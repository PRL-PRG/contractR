type `:::` <character[], character> => list<class<`matrix`> | double | character[] | class<`matrix`> | double | character> | <class<`data.frame`>, list<class<`formula`, `terms`>>, null | character[] | list<character>> => any | <class<`formula`, `terms`>, character[] | null | list<character>> => null;
type `$` <environment, any> => double | <environment> => class<`matrix`> | <environment> => class<`matrix`>;
type `addterm.clm2` <class<`clm2`>, class<`formula`>, double, character, double, logical, logical, character, ...> => class<`anova`, `data.frame`>;
type `adjust_contrast_for_param` <class<`clm`>, list<class<`matrix`>>> => list<class<`matrix`>>;
type `anova.clm` <class<`clm`>, ..., any> => any;
type `anova.clm2` <class<`clm2`, `clmm2`> | class<`clm2`>, ..., character[]> => class<`Anova`, `data.frame`>;
type `anova.clmm2` <class<`clm2`, `clmm2`>, ..., any> => class<`Anova`, `data.frame`>;
type `checkArgs.clm` <class<`call`>> => null;
type `checkContrasts` <class<`formula`, `terms`>, character[] | null | list<character>> => null;
type `clm` <any, any, any, any, any, any, any, logical, any, any, logical, list<any>, character[], character[], ...> => any;
type `clm2` <any, any, any, any, any, any, any, any, any, logical, logical, character[], any, logical, any, character[], ...> => (class<`clm2`> | environment);
type `clm2.control` <character[], ..., double, double, double, double, double> => list<character | double | list<double>>;
type `clm.control` <character[], character[], character[], ..., integer, integer, double, integer, double, double, integer, character[]> => list<character | double | character | double | list<integer>>;
type `clm.finalize` <list<double[] | class<`matrix`> | character | double[] | class<`matrix`> | list<double[] | character> | double[] | class<`matrix`> | list<double[] | null>>, double[], list<character[]>, list<double[]>> => list<any>;
type `clm.fit` <class<`factor`, `ordered`> | list<any>, ...> => class<`clm.fit`>;
type `clm.fit.default` <list<any>, ...> => (class<`clm.fit`> | environment);
type `clm.fit.factor` <class<`factor`, `ordered`>, any, any, any, any, any, any, list<any>, any, logical, character[], character[], ...> => class<`clm.fit`>;
type `clm.fit.flex` <environment, any> => list<double[] | class<`matrix`> | list<double[] | character>>;
type `clm.fit.NR` <environment, list<any>> => any;
type `clm.fit.optim` <environment, character, list<integer>> => list<double[] | class<`matrix`> | list<double[] | character> | double[] | class<`matrix`> | list<double[] | null>>;
type `clm.grad` <environment> => class<`matrix`>;
type `clm.grad_direct` <environment, double[]> => class<`matrix`>;
type `clm.hess` <environment> => class<`matrix`>;
type `clmm` <class<`formula`>, any, any, any, any, any, any, logical, logical, character[], logical, list<any>, double, character[], ...> => any;
type `clmm2` <any, any, any, any, any, any, any, any, any, any, logical, logical, any, any, any, logical, any, double, any, ...> => class<`clm2`, `clmm2`>;
type `clmm2.control` <character[], ..., double, double, double, double, character[]> => list<character | list<double | character>>;
type `clmm.control` <character[], ..., double, double, double, double, logical, character[], character[]> => list<character | logical | list<double | character | double>>;
type `clmm.finalize` <list<any>, list<any>, list<class<`matrix`> | double | character[]>, logical> => class<`clmm`>;
type `clmm.fit.env` <environment, list<double>, character, logical> => list<any>;
type `clmm.fit.ssr` <environment, list<double>, character, logical> => list<double[] | class<`matrix`> | list<class<`matrix`> | double[] | character | double>>;
type `clmm.formulae` <class<`formula`>> => list<class<`formula`>>;
type `clmm.frames` <class<`call`>, list<class<`formula`>>, null> => list<any>;
type `clm.newRho` <environment, class<`factor`> | class<`factor`, `ordered`>, class<`matrix`>, null | class<`matrix`>, class<`matrix`> | null, double[], double[], double[] | null, class<`matrix`>, list<character | double | character | double | list<integer>>, ...> => environment;
type `clm.nll` <environment, any> => double;
type `clm.nll.flex` <environment, any> => double;
type `clm.start` <character[], character, class<`matrix`>, class<`matrix`> | null, null, logical> => double[];
type `coef.clm` <class<`clm`>, logical, ...> => ^double[];
type `coef.summary.clm` <class<`summary.clm`>, logical, ...> => class<`matrix`>;
type `condVar` <class<`clmm`>, ...> => list<class<`data.frame`>>;
type `condVar.clmm` <class<`clmm`>, ...> => list<class<`data.frame`>>;
type `confint.clm` <class<`clm`>, any, double, character[], logical, ...> => class<`matrix`>;
type `confint.profile.clm` <class<`profile.clm`>, integer[], double, ...> => class<`matrix`>;
type `confint.profile.clm2` <class<`profile`, `profile.clmm2`> | class<`profile`, `profile.clm2`>, integer[], double, ...> => class<`matrix`>;
type `confint.profile.clmm2` <class<`profile`, `profile.clmm2`>, integer, double, ...> => class<`matrix`>;
type `containment` <class<`clm`>> => list<character[]>;
type `contestMD` <class<`clm`>, class<`matrix`>, double, any, ...> => class<`data.frame`>;
type `conv.check` <list<any>, list<character | double | character | double | list<integer>>, any, any, ...> => list<any>;
type `convergence` <class<`clm`>, ...> => class<`convergence.clm`>;
type `convergence.clm` <class<`clm`>, any, double, ...> => class<`convergence.clm`>;
type `cor.dec` <double[]> => integer[];
type `dAO` <double[], double, logical> => double[];
type `Deparse` <class<`call`> | class<`formula`> | class<`name`> | double | null, integer, logical, character[], integer> => character;
type `deriv12` <class<`function`>, double[], double, null, ...> => list<double[] | class<`matrix`>>;
type `dfun` <double[], double, double, logical, logical> => double[];
type `dgumbel` <double[], double, double, logical, logical> => double[];
type `dlgamma` <double[], double, logical> => double[];
type `doolittle` <class<`matrix`>, double> => list<class<`matrix`>>;
type `drop.coef` <class<`matrix`>, logical> => class<`matrix`>;
type `drop.coef2` <class<`matrix`>, double, logical, logical> => any;
type `drop.cols` <list<any>, logical, logical> => any;
type `dropterm.clm2` <class<`clm2`>, any, double, character, double, logical, logical, character[], ...> => class<`anova`, `data.frame`>;
type `ensure_full_rank` <class<`matrix`>, double, logical, logical> => class<`matrix`>;
type `expandSlash` <list<class<`call`>>> => list<class<`call`>>;
type `extractAIC.clm` <class<`clm`>, any, double, ...> => double[];
type `extractAIC.clm2` <class<`clm2`>, any, double, ...> => double[];
type `extract_contrasts_type3` <class<`clm`>, class<`matrix`>> => list<class<`matrix`>>;
type `fe.start` <list<any>, character, character> => double[];
type `finalizeRho` <environment> => list<any>;
type `finalizeRhoM` <environment> => list<any>;
type `findbars` <class<`(`> | class<`call`> | class<`name`>> => (class<`call`> | null | list<class<`call`>>);
type `fitCLM` <environment> => null;
type `format.perc` <double[], double> => character[];
type `formatTheta` <any, any, list<any>, any> => list<class<`data.frame`> | class<`matrix`> | logical | class<`matrix`> | logical | logical>;
type `format_tJac` <class<`matrix`>, character[], character[]> => class<`matrix`>;
type `FUN` <class<`call`> | class<`formula`> | class<`name`> | double | null, integer, logical, character[], integer> => character;
type `gauss.hermite` <integer> => list<double[]>;
type `gcauchy` <integer[]> => double[];
type `get_clmDesign` <class<`data.frame`>, list<class<`formula`, `terms`>>, null | character[] | list<character>> => any;
type `get_clmDM` <class<`data.frame`>, class<`formula`, `terms`>, any, logical, character, logical> => list<class<`matrix`> | double[]>;
type `get_clmFormulas` <class<`call`>, environment> => list<class<`formula`>>;
type `get_clmInfoTab` <list<any>, ...> => class<`data.frame`>;
type `get_clm.mf` <class<`call`>, class<`formula`>, any, environment> => any;
type `get_clmRho` <class<`clm`>, ...> => environment;
type `get_clmRho.clm` <class<`clm`>, any, ...> => environment;
type `get_clmRho.default` <class<`data.frame`>, list<class<`formula`, `terms`>>, null | list<character>, character, character, any, null, list<character | double>, ...> => environment;
type `get_clmTerms` <class<`call`>, list<class<`formula`>>, environment> => list<class<`formula`, `terms`>>;
type `get_clmY` <class<`data.frame`>, double[]> => list<class<`factor`, `ordered`> | character[] | class<`factor`> | character[]>;
type `get_contrast_coding` <class<`clm`>, character> => list<character>;
type `getContrasts` <any, character[] | null | list<character>> => (character[] | null | list<any>);
type `get_contrasts_marginal` <class<`clm`>, character[] | null> => list<class<`matrix`>>;
type `get_contrasts_type1` <class<`clm`>> => list<class<`matrix`>>;
type `get_contrasts_type2` <class<`clm`>, character[]> => list<class<`matrix`>>;
type `get_contrasts_type2_unfolded` <class<`clm`>, null> => list<class<`matrix`>>;
type `get_contrasts_type3` <class<`clm`>, null> => list<class<`matrix`>>;
type `getCtrlArgs` <list<any>, list<any>> => list<character | logical | list<double | character | double>>;
type `getDims` <list<any>, list<class<`matrix`> | double | character[]>, list<logical | list<class<`factor`> | integer[] | double | list<class<`dgCMatrix`> | class<`matrix`>>> | logical | list<class<`factor`> | double | list<class<`dgCMatrix`> | class<`matrix`>>>>> => list<integer[] | double | double>;
type `getFittedC` <double[], double[], character, double> => double[];
type `getFullForm` <class<`formula`>, ..., any> => class<`formula`>;
type `getGnll` <environment, any> => double[];
type `getHnll` <environment, double[]> => class<`matrix`>;
type `getLambda` <list<class<`matrix`>>, integer[]> => class<`ddiMatrix`>;
type `get_model_matrix` <class<`clm`>, character, character> => class<`matrix`>;
type `getNLA` <environment, double[], logical[]> => double;
type `getNll` <environment, any> => double;
type `getOffset` <class<`data.frame`>, class<`formula`, `terms`>> => double[];
type `getOffsetStd` <class<`data.frame`>> => double[];
type `getPar` <environment> => double[];
type `getPar.clmm` <environment> => double[];
type `get_rdX` <class<`clm`>, logical> => class<`matrix`>;
type `getREterms` <list<any>, class<`formula`>> => list<logical | list<class<`factor`> | integer[] | double | list<class<`dgCMatrix`> | class<`matrix`>>> | logical | list<class<`factor`> | double | list<class<`dgCMatrix`> | class<`matrix`>>>>;
type `get.se` <environment, class<`matrix`>, character> => double[];
type `getThetamat` <class<`formula`, `terms`>, ^double[], any, any, class<`matrix`>, any, any> => list<class<`data.frame`>>;
type `getWeights` <class<`data.frame`>> => double[];
type `getX` <class<`data.frame`>, class<`data.frame`>, null> => class<`matrix`>;
type `getY` <class<`data.frame`>> => class<`factor`, `ordered`>;
type `getZt` <list<list<class<`dgCMatrix`> | class<`matrix`>>>> => class<`dgCMatrix`>;
type `gfun` <double[], logical> => double[];
type `ggumbel` <double[], logical> => double[];
type `glgamma` <integer[], double> => double[];
type `glogis` <integer[]> => double[];
type `gnorm` <integer[]> => double[];
type `grad.lambda` <environment, double, character, double> => double;
type `grad.u` <environment> => class<`dgeMatrix`>;
type `hess.u` <environment> => logical;
type `logLik.clm` <class<`clm`>, ...> => class<`logLik`>;
type `makeThresholds` <character[], character> => list<class<`matrix`> | double | character[] | class<`matrix`> | double | character>;
type `makeThresholds2` <environment, character, ...> => null;
type `model.frame.clm` <class<`clm`>, ...> => class<`data.frame`>;
type `model_matrix` <class<`clm`>, ...> => class<`matrix`>;
type `model.matrix.clm` <class<`clm`>, character[], ...> => list<class<`matrix`>>;
type `myhess` <class<`function`>, double[], null, double, ...> => class<`matrix`>;
type `namedList` <...> => list<any>;
type `.negLogLikBase` <environment> => null;
type `.negLogLikMfast` <environment> => double;
type `newRho` <environment, class<`matrix`>, class<`matrix`>, class<`matrix`>, class<`factor`, `ordered`> | class<`factor`>, double[], double[], double[], character, null | double, any, character, logical, list<character | double | list<double>>> => environment;
type `nllBase.uC` <environment> => null;
type `nllFast.u` <environment> => double;
type `nll.u` <environment> => double;
type `nobars` <class<`call`> | class<`formula`> | class<`name`> | class<`(`>> => (class<`call`> | class<`formula`> | class<`name`> | null);
type `nobs.clm` <class<`clm`>, ...> => double;
type `nominal_test` <class<`clm`>, ...> => class<`anova`, `data.frame`>;
type `nominal_test.clm` <class<`clm`>, any, logical, ...> => class<`anova`, `data.frame`>;
type `pAO` <double[], double, logical> => double[];
type `par2ST` <double[], list<class<`matrix`>>> => list<class<`matrix`>>;
type `paratBoundary2` <environment | list<any>, double> => integer[];
type `parConstraints` <environment> => double[];
type `pfun` <double[], double, double, logical, logical> => double[];
type `pgumbel` <double[], double, double, logical, logical> => double[];
type `plgamma` <double[], double, logical> => double[];
type `plot.profile.clm` <class<`profile.clm`>, double | integer[], double[], logical, logical, logical, logical, logical, double, logical, ..., null> => list<list<double[]>>;
type `plot.profile.clm2` <class<`profile`, `profile.clmm2`> | class<`profile`, `profile.clm2`>, integer[], double[], logical, logical, logical, double, ..., null | double[]> => (class<`profile`, `profile.clmm2`> | class<`profile`, `profile.clm2`>);
type `plot.profile.clmm2` <class<`profile`, `profile.clmm2`>, integer, double[], logical, logical, logical, double, ..., null> => class<`profile`, `profile.clmm2`>;
type `plot.slice.clm` <class<`slice.clm`>, double | integer[], character[], logical, logical, ...> => null;
type `predict.clm` <class<`clm`>, any, logical, logical, double, character[], any, ...> => any;
type `predict.clm2` <class<`clm2`, `clmm2`>, class<`data.frame`>, ...> => double[];
type `print.conv.check` <list<any>, character, ...> => (character | null);
type `prob.predict.clm` <environment, any, logical, logical, any> => list<double[]>;
type `profile.clm` <class<`clm`>, integer[], integer[], double, double, double, logical, double, list<any>, ...> => class<`profile.clm`>;
type `profile.clm2` <class<`clm2`>, double[], double[], logical, double, double, any, double, double, ...> => class<`profile`, `profile.clm2`>;
type `profile.clm.beta` <class<`clm`>, integer[], double, double, double, logical, double, list<any>, ...> => list<class<`data.frame`>>;
type `profile.clmm2` <class<`clm2`, `clmm2`>, double, double[], double, double, ...> => class<`profile`, `profile.clmm2`>;
type `profile.clm.zeta` <class<`clm`>, integer, double, double, double, logical, double, list<any>, ...> => list<class<`data.frame`>>;
type `profileLambda` <class<`clm2`>, character, any, double, double, ...> => class<`data.frame`>;
type `qgumbel` <double[], double, double, logical, logical> => double[];
type `ranef` <class<`clmm`>, ...> => list<class<`data.frame`>>;
type `ranef.clmm` <class<`clmm`>, logical, ...> => list<class<`data.frame`>>;
type `rbindall` <...> => class<`data.frame`>;
type `response.name` <class<`formula`, `terms`>> => character;
type `rgumbel` <double, double, double, logical> => double[];
type `rho.clm2clmm` <environment, list<logical | list<class<`factor`> | integer[] | double | list<class<`dgCMatrix`> | class<`matrix`>>>>, list<double | character>> => double;
type `rho.clm2clmm.ssr` <environment, list<logical | list<class<`factor`> | double | list<class<`dgCMatrix`> | class<`matrix`>>>>, list<double | character>> => list<class<`matrix`>>;
type `scale_test` <class<`clm`>, ...> => class<`anova`, `data.frame`>;
type `scale_test.clm` <class<`clm`>, any, logical, ...> => class<`anova`, `data.frame`>;
type `set.AGQ` <any, integer, any, any> => any;
type `setLinks` <environment, character> => (double | null);
type `setPar.clmm` <environment, double[], logical[]> => list<class<`matrix`>>;
type `set.start` <environment, any, logical, any, any, list<any>> => any;
type `setStart` <environment> => double[];
type `signif.digits` <double[], double[]> => integer[];
type `single_anova` <class<`clm`>, character[] | double> => any;
type `slashTerms` <class<`call`> | class<`name`>> => (class<`call`> | class<`name`>);
type `slice` <class<`clm`>, ...> => class<`slice.clm`>;
type `slice.clm` <class<`clm`>, integer[], double, double, logical, ...> => class<`slice.clm`>;
type `ST2par` <list<class<`matrix`>>> => double[];
type `start.beta` <class<`matrix`>, logical> => double[];
type `start.threshold` <character[], character> => double[];
type `STconstraints` <list<class<`matrix`>>> => integer[];
type `STstart` <list<class<`matrix`>>> => list<class<`matrix`>>;
type `subbars` <class<`(`> | class<`call`> | class<`formula`> | class<`name`> | double> => (class<`(`> | class<`call`> | class<`formula`> | class<`name`> | double);
type `summary.clm` <class<`clm`>, double, ...> => class<`summary.clm`>;
type `summary.clm2` <class<`clm2`>, double, logical, ...> => class<`summary.clm2`>;
type `summary.clmm` <class<`clmm`>, logical, ...> => class<`summary.clmm`>;
type `summary.clmm2` <class<`clm2`, `clmm2`>, double, logical, ...> => class<`summary.clmm2`>;
type `term2colX` <class<`formula`, `terms`>, class<`matrix`>> => list<double[]>;
type `term_contain` <character, class<`matrix`>, character[], character[]> => logical[];
type `terms.clm` <class<`clm`>, character[], ...> => (class<`formula`, `terms`> | list<class<`formula`, `terms`>>);
type `test_no_ranef` <list<list<class<`dgCMatrix`> | class<`matrix`>>>, list<any>, character> => null;
type `update.clm2` <class<`clm2`>, any, any, any, any, ..., logical> => (class<`clm2`> | environment);
type `update.clmm2` <class<`clm2`, `clmm2`>, any, any, any, any, ..., logical> => class<`clm2`, `clmm2`>;
type `update.u` <environment> => logical;
type `update.uC` <environment> => logical;
type `VarCorr` <class<`clmm`>, ...> => list<class<`matrix`>>;
type `VarCorr.clmm` <class<`clmm`>, ...> => list<class<`matrix`>>;
type `varcov` <class<`clmm`>, logical, any, ...> => list<class<`matrix`>>;
type `vcov.clm` <class<`clmm`> | class<`clm`>, any, character[], ...> => class<`matrix`>;
type `vcov.clm2` <class<`clm2`>, ...> => class<`matrix`>;
type `vcov.clmm` <class<`clmm`>, ...> => class<`matrix`>;
type `vcov.clmm2` <class<`clm2`, `clmm2`>, ...> => class<`matrix`>;
