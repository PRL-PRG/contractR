type `AMUSE.default` <^double[], double, ???> => struct<`W`:^double[], `EV`:double[], `k`:double, `S`:^double[]>;
type `AMUSE.ts` <^double[], double> => struct<`W`:^double[], `EV`:double[], `k`:double, `S`:^double[]>;
type `bss.components` <struct<`W`:^double[], `EV`:double[], `k`:double, `S`:^double[]>> => ^double[];
type `cjd` <^complex[], double, double> => struct<`V`:^complex[], `D`:^complex[]>;
type `coef.bss` <struct<`A`:^double[], `W`:^double[], `S`:^double[], `Xmu`:double[]> | struct<`W`:^double[], `EV`:double[], `k`:double, `S`:^double[]> | struct<`W`:^double[], `EV`:double[], `n.cut`:double[], `S`:^double[]> | struct<`W`:^double[], `EV`:double[], `Xmu`:double[], `S`:^double[]> | struct<`W`:^double[], `k`:double[], `n.cut`:double[], `K`:double, `S`:^double[]> | struct<`W`:^double[], `k`:integer[], `method`:character, `S`:^double[]>, ???> => ^double[];
type `djd` <double[], character | integer[], double, double, double> => ^double[];
type `djd.log` <double[], ^double[], ^double[], integer, integer, double, double> => ^double[];
type `djd.max` <double[], ^double[], double, integer, integer, double, double, double> => ^double[];
type `filter` <character[]> => logical[];
type `frjd` <^double[], null, double, double, any => any> => struct<`V`:^double[], `D`:^double[], `iter`:double>;
type `frjd.int` <double[], double, double> => struct<`V`:^double[], `D`:double[], `iter`:double>;
type `FUN` <double[] | struct<>, ^double[]> => double | struct<>;
type `M.x` <^double[], double> => ^double[];
type `MD` <^double[], ^double[]> => double;
type `multscatter` <character[], ^double[], logical> => double[];
type `NSS.JD.default` <^double[], double, double, ? double[], double, double, ???> => struct<`W`:^double[], `k`:double, `n.cut`:double[], `K`:double, `S`:^double[]>;
type `NSS.SD.default` <^double[], ? double[], ???> => struct<`W`:^double[], `EV`:double[], `n.cut`:double[], `S`:^double[]>;
type `NSS.TD.JD.default` <^double[], double, double[], ? double[], double, double, ???> => struct<`W`:^double[], `k`:double[], `n.cut`:double[], `K`:double, `S`:^double[]>;
type `plot.bss` <struct<`A`:^double[], `W`:^double[], `S`:^double[], `Xmu`:double[]> | struct<`W`:^double[], `EV`:double[], `k`:double, `S`:^double[]> | struct<`W`:^double[], `EV`:double[], `n.cut`:double[], `S`:^double[]> | struct<`W`:^double[], `k`:double[], `method`:character, `S`:^double[]> | struct<`W`:^double[], `k`:double, `n.cut`:double[], `K`:double, `S`:^double[]> | struct<`W`:^double[], `k`:integer[], `n.cut`:double[], `K`:double, `S`:^double[]>, ??? | character> => null;
type `pMatrix.min` <^double[]> => struct<`A`:^double[], `pvec`:double[]>;
type `rand_orth` <double, ? ^double[]> => ^double[];
type `SOBI.default` <^double[], double[], character, double, double, ???> => struct<`W`:^double[], `k`:double[], `method`:character, `S`:^double[]>;
type `SOBI.ts` <^double[], double[]> => struct<`W`:^double[], `k`:double[], `method`:character, `S`:^double[]>;
