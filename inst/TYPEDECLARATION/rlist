type `args_env` <..., environment> => environment;
type `createCallClosure` <any> => class<`function`>;
type `createListClosure` <any, any> => class<`function`>;
type `dots` <...> => (list<class<`call`>> | list<class<`name`> | class<`call`>> | list<class<`name`>> | list<class<`name`> | class<`(`>>);
type `.evalwith` <character[] | double[] | list<double | character[] | list<double>> | list<character | double> | list<list<character | list<double>>> | list<character | list<double>>> => (null | list<double | character[] | list<double>> | list<character | double> | list<list<character | list<double>>> | list<character | list<double>> | list<double>);
type `getnames` <list<class<`name`> | class<`call`>> | list<class<`name`>> | list<double[]> | list<list<list<character | list<double>>>> | list<list<double | character[] | list<double>>> | list<list<character | double>> | list<list<character | list<double>>> | list<character[]> | double[], any> => character[];
type `is.empty` <double[] | list<any>> => logical;
type `is.error` <class<`try-error`> | double> => logical;
type `is.formula` <class<`call`> | class<`name`>> => logical;
type `lambda` <class<`call`> | class<`lambda_expression`> | class<`name`>> => class<`lambda_expression`>;
type `List` <any> => class<`List`, `environment`>;
type `[<-.List` <class<`List`, `environment`>, ..., null | double> => class<`List`, `environment`>;
type `[.List` <class<`List`, `environment`>, ...> => (class<`List`, `environment`> | double | list<double>);
type `[[<-.List` <class<`List`, `environment`>, ..., null | double> => class<`List`, `environment`>;
type `[[.List` <class<`List`, `environment`>, ...> => (class<`List`, `environment`> | double | list<double>);
type `$<-.List` <class<`List`, `environment`>, ..., null | double> => class<`List`, `environment`>;
type `list.all` <list<list<character | list<double>>>, any, logical> => (logical | null);
type `list.any` <list<list<character | list<double>>>, any, logical> => logical;
type `list.cases` <list<list<character | list<double>>> | list<character[]>, any, logical, logical> => (character[] | double[]);
type `list.cbind` <list<class<`data.frame`>>> => class<`data.frame`>;
type `list.class` <list<list<double | character[] | list<double>>>, ..., logical> => list<list<list<double | character[] | list<double>>>>;
type `list.clean` <list<null> | list<null | character[]> | list<character[]> | list<character | null> | list<character[] | null> | list<^double[] | null> | list<double[] | null> | list<double | null> | list<null | double | list<null | character[]>> | list<class<`data.frame`>> | list<list<double>> | list<double> | list<list<character | list<double>>>, class<`function`>, logical> => list<any>;
type `list.common` <list<list<character | list<double>>> | list<character[]>, any> => character[];
type `list.count` <list<list<character | list<double>>>, any> => integer;
type `list.do` <list<class<`data.frame`>> | list<double[]>, character | class<`function`>, ...> => (class<`data.frame`> | class<`matrix`>);
type `list.exclude` <list<list<character | list<double>>>, any> => list<list<character | list<double>>>;
type `list.expand` <...> => (list<list<character[] | list<double | character>>> | list<list<double[] | character>> | list<list<integer | character>>);
type `list.filter` <list<list<character | list<double>>>, ...> => list<list<character | list<double>>>;
type `list.find` <list<list<character | list<double>>>, any, double> => list<list<character | list<double>>>;
type `list.findi` <list<list<character | list<double>>>, any, double> => integer[];
type `list.findi.internal` <list<list<character | list<double>>>, class<`call`>, environment, double, logical> => integer[];
type `list.first` <list<list<character | list<double>>>, any> => (null | list<character | list<double>>);
type `list.first.internal` <list<list<character | list<double>>>, class<`call`> | class<`lambda_expression`>, environment, logical> => (list<logical> | list<logical | list<character | list<double>>> | list<null | list<character | list<double>>>);
type `list.flatten` <list<double | list<double | double | list<character>>> | list<double | list<character | double>>, logical, character> => (list<double | character> | list<double> | list<character>);
type `List_get` <any, list<double> | double, pairlist, any> => (class<`List`, `environment`> | double | list<double>);
type `list.group` <list<list<character | list<double>>>, ..., logical> => list<list<list<character | list<double>>>>;
type `list.group.internal` <list<list<character | list<double>>> | list<list<double | character[] | list<double>>>, list<any>, any, any, any, any> => (list<list<list<character | list<double>>>> | list<list<list<double | character[] | list<double>>>> | list<list<double | character[] | list<double>>> | list<list<character | list<double>>>);
type `list.is` <list<list<character | list<double>>>, any, logical> => logical[];
type `list.is.internal` <list<list<character | list<double>>>, class<`call`>, environment> => logical[];
type `list.iter` <list<list<character | list<double>>>, any> => list<list<character | list<double>>>;
type `list.join` <list<list<character | double>>, list<list<character | double>>, any, any, ..., logical> => list<list<character | double>>;
type `list.last` <list<list<character | list<double>>>, any> => (null | list<character | list<double>>);
type `list.map` <list<double[]> | list<list<list<character | list<double>>>> | list<list<character | list<double>>>, any> => (list<double> | list<double | null> | list<character> | list<list<double>>);
type `list.map.internal` <list<list<character | list<double>>> | list<character[]> | double[] | list<list<character | double>> | list<double[]> | list<list<list<character | list<double>>>> | list<list<double | character[] | list<double>>>, class<`call`> | class<`lambda_expression`> | class<`name`>, environment, class<`function`>, environment | null> => any;
type `list.mapv` <list<list<character | list<double>>>, any, any, logical> => (character[] | double[]);
type `list.match` <list<list<character | list<double>>>, character, ...> => list<list<character | list<double>>>;
type `list.merge` <...> => list<double | list<double>>;
type `list.names` <double[] | list<list<character | double>>, any> => (character[] | double[] | null | list<list<character | double>>);
type `list.order` <list<list<character | list<double>>>, ..., logical, logical> => integer[];
type `list.order.internal` <list<list<character | list<double>>>, list<class<`call`>> | list<class<`name`> | class<`(`>>, environment, logical | null> => integer[];
type `list.parse` <class<`data.frame`> | character | class<`matrix`>, ...> => (list<list<integer | class<`factor`>>> | list<list<character | logical>> | list<list<double>>);
type `list.parse.character` <character, character, ...> => list<list<character | logical>>;
type `list.parse.data.frame` <class<`data.frame`>, ...> => list<list<integer | class<`factor`>>>;
type `list.parse.matrix` <class<`matrix`>, ...> => list<list<double>>;
type `list.prepend` <list<double>, ...> => list<double[]>;
type `list.rbind` <list<class<`data.frame`>> | list<double[]>> => (class<`data.frame`> | class<`matrix`>);
type `list.remove` <list<list<character | list<double>>>, character | double[]> => list<list<character | list<double>>>;
type `list.reverse` <list<double>> => list<double>;
type `list.sample` <list<double[]>, double, logical, any, null> => list<double[]>;
type `list.search` <list<list<character | double | character[] | double[] | character[] | ^double[]>> | list<list<character[] | double>> | list<list<character | double>>, any, character, any, logical> => list<any>;
type `list.select` <list<list<character | list<double>>>, ...> => (list<list<character>> | list<list<character | double[]>> | list<list<character | list<double>>>);
type `List_set` <class<`name`>, list<double>, pairlist, double | null, environment> => class<`List`, `environment`>;
type `list.skip` <list<double>, double> => list<double>;
type `list.skipWhile` <list<list<character | list<double>>>, any> => list<list<character | list<double>>>;
type `list.sort` <list<list<character | list<double>>>, ..., null> => list<list<character | list<double>>>;
type `list.table` <list<list<character | list<double>>>, ..., list<character[]>> => class<`table`>;
type `list.take` <list<double>, double, logical> => list<double>;
type `list.takeWhile` <list<list<character | list<double>>>, any> => list<any>;
type `list.ungroup` <list<list<list<list<double>>>> | list<list<list<character | list<double>>>>, double, ..., logical, logical> => (list<list<list<double>>> | list<list<double>> | list<list<character | list<double>>>);
type `list.unzip` <list<list<double>> | list<list<double | character[] | list<list<character>>>>, character[], ..., character, null> => (list<^double[]> | list<^double[] | list<double>> | list<double[] | class<`data.frame`> | class<`matrix`>>);
type `list.update` <list<list<character | list<double>>>, ..., logical> => (list<list<character | list<double>>> | list<list<character | integer | list<double>>> | list<list<character | double | list<double>>>);
type `list.which` <list<list<character | list<double>>>, any> => integer[];
type `list.zip` <..., logical, logical> => list<list<double | character>>;
type `map` <class<`function`>, list<integer[] | character[] | list<list<character | list<double>>>> | list<integer[] | character | list<character[]>> | list<double[] | character> | list<integer[] | character | list<list<character | double>>> | class<`data.frame`> | list<list<double | character>> | list<integer[] | character[] | list<double[]>> | list<integer[] | character[] | list<list<list<character | list<double>>>>> | list<integer[] | character[] | list<list<double | character[] | list<double>>>> | list<integer[] | character[] | list<list<character | double>>> | list<integer | character | list<list<character | list<double>>>> | list<list<list<character | double>>> | list<list<list<character | list<double> | double>>> | list<list<integer | list<character | list<double>>>> | list<list<double | list<character | list<double>>>> | list<integer[] | character[] | list<character[]>>, null, logical> => any;
type `ndots` <pairlist> => logical;
type `reduce` <class<`function`>, list<character[]> | list<class<`function`>> | list<list<double | list<double>>> | list<class<`call`>>, character[] | list<any>, ...> => (character[] | class<`data.frame`> | class<`matrix`> | ^double[] | list<double | list<double>> | list<double> | list<list<character | list<double>>>);
type `set_argnames` <list<class<`name`>> | list<class<`name`> | class<`call`>>, list<list<double | character>> | list<class<`name`>> | list<class<`name`> | class<`call`>>> => (list<list<double | character>> | list<class<`name`>> | list<class<`name`> | class<`call`>>);
type `subset.list` <list<list<character | list<double>>>, any, any, ...> => (list<class<`data.frame`>> | list<list<double>> | list<double> | list<list<character | list<double>>>);
type `tryEval` <any, null> => (double | null);
type `tryGet` <any, double, ..., environment> => double;
type `tryWithCondition` <any, ...> => (null | list<null> | list<null | list<null | list<character | list<double>>>>);
