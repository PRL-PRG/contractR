type `::` <class<`matrix`> | class<`Lexis`, `data.frame`>, logical | list<double[]>, double, double, double, logical, logical, double, double, logical | character, any, logical, logical, any, any, double, any, any, logical, logical> => class<`MS`>;
type `addCov.Lexis` <class<`Lexis`, `data.frame`>, class<`data.frame`>, double, any, character, logical> => class<`Lexis`, `data.frame`>;
type `apc.fit` <class<`data.frame`>, any, any, any, any, any, any, character[], character[], character, character[], double[] | list<double[]>, double, double, logical> => class<`apc`>;
type `apc.frame` <double[], double[], double[], double[], double, double[], double[], double[], double[], double, character, character, character, character, logical, double, character, double[]> => double[];
type `apc.LCa` <class<`data.frame`>, logical, ...> => list<class<`matrix`> | class<`apc`> | list<class<`LCa`>>>;
type `apc.lines` <class<`apc`>, any, any, character[], double[], double, any, any, any, logical[], double[], double[], character, character, logical, logical, ...> => list<class<`matrix`>>;
type `apc.plot` <class<`apc`>, character, ...> => double[];
type `Aplot` <class<`matrix`>, double[], any, logical, logical, logical, character, double[], double[], double[] | null, any, character, character, character, double, double, any, character, double, any> => null;
type `array.subset` <double[], double[], double[]> => (class<`array`> | class<`matrix`>);
type `as.Date.cal.yr` <class<`cal.yr`, `numeric`>, ...> => class<`Date`>;
type `bootLexis` <class<`Lexis`, `data.frame`>, double[] | null, character | null, logical> => class<`Lexis`, `data.frame`>;
type `boxarr` <double[], double[], double[], double, ...> => list<double[]>;
type `boxes` <class<`Lexis`, `data.frame`> | class<`matrix`> | class<`MS`>, ...> => (class<`MS`> | null);
type `boxes.Lexis` <class<`matrix`> | class<`Lexis`, `data.frame`>, logical | list<double[]>, double, double, double, logical, logical, double, double, logical | character, any, logical, logical, any, any, double, any, any, logical, logical> => class<`MS`>;
type `boxes.matrix` <class<`matrix`>, ...> => class<`MS`>;
type `boxes.MS` <class<`MS`>, any, any, double, ...> => null;
type `cal.yr` <character[] | class<`Date`> | class<`factor`> | class<`data.frame`>, character, null | integer[]> => (class<`cal.yr`, `numeric`> | class<`data.frame`>);
type `ccwc` <any, any, any, any, double, any, any, class<`data.frame`>, logical> => class<`data.frame`>;
type `check.time.scale` <class<`Lexis`, `data.frame`>, character[] | null | double> => character[];
type `chop.lex` <class<`Lexis`, `data.frame`>, character[], double> => class<`Lexis`, `data.frame`>;
type `ci.cum` <class<`gam`, `glm`, `lm`> | class<`glm`, `lm`>, class<`data.frame`>, any, double, double, logical, logical, logical> => class<`matrix`>;
type `ci.dfr` <class<`gam`, `glm`, `lm`> | class<`glm`, `lm`> | class<`lm`>, class<`data.frame`>, class<`data.frame`>, null | character, any, any, any, any> => any;
type `ci.exp` <..., logical, logical> => class<`matrix`>;
type `ci.lin` <any, any, null | character[] | double | integer[], null, null | character, logical, any, any, any, double, any, any> => any;
type `ci.mat` <double, double> => class<`matrix`>;
type `ci.pd` <class<`array`> | class<`matrix`> | integer, null | integer, null | integer, null | integer, character, double, double, double, logical, logical> => class<`matrix`>;
type `ci.pred` <class<`gam`, `glm`, `lm`> | class<`glm`, `lm`>, class<`data.frame`>, null, double> => class<`matrix`>;
type `ci.ratio` <class<`matrix`>, class<`matrix`>, null, null, logical, double, logical> => class<`matrix`>;
type `ci.surv` <class<`gam`, `glm`, `lm`> | class<`glm`, `lm`>, class<`data.frame`>, null, double, double, logical, logical> => class<`matrix`>;
type `clear` < > => null;
type `clogistic` <class<`formula`>, any, any, any, any, any, logical, logical, logical, null, double, double, double> => class<`clogistic`>;
type `COEF` <class<`clogit`, `coxph`> | class<`glm`, `lm`> | class<`lm`> | class<`gam`, `glm`, `lm`> | class<`crr`>, ...> => ^double[];
type `COEF.crr` <class<`crr`>, ...> => double[];
type `COEF.default` <class<`clogit`, `coxph`> | class<`glm`, `lm`> | class<`lm`> | class<`gam`, `glm`, `lm`>, ...> => ^double[];
type `contr.2nd` <double> => class<`matrix`>;
type `contr.cum` <double> => class<`matrix`>;
type `contr.diff` <double> => class<`matrix`>;
type `contr.orth` <double> => class<`matrix`>;
type `count` <any> => (class<`array`> | class<`matrix`>);
type `Cplot` <class<`matrix`>, double[], double[], any, logical, logical, character, null, double[], double[] | null, any, character, character, character, double, double, character[], character, double, any> => null;
type `crr.Lexis` <class<`Lexis`, `data.frame`>, class<`formula`>, logical, ...> => class<`crr`>;
type `cutLexis` <class<`Lexis`, `data.frame`>, class<`data.frame`> | ^double[], double | character, any, logical | character, logical, logical, double | integer[] | null | character[], logical> => class<`Lexis`, `data.frame`>;
type `df2ctr` <class<`glm`, `lm`> | class<`lm`> | class<`gam`, `glm`, `lm`>, class<`data.frame`>> => (class<`matrix`> | list<any>);
type `doCutLexis` <class<`Lexis`, `data.frame`>, ^double[], character, logical> => class<`Lexis`, `data.frame`>;
type `dur` <class<`Lexis`, `data.frame`>, logical> => double[];
type `effx` <any, character, null, any, any, any, null, null | character, double, double, double, class<`data.frame`>> => (null | list<class<`matrix`> | character>);
type `effx.match` <any, any, any, any, any, double, double, double, class<`data.frame`>> => (null | list<class<`matrix`> | character>);
type `entry` <class<`Lexis`, `data.frame`>, character | double, logical> => double[];
type `etm.Lexis` <class<`Lexis`, `data.frame`>, double, character, double, character, logical, logical, ...> => class<`etm`>;
type `exit` <class<`Lexis`, `data.frame`>, null | character, logical> => (class<`matrix`> | double[]);
type `expand.data` <class<`matrix`>, class<`formula`>, double[], class<`data.frame`>> => list<class<`data.frame`> | double[]>;
type `factorize.Lexis` <class<`Lexis`, `data.frame`>, character[] | null | list<character[]>, logical, ...> => class<`Lexis`, `data.frame`>;
type `fgrep` <character, character[] | class<`factor`>, ...> => (character[] | class<`factor`>);
type `fillarr` <double, double, double, double, double, double, double, double, any, ...> => null;
type `fit.add` <double[], class<`data.frame`>, class<`data.frame`>, any> => list<class<`glm`, `lm`>>;
type `fit.baseline` <double[], class<`data.frame`>, any> => class<`glm`, `lm`>;
type `fitClogit` <class<`matrix`>, double[], null, double[], double[], double, double, double> => list<double[] | class<`matrix`>>;
type `fit.mult` <double[], class<`data.frame`>, class<`data.frame`>, any> => list<class<`glm`, `lm`> | double>;
type `fixEvent` <double[]> => integer[];
type `FUN` <class<`Lexis`, `data.frame`>, logical, double, null | logical[], logical, logical, ...> => (class<`summary.Lexis`> | list<class<`summary.Lexis`>>) | <class<`Lexis`, `data.frame`>, null | character, ...> => integer[];
type `gen.exp` <class<`data.frame`>, character, character, character, character, class<`data.frame`>, character, character, double[], logical, double, logical, double[], double, character, double> => class<`data.frame`>;
type `get.ests` <class<`matrix`>, ...> => class<`matrix`>;
type `get.next` <class<`Lexis`, `data.frame`>, character[], any, any> => class<`Lexis`, `data.frame`>;
type `harm` <double[], double, double, logical> => class<`matrix`>;
type `Icens` <any, any, any, class<`formula`>, character, double[], logical, double, logical, class<`data.frame`>> => class<`Icens`>;
type `id.span` <class<`matrix`>, class<`matrix`>, double> => logical;
type `in.span` <class<`matrix`>, class<`matrix`> | integer[], logical, double> => (class<`matrix`> | logical);
type `interp` <double, double[], class<`data.frame`>> => class<`matrix`>;
type `isInformative` <list<class<`matrix`>>, list<integer[]>, double[]> => logical[];
type `LCa.fit` <class<`data.frame`>, any, any, any, any, character, any, any, any, any, any, double[], logical, double, double, double, logical> => class<`LCa`>;
type `levels.Lexis` <class<`Lexis`, `data.frame`>> => (character[] | null);
type `Lexis` <any, any, any, character | class<`factor`> | double[], any, any, any, logical, any, logical, double, logical> => class<`Lexis`, `data.frame`>;
type `[.Lexis` <class<`Lexis`, `data.frame`>, ...> => (^character[] | class<`cal.yr`, `numeric`> | class<`factor`> | class<`Lexis`, `data.frame`> | ^double[]);
type `Lexis.diagram` <double[], character, double[], character, double, double[], character, double, logical, logical, logical, character, double, double, any, any, any, any, any, any> => (class<`data.frame`> | null);
type `Lexis.lines` <class<`cal.yr`, `numeric`> | null, class<`cal.yr`, `numeric`> | null, any, any, null | double[], any, character, double, any, double, ^double[], ^character[], class<`data.frame`> | null> => class<`data.frame`>;
type `lgrep` <character, class<`factor`>, ...> => character[];
type `Life.lines` <class<`cal.yr`, `numeric`> | null, class<`cal.yr`, `numeric`> | null, class<`cal.yr`, `numeric`> | double[] | class<`Date`>, null | double[], null | double[], class<`cal.yr`, `numeric`> | double[]> => class<`data.frame`>;
type `linesEst` <class<`matrix`>, integer[], double, double, double, character, character[], character[], ...> => null;
type `lines.pState` <class<`matrix`, `pState`>, character[], character, ...> => null;
type `lint` <double[], double[], double> => double;
type `list.lex` <class<`Lexis`, `data.frame`>, double, character> => null;
type `lls` <double, character, logical, logical> => (class<`data.frame`> | null);
type `mat2pol` <class<`matrix`>, integer[], any, character[], integer[], logical, ...> => class<`matrix`>;
type `match.cut` <class<`Lexis`, `data.frame`>, class<`data.frame`>> => class<`Lexis`, `data.frame`>;
type `matshade` <double[], class<`matrix`>, double, integer | character[], integer | character[], double, logical, ...> => null;
type `mcutLexis` <class<`Lexis`, `data.frame`>, character, character[], character[], character, logical, character[], logical> => class<`Lexis`, `data.frame`>;
type `merge.Lexis` <class<`Lexis`, `data.frame`>, class<`data.frame`> | class<`Lexis`, `data.frame`>, any, any, ...> => class<`Lexis`, `data.frame`>;
type `mh` <class<`array`>, class<`array`>, character, character[] | double[], null | character[], logical, double> => class<`mh`>;
type `model.terms` <class<`LCa`>> => list<logical>;
type `msdata.Lexis` <class<`Lexis`, `data.frame`>, character, ...> => class<`data.frame`>;
type `N2Y` <any, any, any, class<`data.frame`>, logical> => (class<`array`> | class<`data.frame`>);
type `NArray` <list<character[] | integer[]>, null> => (class<`array`> | class<`matrix`>);
type `ncut` <double[], double[], character> => ^double[];
type `ngrep` <character, class<`factor`>, ...> => null;
type `nice` <double[], logical, any, ...> => double[];
type `nid` <class<`Lexis`, `data.frame`>, ...> => integer[];
type `nid.Lexis` <class<`Lexis`, `data.frame`>, null | character, ...> => integer[];
type `Ns` <double[], double | null, null | double, double[] | null, logical, null, logical[], logical> => class<`basis`, `cns`, `matrix`>;
type `ns.ld` <double[], double | null, null | double[], logical, double[], logical[]> => class<`basis`, `cns`, `matrix`>;
type `nState` <class<`Lexis`, `data.frame`>, double[], double, character> => class<`table`>;
type `pc.points` <double, double, ...> => null;
type `pctab` <class<`array`, `table`> | class<`table`>, double, double> => class<`array`, `table`>;
type `percent` <...> => (class<`array`> | class<`matrix`>);
type `plotCIF` <class<`survfit`, `survfitms`>, double, character, character, double[], double, character[], ...> => null;
type `plotEst` <class<`matrix`>, integer[], character[] | expression, integer[], double[], character, double[], double[], logical, double, double, double, character, character, double, character[], character[], double | null, logical, any> => list<double[]>;
type `plot.LCa` <class<`LCa`>, ...> => double[];
type `plot.Lexis` <class<`Lexis`, `data.frame`>, null, character, character, ...> => null;
type `plot.Lexis.2D` <class<`Lexis`, `data.frame`>, character[], character, character, character, any, any, any, any, double[], character, double, logical, ...> => null;
type `plot.pState` <class<`matrix`, `pState`>, character[], character, character, integer[], character, ...> => null;
type `points.Lexis` <class<`Lexis`, `data.frame`>, character[], ...> => null;
type `points.Lexis.2D` <class<`Lexis`, `data.frame`>, character[], ...> => null;
type `Pplot` <class<`matrix`>, any, double[], any, logical, logical, character, double[], double[], character, character, double[] | null, any, character, double, double, character[], character, double, logical> => null;
type `predict.LCa` <class<`LCa`>, class<`data.frame`>, double, any, double, ...> => class<`matrix`>;
type `pretty.print.stattable.2d` <class<`array`, `stat.table`>, double, double[]> => class<`array`, `stat.table`>;
type `print.Icens` <class<`Icens`>, double, double, ...> => class<`matrix`>;
type `print.LCa` <class<`LCa`>, ...> => null;
type `print.stat.table` <class<`array`, `stat.table`>, double, any, ...> => class<`array`, `stat.table`>;
type `projection.ip` <class<`matrix`>, class<`matrix`>, logical, double[]> => class<`matrix`>;
type `pState` <class<`table`>, double[]> => class<`matrix`, `pState`>;
type `PY.ann` <class<`Lexis`, `data.frame`>, ...> => null;
type `PY.ann.Lexis` <class<`Lexis`, `data.frame`>, character[], double, ...> => null;
type `rateplot` <class<`matrix`>, character[], double[], double[], logical, logical, logical, logical, logical, character, double[], double[], null, double[], double[] | null, any, character, character, character, character> => null;
type `Relevel` <class<`factor`> | class<`Lexis`, `data.frame`>, ...> => any;
type `Relevel.factor` <class<`factor`>, character[] | class<`data.frame`> | double | integer[] | list<character[] | double[] | integer[] | character[]>, logical, character, logical, logical, ...> => any;
type `Relevel.Lexis` <class<`Lexis`, `data.frame`>, character[] | null | list<character[]>, logical, ...> => class<`Lexis`, `data.frame`>;
type `rm.tr` <class<`Lexis`, `data.frame`>, character, character> => class<`Lexis`, `data.frame`>;
type `ROC` <null, null, class<`formula`>, character, logical, logical, logical, logical, logical, double[], any, null, double, environment, ...> => list<class<`data.frame`> | double | class<`glm`, `lm`>>;
type `ROC.tic` <double, character, double, double, character, double, double[], class<`data.frame`>> => null;
type `setStatus.factor` <class<`Lexis`, `data.frame`>, ^character[], null | character[], logical> => class<`Lexis`, `data.frame`>;
type `setStatus.numeric` <class<`Lexis`, `data.frame`>, ^double[], double | integer[] | null, logical> => class<`Lexis`, `data.frame`>;
type `show.apc.LCa` <list<class<`matrix`> | class<`apc`> | list<class<`LCa`>>>, logical, character, ...> => class<`MS`>;
type `simLexis` <list<list<class<`glm`, `lm`> | class<`coxph`> | class<`coxph`> | class<`glm`, `lm`>>>, class<`Lexis`, `data.frame`>, double, any, double, double, double[]> => class<`Lexis`, `data.frame`>;
type `splitLexis` <class<`Lexis`, `data.frame`>, double[], character, double> => class<`Lexis`, `data.frame`>;
type `split.lexis.1D` <class<`Lexis`, `data.frame`>, double[], character, double> => class<`Lexis`, `data.frame`>;
type `splitMatrix` <class<`matrix`>, double[], logical> => list<class<`matrix`>>;
type `split.to.width` <character, double> => character;
type `stackedCIF` <class<`survfit`, `survfitms`>, double, character, character, double[], character, character, ...> => null;
type `stack.Lexis` <class<`Lexis`, `data.frame`>, ...> => class<`data.frame`, `stacked.Lexis`>;
type `stat.table` <any, any, class<`data.frame`>, logical[]> => (class<`array`, `stat.table`> | class<`matrix`, `stat.table`>);
type `status` <class<`Lexis`, `data.frame`>, character, logical> => (class<`factor`> | double[]);
type `std.vec` <double, double> => double[];
type `subid.Lexis` <class<`Lexis`, `data.frame`>, integer[]> => class<`Lexis`, `data.frame`>;
type `subset.Lexis` <class<`Lexis`, `data.frame`>, ...> => class<`Lexis`, `data.frame`>;
type `summary.Icens` <class<`Icens`>, double, ...> => class<`matrix`>;
type `summary.LCa` <class<`LCa`>, logical, ...> => class<`matrix`>;
type `summary.Lexis` <class<`Lexis`, `data.frame`>, logical, double, null | logical[], logical, logical, ...> => (class<`summary.Lexis`> | list<class<`summary.Lexis`>>);
type `tbox` <character, double, double, double, double, double, double, character, character, character> => double[];
type `Termplot` <class<`glm`, `lm`>, logical, null, null, logical, double, double, null, null> => list<class<`matrix`>>;
type `thinCol` <class<`matrix`>, double, logical> => class<`matrix`>;
type `timeBand` <class<`Lexis`, `data.frame`>, character, character> => (class<`factor`> | double[]);
type `timeScales` <class<`Lexis`, `data.frame`>> => character[];
type `timeSince` <class<`Lexis`, `data.frame`>> => character[];
type `tmat` <class<`Lexis`, `data.frame`>, ...> => class<`matrix`>;
type `tmat.Lexis` <class<`Lexis`, `data.frame`>, logical, character, ...> => class<`matrix`>;
type `transform.Lexis` <class<`Lexis`, `data.frame`>, ...> => class<`Lexis`, `data.frame`>;
type `tRelevel` <any, class<`data.frame`>, any, any> => any;
type `twoby2` <character[] | class<`matrix`> | class<`table`>, any, double, logical, double, any, double> => list<class<`matrix`> | double[]>;
type `use.amt.dpt` <class<`data.frame`>, double, logical> => class<`data.frame`>;
type `use.only.amt` <class<`data.frame`>, double> => class<`data.frame`>;
type `valid.times` <class<`Lexis`, `data.frame`>, character[]> => class<`Lexis`, `data.frame`>;
type `VCOV` <class<`crr`> | class<`clogit`, `coxph`> | class<`gam`, `glm`, `lm`> | class<`glm`, `lm`> | class<`lm`>, ...> => class<`matrix`>;
type `VCOV.crr` <class<`crr`>, ...> => class<`matrix`>;
type `VCOV.default` <class<`clogit`, `coxph`> | class<`gam`, `glm`, `lm`> | class<`glm`, `lm`> | class<`lm`>, ...> => class<`matrix`>;
type `Wald` <class<`lm`>, double, ...> => double[];
type `wh.no` <class<`matrix`>, integer, integer> => integer;
