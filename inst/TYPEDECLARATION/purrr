type `%@%` <class<`factor`> | class<`data.frame`>, character> => character[];
type `accum_index` <list<any>, logical> => integer[];
type `accum_init` <character | integer, integer[], logical> => list<any>;
type `accumulate` <character[] | integer[], class<`function`>, ..., any, character[]> => (character[] | integer[]);
type `accumulate2` <character[], character[], class<`function`>, ..., any> => list<character>;
type `accumulate_names` <null, any, any> => null;
type `array_branch` <class<`array`> | integer[] | class<`matrix`>, null | double[]> => list<class<`matrix`> | integer[]>;
type `array_tree` <class<`array`> | integer[] | class<`matrix`>, double[] | null> => list<integer[] | list<integer[] | list<integer>>>;
type `as_invoke_function` <character[] | list<class<`function`>>> => (character[] | list<class<`function`>>);
type `as_mapper` <character[] | class<`function`> | double[] | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`formula`> | class<`function`, `rlang_lambda_function`> | list<character | double | double | character | double | class<`function`>>, ...> => (class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`function`, `rlang_lambda_function`>);
type `as_mapper.character` <character[] | double[], ..., any, null | character> => class<`function`>;
type `as_mapper.default` <class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`formula`> | class<`function`, `rlang_lambda_function`>, ...> => (class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`function`, `rlang_lambda_function`>);
type `as_mapper.list` <list<character | double | double | character | double | class<`function`>>, ..., any, null | character> => class<`function`>;
type `as_mapper.numeric` <character[] | double[], ..., any, null | character> => class<`function`>;
type `as_predicate` <character | class<`formula`> | class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`>, ..., logical, logical> => class<`function`>;
type `assign_in` <list<list<character | list<double | character> | double>>, list<double | character>, character | double> => list<list<character | list<double | character> | double>>;
type `as_vector` <list<character | double | integer[]>, character | null | integer[]> => (character[] | double[]);
type `at_selection` <any, character[] | double[]> => (character[] | double[]);
type `attr_getter` <character> => class<`function`>;
type `can_coerce` <list<character | integer[]>, character | integer[]> => logical;
type `can_simplify` <list<any>, any> => logical;
type `capture_error` <any, any, any> => list<double | null | null | class<`condition`, `error`, `simpleError`>>;
type `check_tibble` < > => null;
type `chuck` <list<character | list<double | character> | list<character | list<double | character> | double>>, ...> => any;
type `compact` <list<any>, class<`function`>> => list<character | null | list<integer | integer | character | character>>;
type `compose` <double | null> => double | <..., character[]> => class<`function`, `purrr_function_compose`>;
type `cross` <list<integer[] | integer[] | character[] | character[]>, class<`function`> | null> => list<list<integer | integer | character | character>>;
type `cross2` <integer[], integer[], class<`function`>> => list<list<integer>>;
type `cross_df` <list<character[]>, null> => class<`data.frame`, `tbl`, `tbl_df`>;
type `cross_dots` <...> => (double | list<list<integer | character | integer>>);
type `detect` <integer[] | list<list<double>>, class<`function`> | character, ..., character[], null, null> => (integer | list<double>);
type `detect_index` <integer[] | list<list<double>>, class<`function`> | class<`function`, `purrr_function_compose`> | character, ..., character[], null> => integer;
type `discard` <list<any>, class<`function`> | character, ...> => list<character | null | list<integer | character | integer[] | character>>;
type `every` <list<integer[] | double>, class<`function`>, ...> => logical;
type `.f` <list<character | list<double | character> | list<character | list<double | character> | double>>, ...> => any | <...> => (double | list<list<integer | character | integer>>) | <double[] | class<`data.frame`, `tbl`, `tbl_df`> | class<`data.frame`> | list<any>, class<`function`> | double[] | class<`formula`> | character | class<`function`, `rlang_lambda_function`> | list<double | character | character | double>, ...> => any | <character | class<`function`>, null | list<character | ^double[]>, ..., environment | null> => (double[] | character) | <double | list<any>> => integer | <...> => (double | character[]) | <character[] | class<`summary.lm`> | integer[] | list<any>, ..., null | character> => (character | double | integer[] | null | list<character | list<double | character> | double | character>);
type `..f` <list<integer[] | integer[] | character[] | character[]>, class<`function`> | null> => list<list<integer | integer | character | character>> | <class<`data.frame`> | list<any>, ...> => double;
type `find_extract_default` <any, character | null> => (character | null);
type `flatten` <class<`array`> | class<`matrix`> | list<integer[] | class<`data.frame`> | list<double[]> | list<any>>> => list<any>;
type `flatten_int` <list<integer[]>> => integer[];
type `fun` <class<`data.frame`> | list<any>, ...> => double;
type `FUN` <class<`array`> | integer[] | class<`matrix`>, double[] | null> => list<integer[] | list<integer[] | list<integer>>>;
type `fun2` <...> => (double | list<list<integer | character | integer>>);
type `has_element` <list<integer[] | double>, double | integer[]> => logical;
type `has_names` <class<`list`, `quosures`>> => logical;
type `head_while` <integer[], class<`function`>, ...> => integer[];
type `imap_chr` <integer[], class<`formula`>, ...> => character[];
type `index` <integer[] | list<list<double>>, character, null, character> => integer[];
type `insistently` <class<`function`>, class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, logical> => class<`function`>;
type `invoke` <character | class<`function`>, null | list<character | ^double[]>, ..., environment | null> => (double[] | character);
type `invoke_map` <character[] | list<class<`function`>>, list<null | list<double>>, ..., null> => list<double[]>;
type `invoke_map_dbl` <list<class<`function`>>, list<null>, ..., null> => double[];
type `inv_which` <class<`data.frame`> | list<integer[] | character[]>, double[] | character[]> => logical[];
type `is_bool` <logical> => logical;
type `is_index` <character | double> => logical;
type `is_mold` <character | integer[]> => logical;
type `is_names` <character[]> => logical;
type `is_number` <double> => logical;
type `is_quantity` <double> => logical;
type `is_rate` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => logical;
type `iwalk` <class<`data.frame`>, class<`formula`>, ...> => class<`data.frame`>;
type `keep` <list<integer[] | list<integer[] | double>>, class<`formula`> | class<`function`> | character | class<`function`, `purrr_function_compose`>, ...> => list<integer[] | list<integer[] | double>>;
type `lift` <class<`data.frame`> | list<any>, ...> => double | <class<`function`>, ..., logical> => class<`function`>;
type `lift_dl` <class<`data.frame`> | list<any>, ...> => double | <class<`function`>, ..., logical> => class<`function`>;
type `lifted_identical` <class<`data.frame`> | list<any>, ...> => double;
type `lift_ld` <...> => (double | list<list<integer | character | integer>>) | <class<`function`>, ...> => class<`function`>;
type `lift_lv` <character[], ...> => character | <class<`function`>, ...> => class<`function`>;
type `lift_vd` <...> => (double | character[]) | <class<`function`>, ..., any> => class<`function`>;
type `list_along` <class<`data.frame`> | integer[] | list<class<`formula`> | class<`formula`, `quosure`>>> => list<null>;
type `list_merge` <list<integer[] | double | list<double>>, ...> => list<double[] | list<double[]>>;
type `list_modify` <list<integer[] | double | list<double>>, ...> => list<integer[] | double | integer[] | double | list<double> | integer[] | double | list<integer[] | double>>;
type `list_recurse` <list<double | integer[] | double | list<double>>, class<`rlang_zap`> | list<any>, any> => list<any>;
type `lmap` <list<integer[] | character[]>, class<`function`>, ...> => list<integer[] | character[]>;
type `lmap_at` <class<`data.frame`> | list<integer[] | character[]>, character[] | integer[], class<`function`>, ...> => (class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | character[]>);
type `lmap_if` <class<`data.frame`> | list<integer[] | character[]>, class<`function`>, class<`function`>, ..., null> => (class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | character[]>);
type `map` <double[] | class<`data.frame`, `tbl`, `tbl_df`> | class<`data.frame`> | list<any>, class<`function`> | double[] | class<`formula`> | character | class<`function`, `rlang_lambda_function`> | list<double | character | character | double>, ...> => any;
type `map2` <double[] | character[] | class<`data.frame`> | list<any>, double[] | character[] | list<any>, class<`function`> | class<`formula`> | class<`function`, `rlang_lambda_function`>, ...> => list<any>;
type `map2_chr` <integer[], integer[], class<`function`, `rlang_lambda_function`>, ...> => character[];
type `map2_dbl` <double[] | list<class<`function`>>, double[] | list<null>, class<`function`>, ...> => double[];
type `map2_dfc` <double[], double[], class<`function`>, ...> => class<`data.frame`>;
type `map2_dfr` <double[], double[], class<`function`>, ..., null> => class<`data.frame`>;
type `map_at` <class<`data.frame`>, character | double[], class<`function`>, ...> => list<double[] | character[] | double[]>;
type `map_chr` <character[] | list<list<character>>, class<`formula`> | class<`function`>, ...> => character[];
type `map_dbl` <class<`data.frame`> | list<any>, class<`function`> | class<`formula`> | character, ...> => ^double[];
type `map_depth` <list<list<integer[]>>, double, class<`function`>, ..., logical> => list<list<character>>;
type `map_depth_rec` <list<integer[] | list<integer[]>>, double, class<`function`>, ..., any, logical> => list<character | list<character>>;
type `map_dfr` <list<class<`lm`>>, class<`formula`>, ..., null> => class<`data.frame`>;
type `map_if` <class<`data.frame`> | list<class<`formula`> | class<`formula`, `quosure`>>, class<`function`> | logical, class<`function`>, ..., null | class<`function`>> => list<any>;
type `map_int` <integer[] | list<any>, character | double | class<`function`> | list<character | double>, ...> => ^integer[];
type `map_lgl` <class<`data.frame`> | list<any>, class<`function`> | character, ...> => logical[];
type `maybe_as_data_frame` <list<double[] | integer[] | character[]>, class<`data.frame`> | list<integer[] | character[]>> => (class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | character[]>);
type `maybe_zap` <double[] | class<`rlang_zap`>> => (double[] | null);
type `modify` <integer[] | list<integer[] | list<integer[] | list<integer[]>>>, class<`function`> | character[] | class<`function`, `rlang_lambda_function`>, ...> => (integer[] | list<integer[] | list<integer[] | character | list<character | integer[]>>>);
type `modify2` <integer[], logical[], class<`formula`>, ...> => integer[];
type `modify2.integer` <integer[], logical[], class<`formula`>, ...> => integer[];
type `modify_at` <class<`data.frame`>, character[] | double[], class<`function`>, ...> => class<`data.frame`>;
type `modify_at.default` <class<`data.frame`>, character[] | double[], class<`function`>, ...> => class<`data.frame`>;
type `modify_base` <class<`function`>, integer[], logical[], class<`formula`>, ...> => integer[];
type `modify.default` <list<integer[] | list<integer[] | list<integer[]>>>, character[] | class<`function`> | class<`function`, `rlang_lambda_function`>, ...> => list<integer[] | list<integer[] | character | list<character | integer[]>>>;
type `modify_depth` <list<list<list<integer[]>>>, double, character | class<`formula`> | class<`function`>, ..., any> => list<list<integer[] | list<character | integer[]>>>;
type `modify_depth.default` <list<list<list<integer[]>>>, double, character | class<`formula`> | class<`function`>, ..., logical> => list<list<integer[] | list<character | integer[]>>>;
type `modify_depth_rec` <integer[] | list<integer[] | list<integer[] | list<integer[]>>>, double, class<`function`> | class<`function`, `rlang_lambda_function`>, ..., any, logical> => (integer[] | list<integer[] | list<integer[] | character | list<character | integer[]>>>);
type `modify_if` <class<`data.frame`> | list<character[] | list<character> | list<integer>>, class<`function`> | logical[] | character, class<`function`> | class<`formula`>, ..., class<`function`> | null> => (class<`data.frame`> | list<list<double | character[]>>);
type `modify_if.default` <class<`data.frame`> | list<character[] | list<character> | list<integer>>, class<`function`> | logical[] | character, class<`function`> | class<`formula`>, ..., class<`function`> | null> => (class<`data.frame`> | list<list<double | character[]>>);
type `modify_in` <list<list<double>>, list<double | character>, class<`formula`> | class<`function`>, ...> => list<list<double>>;
type `modify.integer` <integer[], class<`function`>, ...> => integer[];
type `negate` <character | class<`formula`> | class<`function`> | class<`function`, `purrr_function_compose`>> => class<`function`, `purrr_function_compose`>;
type `new_rate` <character, ..., logical, double> => (class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>);
type `not_null` <double | null> => double;
type `partial` <class<`function`> | class<`function`, `purrr_function_partial`>, ..., null, null, null> => class<`function`, `purrr_function_partial`>;
type `paste_line` <...> => character;
type `pluck` <character[] | class<`summary.lm`> | integer[] | list<any>, ..., null | character> => (character | double | integer[] | null | list<character | list<double | character> | double | character>);
type `pluck<-` <list<list<character | list<double | character>>>, ..., character> => list<list<character | list<double | character>>>;
type `plucker` <list<any>, null | character> => class<`function`>;
type `pmap` <class<`data.frame`> | list<integer[] | list<double>>, class<`function`>, ...> => list<character | double>;
type `pmap_chr` <class<`data.frame`>, class<`function`>, ...> => character[];
type `pmap_dbl` <class<`data.frame`>, class<`function`>, ...> => double[];
type `possibly` <class<`function`>, double | null, logical> => class<`function`>;
type `prepend` <list<any>, character | list<character | integer>, null | double> => list<character | integer | integer | character | integer>;
type `probe` <class<`data.frame`> | list<any>, logical[] | class<`formula`> | class<`function`> | character | class<`function`, `purrr_function_compose`>, ...> => logical[];
type `quo_invert` <class<`formula`, `quosure`>> => class<`formula`, `quosure`>;
type `quo_is_constant` <class<`formula`, `quosure`>> => logical;
type `rate_backoff` <double, double, double, double, logical> => class<`purrr_rate`, `purrr_rate_backoff`>;
type `rate_bump_count` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, integer> => (class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>);
type `rate_count` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => integer;
type `rate_delay` <double, double> => class<`purrr_rate`, `purrr_rate_delay`>;
type `rate_reset` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => (class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>);
type `rate_sleep` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, any> => any;
type `rate_sleep_impl` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, double, logical> => null;
type `rate_sleep.purrr_rate_backoff` <class<`purrr_rate`, `purrr_rate_backoff`>, logical> => null;
type `rate_sleep.purrr_rate_delay` <class<`purrr_rate`, `purrr_rate_delay`>, logical> => null;
type `rbernoulli` <double, double> => logical[];
type `rdunif` <double, double, double> => double[];
type `recycle_args` <list<integer[]>> => list<integer[]>;
type `reduce` <character[] | integer[] | list<character[] | double | character>, class<`function`>, ..., any, character[]> => (character[] | class<`call`> | integer | list<integer | list<integer | list<integer>>>);
type `reduce2` <character[] | list<double[]>, character[] | list<double[]>, class<`function`>, ..., any> => character[];
type `reduce2_impl` <character[] | list<double[]>, character[] | list<double[]>, class<`function`>, ..., any, logical, logical> => (character[] | list<character>);
type `reduce_early` <class<`rlang_box`, `rlang_box_done`>, any, logical, any, any, any> => (character | list<character>);
type `reduce_impl` <character[] | integer[] | list<character[] | double | character>, class<`function`>, ..., any, character[], logical> => (character[] | class<`call`> | integer | list<character | integer | integer | list<integer | list<integer>>>);
type `reduce_index` <character[] | integer[] | list<double | character | double[] | character[]>, any, logical> => integer[];
type `reduce_init` <any, any, any> => (character[] | class<`name`> | double[]);
type `reduce_subset_call` <class<`name`>, list<double | character>> => class<`call`>;
type `rerun` <double, ...> => list<double[] | list<double[]>>;
type `safely` <class<`function`>, null, logical> => class<`function`>;
type `seq_len2` <double, integer> => integer[];
type `signal_rate_init` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => null;
type `signal_rate_retry` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, double, logical> => null;
type `signal_soft_deprecated` <character, character, environment> => null;
type `silver` <character> => character;
type `simplify_all` <list<list<double | character | null | double | class<`condition`, `error`, `simpleError`> | null>>, null> => list<double[] | character[] | ^double[] | list<class<`condition`, `error`, `simpleError`> | null>>;
type `slowly` <class<`formula`>, class<`purrr_rate`, `purrr_rate_delay`>, logical> => class<`function`>;
type `some` <list<integer[] | double>, class<`function`>, ...> => logical;
type `splice` <...> => list<character[]>;
type `splice_if` <list<character[] | list<character>>, class<`function`>> => list<character[]>;
type `stop_rate_excess` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => any;
type `tail_while` <integer[], class<`function`> | class<`function`, `purrr_function_compose`>, ...> => integer[];
type `transpose` <class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | list<any>>, null | character[]> => list<list<any>>;
type `update_list` <list<integer>, ...> => list<double>;
type `vec_depth` <double | list<any>> => integer;
type `vec_index` <class<`data.frame`> | integer[]> => (character[] | integer[]);
type `walk2` <class<`data.frame`>, character[], class<`function`, `rlang_lambda_function`>, ...> => class<`data.frame`>;
type `warn_deprecated` <any, character> => (character | null);
type `when` <class<`data.frame`> | integer[], ...> => (class<`data.frame`> | double);
