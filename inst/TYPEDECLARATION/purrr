type `%@%` <class<`factor`> | class<`data.frame`>, character> => character[];
type `accum_index` <list<character | null> | list<integer | null> | list<null | character> | list<null | integer>, logical> => integer[];
type `accum_init` <character | integer, integer[], logical> => (list<character | null> | list<integer | null> | list<null | character> | list<null | integer>);
type `accumulate` <character[] | integer[], class<`function`>, ..., any, character[]> => (character[] | integer[]);
type `accumulate2` <character[], character[], class<`function`>, ..., any> => list<character>;
type `accumulate_names` <null, any, any> => null;
type `array_branch` <class<`array`> | integer[] | class<`matrix`>, null | double[]> => (list<class<`matrix`>> | list<integer[]>);
type `array_tree` <class<`array`> | integer[] | class<`matrix`>, double[] | null> => (list<list<integer[]>> | list<list<list<integer>>> | list<integer[]>);
type `as_invoke_function` <character[] | list<class<`function`>>> => (character[] | list<class<`function`>>);
type `as_mapper` <character[] | class<`function`> | double[] | list<character | double> | list<double | character> | list<double | class<`function`>> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`formula`> | class<`function`, `rlang_lambda_function`>, ...> => (class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`function`, `rlang_lambda_function`>);
type `as_mapper.character` <character[] | double[], ..., any, null | character> => class<`function`>;
type `as_mapper.default` <class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`formula`> | class<`function`, `rlang_lambda_function`>, ...> => (class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`> | class<`function`, `rlang_lambda_function`>);
type `as_mapper.list` <list<character | double> | list<double | character> | list<double | class<`function`>>, ..., any, null | character> => class<`function`>;
type `as_mapper.numeric` <character[] | double[], ..., any, null | character> => class<`function`>;
type `as_predicate` <character | class<`formula`> | class<`function`> | class<`function`, `purrr_function_compose`> | class<`function`, `purrr_function_partial`>, ..., logical, logical> => class<`function`>;
type `assign_in` <list<list<character | list<double | character>>> | list<list<double>>, list<double | character>, character | double> => (list<list<character | list<double | character>>> | list<list<double>>);
type `as_vector` <list<character> | list<double> | list<integer[]>, character | null | integer[]> => (character[] | double[]);
type `at_selection` <any, character[] | double[]> => (character[] | double[]);
type `attr_getter` <character> => class<`function`>;
type `can_coerce` <list<character> | list<integer[]>, character | integer[]> => logical;
type `can_simplify` <list<character> | list<class<`condition`, `error`, `simpleError`> | null> | list<double> | list<integer[]> | list<null | double>, any> => logical;
type `capture_error` <any, any, any> => (list<double | null> | list<null | class<`condition`, `error`, `simpleError`>>);
type `check_tibble` < > => null;
type `chuck` <list<list<character | list<double | character>>> | list<list<double>> | list<character | list<double | character>>, ...> => any;
type `compact` <list<any>, class<`function`>> => (list<list<integer>> | list<list<integer | character>> | list<list<character>> | list<character | null>);
type `compose` <double | null> => double | <..., character[]> => class<`function`, `purrr_function_compose`>;
type `cross` <list<integer[]> | list<integer[] | character[]> | list<character[]>, class<`function`> | null> => (list<list<integer>> | list<list<integer | character>> | list<list<character>>);
type `cross2` <integer[], integer[], class<`function`>> => list<list<integer>>;
type `cross_df` <list<character[]>, null> => class<`data.frame`, `tbl`, `tbl_df`>;
type `detect` <integer[] | list<list<double>>, class<`function`> | character, ..., character[], null, null> => (integer | list<double>);
type `detect_index` <integer[] | list<list<double>>, class<`function`> | class<`function`, `purrr_function_compose`> | character, ..., character[], null> => integer;
type `discard` <list<any>, class<`function`> | character, ...> => (list<list<integer | character>> | list<list<integer[]>> | list<list<character>> | list<character | null>);
type `every` <list<integer[] | double>, class<`function`>, ...> => logical;
type `find_extract_default` <any, character | null> => (character | null);
type `flatten` <list<list<class<`matrix`>>> | class<`array`> | list<integer[]> | class<`matrix`> | list<list<integer[]>> | list<list<integer[] | character[]>> | list<list<character[]>> | list<class<`data.frame`> | list<double[]>>> => (list<class<`matrix`>> | list<integer[] | character[]> | list<character[]> | list<double[]>);
type `flatten_int` <list<integer[]>> => integer[];
type `has_element` <list<integer[] | double>, double | integer[]> => logical;
type `has_names` <class<`list`, `quosures`>> => logical;
type `head_while` <integer[], class<`function`>, ...> => integer[];
type `imap_chr` <integer[], class<`formula`>, ...> => character[];
type `index` <integer[] | list<list<double>>, character, null, character> => integer[];
type `insistently` <class<`function`>, class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, logical> => class<`function`>;
type `invoke` <character | class<`function`>, null | list<character> | list<^double[]>, ..., environment | null> => (double[] | character);
type `invoke_map` <list<class<`function`>> | character[], list<list<double>> | list<null>, ..., null> => list<double[]>;
type `invoke_map_dbl` <list<class<`function`>>, list<null>, ..., null> => double[];
type `inv_which` <class<`data.frame`> | list<integer[] | character[]>, double[] | character[]> => logical[];
type `is_bool` <logical> => logical;
type `is_index` <character | double> => logical;
type `is_mold` <character | integer[]> => logical;
type `is_names` <character[]> => logical;
type `is_number` <double> => logical;
type `is_quantity` <double> => logical;
type `is_rate` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => logical;
type `iwalk` <class<`data.frame`>, class<`formula`>, ...> => class<`data.frame`>;
type `keep` <list<integer[]> | list<list<integer[]>> | list<list<double>>, class<`formula`> | class<`function`> | character | class<`function`, `purrr_function_compose`>, ...> => (list<integer[]> | list<list<integer[]>> | list<list<double>>);
type `lift` <class<`data.frame`> | list<any>, ...> => double | <class<`function`>, ..., logical> => class<`function`>;
type `lift_dl` <class<`data.frame`> | list<any>, ...> => double | <class<`function`>, ..., logical> => class<`function`>;
type `lift_ld` <...> => (list<list<integer | character>> | double | list<list<integer>>) | <class<`function`>, ...> => class<`function`>;
type `lift_lv` <character[], ...> => character | <class<`function`>, ...> => class<`function`>;
type `lift_vd` <...> => (double | character[]) | <class<`function`>, ..., any> => class<`function`>;
type `list_along` <list<class<`formula`>> | list<class<`formula`, `quosure`>> | class<`data.frame`> | integer[]> => list<null>;
type `list_merge` <list<integer[] | double | list<double>>, ...> => list<double[] | list<double[]>>;
type `list_modify` <list<integer[] | double | list<double>>, ...> => (list<integer[] | double> | list<integer[] | double | list<double>> | list<integer[] | double | list<integer[] | double>>);
type `list_recurse` <list<double> | list<integer[] | double | list<double>>, list<integer[] | double> | class<`rlang_zap`> | list<integer[]> | list<double | list<integer[] | double>> | list<double> | list<class<`rlang_zap`>> | list<list<integer[]>> | list<double | class<`rlang_zap`>>, any> => (list<double[]> | list<integer[] | double> | list<double[] | list<double[]>> | list<integer[] | double | list<double>> | list<integer[] | double | list<integer[] | double>>);
type `lmap` <list<integer[] | character[]>, class<`function`>, ...> => list<integer[] | character[]>;
type `lmap_at` <class<`data.frame`> | list<integer[] | character[]>, character[] | integer[], class<`function`>, ...> => (class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | character[]>);
type `lmap_if` <class<`data.frame`> | list<integer[] | character[]>, class<`function`>, class<`function`>, ..., null> => (class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | character[]>);
type `map` <list<integer[]> | list<list<any>> | list<class<`function`>> | list<class<`function`> | class<`function`, `purrr_function_compose`>> | list<class<`function`> | class<`formula`>> | list<class<`function`> | class<`function`, `rlang_lambda_function`>> | list<class<`formula`>> | double[] | list<character | double> | list<class<`lm`>> | list<class<`data.frame`>> | class<`data.frame`, `tbl`, `tbl_df`> | class<`data.frame`> | list<class<`formula`, `quosure`>>, class<`function`> | double[] | list<double | character> | class<`formula`> | character | list<character | double> | class<`function`, `rlang_lambda_function`>, ...> => any;
type `map2` <double[] | list<double> | list<class<`function`>> | character[] | list<class<`lm`>> | list<list<character[]>> | class<`data.frame`>, double[] | list<double> | list<list<double>> | list<null> | list<class<`data.frame`>> | character[], class<`function`> | class<`formula`> | class<`function`, `rlang_lambda_function`>, ...> => (list<class<`data.frame`>> | list<double[]> | list<list<character[]>> | list<null>);
type `map2_chr` <integer[], integer[], class<`function`, `rlang_lambda_function`>, ...> => character[];
type `map2_dbl` <double[] | list<class<`function`>>, double[] | list<null>, class<`function`>, ...> => double[];
type `map2_dfc` <double[], double[], class<`function`>, ...> => class<`data.frame`>;
type `map2_dfr` <double[], double[], class<`function`>, ..., null> => class<`data.frame`>;
type `map_at` <class<`data.frame`>, character | double[], class<`function`>, ...> => (list<double[] | character[]> | list<double[]>);
type `map_chr` <list<list<character>> | character[], class<`formula`> | class<`function`>, ...> => character[];
type `map_dbl` <list<character | double> | list<double[]> | list<list<double[]>> | list<class<`summary.lm`>> | class<`data.frame`>, class<`function`> | class<`formula`> | character, ...> => ^double[];
type `map_depth` <list<list<integer[]>>, double, class<`function`>, ..., logical> => list<list<character>>;
type `map_depth_rec` <list<list<integer[]>> | list<integer[]>, double, class<`function`>, ..., any, logical> => (list<list<character>> | list<character>);
type `map_dfr` <list<class<`lm`>>, class<`formula`>, ..., null> => class<`data.frame`>;
type `map_if` <class<`data.frame`> | list<class<`formula`>> | list<class<`formula`, `quosure`>>, class<`function`> | logical, class<`function`>, ..., null | class<`function`>> => (list<double[] | character[]> | list<integer[] | character[]> | list<class<`formula`, `quosure`>> | list<double>);
type `map_int` <integer[] | list<any>, character | double | list<character | double> | class<`function`>, ...> => ^integer[];
type `map_lgl` <list<any> | class<`data.frame`>, class<`function`> | character, ...> => logical[];
type `maybe_as_data_frame` <list<double[]> | list<integer[] | character[]>, class<`data.frame`> | list<integer[] | character[]>> => (class<`data.frame`, `tbl`, `tbl_df`> | list<integer[] | character[]>);
type `maybe_zap` <double[] | class<`rlang_zap`>> => (double[] | null);
type `modify` <integer[] | list<list<list<integer[]>>> | list<integer[]> | list<list<integer[]>>, class<`function`> | character[] | class<`function`, `rlang_lambda_function`>, ...> => (integer[] | list<integer[]> | list<list<integer[]>> | list<list<list<character>>> | list<list<list<integer[]>>> | list<list<character>>);
type `modify2` <integer[], logical[], class<`formula`>, ...> => integer[];
type `modify2.integer` <integer[], logical[], class<`formula`>, ...> => integer[];
type `modify_at` <class<`data.frame`>, character[] | double[], class<`function`>, ...> => class<`data.frame`>;
type `modify_at.default` <class<`data.frame`>, character[] | double[], class<`function`>, ...> => class<`data.frame`>;
type `modify_base` <class<`function`>, integer[], logical[], class<`formula`>, ...> => integer[];
type `modify.default` <list<list<list<integer[]>>> | list<integer[]> | list<list<integer[]>>, character[] | class<`function`> | class<`function`, `rlang_lambda_function`>, ...> => (list<integer[]> | list<list<integer[]>> | list<list<list<character>>> | list<list<list<integer[]>>> | list<list<character>>);
type `modify_depth` <list<list<list<integer[]>>>, double, character | class<`formula`> | class<`function`>, ..., any> => (list<list<integer[]>> | list<list<list<character>>> | list<list<list<integer[]>>>);
type `modify_depth.default` <list<list<list<integer[]>>>, double, character | class<`formula`> | class<`function`>, ..., logical> => (list<list<integer[]>> | list<list<list<character>>> | list<list<list<integer[]>>>);
type `modify_depth_rec` <integer[] | list<list<list<integer[]>>> | list<integer[]> | list<list<integer[]>>, double, class<`function`> | class<`function`, `rlang_lambda_function`>, ..., any, logical> => (integer[] | list<list<integer[]>> | list<list<list<character>>> | list<list<list<integer[]>>> | list<integer[]> | list<list<character>>);
type `modify_if` <class<`data.frame`> | list<list<integer>> | list<character[] | list<character>>, class<`function`> | logical[] | character, class<`function`> | class<`formula`>, ..., class<`function`> | null> => (class<`data.frame`> | list<list<double>> | list<list<character[]>>);
type `modify_if.default` <class<`data.frame`> | list<list<integer>> | list<character[] | list<character>>, class<`function`> | logical[] | character, class<`function`> | class<`formula`>, ..., class<`function`> | null> => (class<`data.frame`> | list<list<double>> | list<list<character[]>>);
type `modify_in` <list<list<double>>, list<double | character>, class<`formula`> | class<`function`>, ...> => list<list<double>>;
type `modify.integer` <integer[], class<`function`>, ...> => integer[];
type `negate` <character | class<`formula`> | class<`function`> | class<`function`, `purrr_function_compose`>> => class<`function`, `purrr_function_compose`>;
type `new_rate` <character, ..., logical, double> => (class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>);
type `partial` <class<`function`> | class<`function`, `purrr_function_partial`>, ..., null, null, null> => class<`function`, `purrr_function_partial`>;
type `paste_line` <...> => character;
type `pluck` <character[] | class<`summary.lm`> | integer[] | list<any>, ..., null | character> => (character | double | integer[] | list<character | list<double | character>> | null | list<double | character>);
type `pluck<-` <list<list<character | list<double | character>>>, ..., character> => list<list<character | list<double | character>>>;
type `plucker` <list<character> | list<character | double> | list<double | character> | list<double | class<`function`>> | list<double>, null | character> => class<`function`>;
type `pmap` <class<`data.frame`> | list<integer[]> | list<list<double>>, class<`function`>, ...> => (list<character> | list<double>);
type `pmap_chr` <class<`data.frame`>, class<`function`>, ...> => character[];
type `pmap_dbl` <class<`data.frame`>, class<`function`>, ...> => double[];
type `possibly` <class<`function`>, double | null, logical> => class<`function`>;
type `prepend` <list<any>, character | list<character> | list<integer>, null | double> => (list<character | integer> | list<integer | character> | list<integer>);
type `probe` <class<`data.frame`> | list<any>, logical[] | class<`formula`> | class<`function`> | character | class<`function`, `purrr_function_compose`>, ...> => logical[];
type `quo_invert` <class<`formula`, `quosure`>> => class<`formula`, `quosure`>;
type `quo_is_constant` <class<`formula`, `quosure`>> => logical;
type `rate_backoff` <double, double, double, double, logical> => class<`purrr_rate`, `purrr_rate_backoff`>;
type `rate_bump_count` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, integer> => (class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>);
type `rate_count` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => integer;
type `rate_delay` <double, double> => class<`purrr_rate`, `purrr_rate_delay`>;
type `rate_reset` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => (class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>);
type `rate_sleep` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, any> => any;
type `rate_sleep_impl` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, double, logical> => null;
type `rate_sleep.purrr_rate_backoff` <class<`purrr_rate`, `purrr_rate_backoff`>, logical> => null;
type `rate_sleep.purrr_rate_delay` <class<`purrr_rate`, `purrr_rate_delay`>, logical> => null;
type `rbernoulli` <double, double> => logical[];
type `rdunif` <double, double, double> => double[];
type `recycle_args` <list<integer[]>> => list<integer[]>;
type `reduce` <list<character[]> | character[] | list<double | character> | integer[], class<`function`>, ..., any, character[]> => (character[] | class<`call`> | integer | list<integer | list<integer | list<integer>>>);
type `reduce2` <list<double[]> | character[], list<double[]> | character[], class<`function`>, ..., any> => character[];
type `reduce2_impl` <list<double[]> | character[], list<double[]> | character[], class<`function`>, ..., any, logical, logical> => (character[] | list<character>);
type `reduce_early` <class<`rlang_box`, `rlang_box_done`>, any, logical, any, any, any> => (character | list<character>);
type `reduce_impl` <list<character[]> | character[] | list<double | character> | integer[], class<`function`>, ..., any, character[], logical> => (character[] | class<`call`> | integer | list<character> | list<integer> | list<integer | list<integer | list<integer>>>);
type `reduce_index` <character[] | integer[] | list<double | character> | list<double[]> | list<character[]>, any, logical> => integer[];
type `reduce_init` <any, any, any> => (character[] | class<`name`> | double[]);
type `reduce_subset_call` <class<`name`>, list<double | character>> => class<`call`>;
type `rerun` <double, ...> => (list<double[]> | list<list<double[]>>);
type `safely` <class<`function`>, null, logical> => class<`function`>;
type `seq_len2` <double, integer> => integer[];
type `signal_rate_init` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => null;
type `signal_rate_retry` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>, double, logical> => null;
type `signal_soft_deprecated` <character, character, environment> => null;
type `silver` <character> => character;
type `simplify_all` <list<list<double>> | list<list<character>> | list<list<null | double | class<`condition`, `error`, `simpleError`> | null>>, null> => (list<double[]> | list<character[]> | list<^double[] | list<class<`condition`, `error`, `simpleError`> | null>>);
type `slowly` <class<`formula`>, class<`purrr_rate`, `purrr_rate_delay`>, logical> => class<`function`>;
type `some` <list<integer[] | double>, class<`function`>, ...> => logical;
type `splice` <...> => list<character[]>;
type `splice_if` <list<character[] | list<character>>, class<`function`>> => list<character[]>;
type `stop_rate_excess` <class<`purrr_rate`, `purrr_rate_backoff`> | class<`purrr_rate`, `purrr_rate_delay`>> => any;
type `tail_while` <integer[], class<`function`> | class<`function`, `purrr_function_compose`>, ...> => integer[];
type `transpose` <class<`data.frame`, `tbl`, `tbl_df`> | list<list<double[]>> | list<integer[]> | list<list<character>> | list<list<null | class<`condition`, `error`, `simpleError`> | double | null>> | list<list<double | character | character | double>>, null | character[]> => (list<list<character>> | list<list<double[]>> | list<list<null | double | class<`condition`, `error`, `simpleError`> | null>> | list<list<double | character | null>> | list<list<double | character | null | null | character>>);
type `update_list` <list<integer>, ...> => list<double>;
type `vec_depth` <double | list<any>> => integer;
type `vec_index` <class<`data.frame`> | integer[]> => (character[] | integer[]);
type `walk2` <class<`data.frame`>, character[], class<`function`, `rlang_lambda_function`>, ...> => class<`data.frame`>;
type `warn_deprecated` <any, character> => (character | null);
type `when` <class<`data.frame`> | integer[], ...> => (class<`data.frame`> | double);
