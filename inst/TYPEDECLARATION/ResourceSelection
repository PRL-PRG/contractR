type `.mep` <double[], double[], double, character, character, symbol | double, double, symbol | double, double, double, symbol, double[], double, double[], double[], logical, character> => struct<`x`:character[], `y`:^double[], `link`:character> | struct<`x`:double[], `y`:^double[], `link`:character>;
type `.solvenear` <^double[]> => ^double[];
type `.wrsi` <integer[], ^double[]> => ^double[];
type `CAIC.default` <struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `runif(10)`:double[]>>, struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `runif(10)`:double[]>> | null, double | null> => struct<`df`:double[], `CAIC`:double[]> | double;
type `CAICtable` <struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `runif(10)`:double[]>>, struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `runif(10)`:double[]>>, double> => struct<`df`:double[], `CAIC`:double[], `dCAIC`:double[], `wCAIC`:double[]>;
type `diag.panel` <double[], null> => null;
type `family.rsf` <struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:struct<`TASPc`:character[], `SLOPEc`:character[]>, `contrasts`:struct<`TASPc`:character, `SLOPEc`:character>, `model`:struct<`STATUS`:integer[], `TASPc`:integer[], `SLOPEc`:integer[], `ELEVATION`:double[], `I(ELEVATION^2)`:double[]>, `x`:null, `fitted.values`:double[]>, null> => struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `simulate`:any => any>;
type `filter` <character[]> => logical[];
type `fitted.rsf` <struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:struct<`TASPc`:character[], `SLOPEc`:character[]>, `contrasts`:struct<`TASPc`:character, `SLOPEc`:character>, `model`:struct<`STATUS`:integer[], `TASPc`:integer[], `SLOPEc`:integer[], `ELEVATION`:double[], `I(ELEVATION^2)`:double[]>, `x`:null, `fitted.values`:double[]> | struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:tuple<>, `contrasts`:null, `model`:struct<`status`:double[], `x1`:double[], `x2`:double[]>, `x`:null, `fitted.values`:double[]> | struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:^logical[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:double, `nobs`:integer, `converged`:logical, `formula`:language, `terms`:language, `levels`:tuple<>, `contrasts`:null, `model`:struct<`status`:double[], `x1`:double[], `x2`:double[]>, `x`:null, `fitted.values`:double[]>, character[], null> => double[];
type `fn` <double[], integer[]> => double;
type `fun` <symbol, character | symbol> => null;
type `FUN` <struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `runif(10)`:double[]>> | character | double | integer[]> => double[];
type `hoslem.test` <double[], double[], double> => struct<`statistic`:double, `parameter`:double, `p.value`:double, `method`:character, `data.name`:character, `observed`:^double[], `expected`:^double[]>;
type `jfun` <double[], double, symbol, double> => double[];
type `jitter_amount` <double[], double, null> => double;
type `kdepairs.default` <struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[]>, double, logical, logical, null> => null;
type `logLik.rsf` <struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:tuple<>, `contrasts`:null, `model`:struct<`status`:double[], `x1`:double[], `x2`:double[]>, `x`:null, `fitted.values`:double[]> | struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:^logical[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:double, `nobs`:integer, `converged`:logical, `formula`:language, `terms`:language, `levels`:tuple<>, `contrasts`:null, `model`:struct<`status`:double[], `x1`:double[], `x2`:double[]>, `x`:null, `fitted.values`:double[]>, null> => double;
type `lower.panel` <double[], double[], null> => null;
type `makeUsedAvail.default` <struct<`var1`:integer[], `var2`:integer[]>, double[], symbol> => struct<`species`:double[], `var1`:integer[], `var2`:integer[]>;
type `makeUsedAvail.formula` <language, symbol, null> => struct<`species`:double[], `var1`:integer[], `var2`:integer[]>;
type `mep.default` <struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:struct<`TASPc`:character[], `SLOPEc`:character[]>, `contrasts`:struct<`TASPc`:character, `SLOPEc`:character>, `model`:struct<`STATUS`:integer[], `TASPc`:integer[], `SLOPEc`:integer[], `ELEVATION`:double[], `I(ELEVATION^2)`:double[]>, `x`:null, `fitted.values`:double[]>, integer[], null, double, double, double, double, double, null, double[], double, double[], double[], null, null, null, null> => struct<`STATUS`:struct<`x`:double[], `y`:^double[], `link`:character>, `TASPc`:struct<`x`:character[], `y`:^double[], `link`:character>, `SLOPEc`:struct<`x`:character[], `y`:^double[], `link`:character>, `ELEVATION`:struct<`x`:double[], `y`:^double[], `link`:character>>;
type `model.frame.rsf` <struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:struct<`TASPc`:character[], `SLOPEc`:character[]>, `contrasts`:struct<`TASPc`:character, `SLOPEc`:character>, `model`:struct<`STATUS`:integer[], `TASPc`:integer[], `SLOPEc`:integer[], `ELEVATION`:double[], `I(ELEVATION^2)`:double[]>, `x`:null, `fitted.values`:double[]>, null> => struct<`STATUS`:integer[], `TASPc`:integer[], `SLOPEc`:integer[], `ELEVATION`:double[], `I(ELEVATION^2)`:double[]>;
type `rsf` <language, struct<`status`:double[], `x1`:double[], `x2`:double[]>, double, double, null, character, null, logical, logical, null> => struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:^logical[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:double, `nobs`:integer, `converged`:logical, `formula`:language, `terms`:language, `levels`:tuple<>, `contrasts`:null, `model`:struct<`status`:double[], `x1`:double[], `x2`:double[]>, `x`:null, `fitted.values`:double[]>;
type `rsf.fit` <^double[], integer[], double, character, double, symbol, character, symbol, null> => struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical> | struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:^logical[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical>;
type `rspf` <language, struct<`STATUS`:integer[], `ID`:integer[], `ELEVATION`:double[], `SLOPE`:double[], `ET`:double[], `ASPECT`:double[], `HLI`:double[], `TASP`:double[], `TASPc`:integer[], `SLOPEc`:integer[]>, double, double, double | character, null, character, null, logical, logical, null> => struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:struct<`TASPc`:character[], `SLOPEc`:character[]>, `contrasts`:struct<`TASPc`:character, `SLOPEc`:character>, `model`:struct<`STATUS`:integer[], `TASPc`:integer[], `SLOPEc`:integer[], `ELEVATION`:double[], `I(ELEVATION^2)`:double[]>, `x`:null, `fitted.values`:double[]> | struct<`call`:language, `y`:integer[], `coefficients`:double[], `std.error`:double[], `loglik`:double, `results`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `link`:character, `control`:struct<`maxit`:double>, `inits`:double[], `m`:double, `np`:integer, `nobs`:integer, `bootstrap`:null, `converged`:logical, `formula`:language, `terms`:language, `levels`:tuple<>, `contrasts`:null, `model`:struct<`status`:double[], `x1`:double[], `x2`:double[]>, `x`:null, `fitted.values`:double[]>;
type `simulateUsedAvail` <struct<`x1`:double[], `x2`:double[]>, double[], double, double, character> => struct<`status`:double[], `x1`:double[], `x2`:double[]>;
type `sindex` <^double[], ^double[]> => struct<`Spp1`:double[], `Spp2`:double[], `Spp3`:double[]>;
type `upper.panel` <double[], double[], null> => null;
type `wrsi` <double[], ^double[]> => struct<`WRSI`:double[], `zWRSI`:double[], `rWRSI`:double[], `Pused`:double[], `Pavail`:double[], `Pw`:double[], `u`:double[], `a`:double[]>;
