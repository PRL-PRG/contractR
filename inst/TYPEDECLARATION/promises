type `filter` <character[]> => logical[];
type `is.promise` <struct<`status`:double, `body`:character, `headers`:character> | struct<`status`:double, `body`:character, `headers`:struct<`Content-Type`:character>>> => logical;
type `_fseq` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `[[` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `%...!%` <environment, language> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `%...>%` <environment | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, language> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `%...T!%` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, language> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `%...T>%` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, language> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `$` <? any => any | struct<`message`:character, `call`:null> | struct<> | double | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, ? any => any | logical, null> => struct<`onFulfilled`:any => any> | struct<`onFulfilled`:any => any, `onRejected`:any => any> | struct<`onRejected`:any => any> | any => any | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `action` <any => any | language, language | any => any> => ? tuple<struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> | any => any | tuple<any => any> | tuple<any => any, any => any>;
type `as.promise.Future` <environment> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `as.promise.promise` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `catch` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, any => any, logical> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `check` < > => ? any => any;
type `current_promise_domain` < > => null;
type `do_next` <double> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `FUN` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any> | integer> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `has.visible` <any => any> => logical;
type `is_colexpr` <language> => logical;
type `is_first` <language> => logical;
type `is_function` <any => any | language> => logical;
type `is_funexpr` <any => any | language> => logical;
type `is_lambda` <any => any | language> => logical;
type `is_parenthesized` <language> => logical;
type `is.promising` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]> | double | struct<`message`:character, `call`:null> | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => logical;
type `normalizeOnFulfilled` <any => any> => any => any;
type `normalizeOnRejected` <any => any> => any => any;
type `pipeify_rhs` <language, environment> => any => any;
type `prepare_first` <language> => language;
type `promise` <any => any | language> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `promise_all` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, null> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `promise_map` <struct<`A`:double, `B`:double, `C`:double>, any => any, ???> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `promise_race` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, null> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `promise_reduce` <integer[], symbol, ???, double> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `promise_reject` <character> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `promise_resolve` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]> | double | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `reject` <character> => null;
type `resolve` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]> | double | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => null;
type `then` <environment | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, any => any | language, ? any => any | language> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `tryCatch` <? any => any | tuple<any => any> | tuple<any => any, any => any> | tuple<struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, any => any, ???> => ? any => any | tuple<any => any> | tuple<any => any, any => any> | tuple<struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> | struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `with_promise_domain` <null, struct<`then`:any => any, `catch`:any => any, `finally`:any => any>, logical> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
type `without_promise_domain` <struct<`then`:any => any, `catch`:any => any, `finally`:any => any>> => struct<`then`:any => any, `catch`:any => any, `finally`:any => any>;
