type `%...>%` <class<`ClusterFuture`, `Future`, `MultiprocessFuture`, `MultisessionFuture`, `environment`> | class<`promise`>, any> => class<`promise`>;
type `%...!%` <class<`ClusterFuture`, `Future`, `MultiprocessFuture`, `MultisessionFuture`, `environment`>, any> => class<`promise`>;
type `as.promise` <class<`ClusterFuture`, `Future`, `MultiprocessFuture`, `MultisessionFuture`, `environment`> | class<`promise`>> => class<`promise`>;
type `as.promise.Future` <class<`ClusterFuture`, `Future`, `MultiprocessFuture`, `MultisessionFuture`, `environment`>> => class<`promise`>;
type `as.promise.promise` <class<`promise`>> => class<`promise`>;
type `catch` <class<`ClusterFuture`, `Future`, `MultiprocessFuture`, `MultisessionFuture`, `environment`> | class<`promise`>, class<`function`>, logical> => class<`promise`>;
type `current_promise_domain` < > => null;
type `has.visible` <class<`function`>> => logical;
type `is_colexpr` <class<`call`>> => logical;
type `is_first` <class<`call`>> => logical;
type `is_function` <class<`call`> | class<`function`>> => logical;
type `is_funexpr` <class<`{`> | class<`call`> | class<`function`>> => logical;
type `is_lambda` <class<`call`> | class<`function`>> => logical;
type `is_parenthesized` <class<`(`> | class<`{`> | class<`call`>> => logical;
type `is.promising` <class<`condition`, `error`, `simpleError`> | class<`data.frame`> | class<`promise`> | double> => logical;
type `normalizeOnFulfilled` <class<`function`> | class<`function`, `rlang_lambda_function`> | null> => (class<`function`> | null);
type `normalizeOnRejected` <class<`function`> | class<`function`, `rlang_lambda_function`> | null> => (class<`function`> | class<`function`, `rlang_lambda_function`> | null);
type `pipeify_rhs` <class<`(`> | class<`{`> | class<`call`>, environment> => class<`function`>;
type `prepare_first` <class<`call`>> => class<`call`>;
type `promise` <class<`formula`> | class<`function`>> => class<`promise`>;
type `promise_all` <..., null> => class<`promise`>;
type `promise_map` <list<double>, class<`function`>, ...> => class<`promise`>;
type `promise_race` <..., null> => class<`promise`>;
type `promise_reduce` <integer[], any, ..., double> => class<`promise`>;
type `promise_reject` <character> => class<`promise`>;
type `promise_resolve` <class<`data.frame`> | class<`promise`> | double> => class<`promise`>;
type `reject` <character> => null;
type `resolve` <class<`data.frame`> | class<`promise`> | double> => null;
type `%...T>%` <class<`promise`>, any> => class<`promise`>;
type `%...T!%` <class<`promise`>, any> => class<`promise`>;
type `then` <class<`ClusterFuture`, `Future`, `MultiprocessFuture`, `MultisessionFuture`, `environment`> | class<`promise`>, class<`function`> | class<`formula`>, null | class<`formula`> | class<`function`>> => class<`promise`>;
type `tryCatch` <class<`function`> | class<`promise`> | list<class<`function`>> | list<class<`promise`>> | null, ..., any> => (class<`function`> | class<`promise`> | list<class<`function`>> | list<class<`promise`>> | null);
type `without_promise_domain` <class<`promise`>> => class<`promise`>;
type `with_promise_domain` <null, class<`promise`>, logical> => class<`promise`>;
