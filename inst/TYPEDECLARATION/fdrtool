type `approximate.fit` <double[], character, double[]> => (list<double> | list<double | null>);
type `censored.fit` <double[], double[], character> => class<`matrix`>;
type `dcor0` <double[], double, logical> => double[];
type `dhalfnorm` <double[], double, logical> => double[];
type `ecdf.pval` <double[], double> => class<`ecdf`, `function`, `stepfun`>;
type `fdrtool` <double[], character[], logical, logical, logical, character[], double> => list<double[] | character | class<`matrix`>>;
type `fitted.monoreg` <class<`monoreg`>, ...> => double[];
type `fndr.cutoff` <double[], character> => double;
type `gcmlcm` <double[], double[], character[]> => list<double[]>;
type `get.nullmodel` <character> => (list<class<`function`>> | list<class<`function`> | null>);
type `grenander` <class<`ecdf`, `function`, `stepfun`>, character[]> => class<`grenander`>;
type `hc.score` <double[]> => double[];
type `hc.thresh` <double[], double, logical> => double;
type `iqr.fit` <double[], character> => (double | null);
type `monoreg` <double[], double[] | null, double[], character[]> => class<`monoreg`>;
type `num.curv` <double, class<`function`>> => double;
type `pcor0` <double, double, logical, logical> => double;
type `phalfnorm` <double[], double, logical, logical> => double[];
type `plot.grenander` <class<`grenander`>, ...> => list<integer[]>;
type `plot.monoreg` <class<`monoreg`>, any, any, character[], ...> => (null | list<integer[]>);
type `pval.estimate.eta0` <double[], character, any, logical, double> => double;
type `pvt.fit.nullmodel` <double[], double, character> => (list<double> | list<double | null>);
type `pvt.isoMean` <double[], double[]> => double[];
type `pvt.plotlabels` <character, any, double> => list<character>;
type `qcor0` <double, double, logical, logical> => double;
type `qhalfnorm` <double[], double, logical, logical> => double[];
type `r2t` <double[], double> => double[];
type `rcor0` <double, double> => double[];
type `residuals.monoreg` <class<`monoreg`>, ...> => double[];
type `rhalfnorm` <double, double> => double[];
type `sd2theta` <double> => double;
type `t2r` <double[], double> => double[];
type `theta2sd` <double> => double;
