type `$` <double[], double, logical> => double[] | <double[], any> => double[] | < > => double[] | <double[], double, logical> => double[] | <double[], any, logical> => double[] | <double> => double | <double[], double> => double[] | <double[], any> => double[] | <double[], double> => double[] | < > => double[];
type `approximate.fit` <double[], character, double[]> => list<double | double | null>;
type `censored.fit` <double[], double[], character> => class<`matrix`>;
type `dcor0` <double[], double, logical> => double[];
type `dhalfnorm` <double[], double, logical> => double[];
type `ecdf.pval` <double[], double> => class<`ecdf`, `function`, `stepfun`>;
type `f` <double[], double, logical> => double[] | <double> => double | <double[]> => double[] | <double[]> => double[];
type `F` <double[]> => double[];
type `f0` <double[]> => double[] | <double[]> => double[];
type `F0` <double[], double> => double[] | <double[]> => double[] | <double[]> => double[] | <double> => double | <double, double> => double | <double> => double;
type `fA` <double[]> => double[];
type `FA` <double[]> => double[];
type `fdr` <double[]> => double[];
type `Fdr` <double[]> => double[];
type `fdr.pval` <double[]> => double[];
type `Fdr.pval` <double[]> => double[];
type `fdrtool` <double[], character[], logical, logical, logical, character[], double> => list<double[] | character | class<`matrix`>>;
type `filter` <character[]> => logical[];
type `fitted.monoreg` <class<`monoreg`>, ...> => double[];
type `fndr.cutoff` <double[], character> => double;
type `fndrfunc` <double> => double;
type `fun` <double[]> => double[];
type `gcmlcm` <double[], double[], character[]> => list<double[]>;
type `get.nullmodel` <character> => list<class<`function`> | class<`function`> | null>;
type `get.pval` <double[]> => double[] | <double[]> => double[];
type `grenander` <class<`ecdf`, `function`, `stepfun`>, character[]> => class<`grenander`>;
type `hc.score` <double[]> => double[];
type `hc.thresh` <double[], double, logical> => double;
type `iqr.fit` <double[], character> => (double | null);
type `monoreg` <double[], double[] | null, double[], character[]> => class<`monoreg`>;
type `num.curv` <double, class<`function`>> => double;
type `pcor0` <double, double, logical, logical> => double;
type `phalfnorm` <double[], double, logical, logical> => double[];
type `plot.grenander` <class<`grenander`>, ...> => list<integer[]>;
type `plot.monoreg` <class<`monoreg`>, any, any, character[], ...> => (null | list<integer[]>);
type `pval.estimate.eta0` <any, character, any, logical, double> => any;
type `pvt.fit.nullmodel` <double[], double, character> => list<double | double | null>;
type `pvt.isoMean` <double[], double[]> => double[];
type `pvt.plotlabels` <character, any, double> => list<character>;
type `qcor0` <double, double, logical, logical> => double;
type `qhalfnorm` <double[], double, logical, logical> => double[];
type `r2t` <double[], double> => double[];
type `rcor0` <double, double> => double[];
type `residuals.monoreg` <class<`monoreg`>, ...> => double[];
type `rhalfnorm` <double, double> => double[];
type `sd2theta` <double> => double;
type `t2r` <double[], double> => double[];
type `theta2sd` <double> => double;
