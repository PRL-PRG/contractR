type `an` <double> => complex;
type `Arma` <double[], double[]> => struct<`b`:double[], `a`:double[]>;
type `as.Arma.Zpg` <struct<`zero`:complex[], `pole`:complex[], `gain`:double>, ???> => struct<`b`:double[], `a`:double[]>;
type `bartlett` <double> => double[];
type `bilinear.default` <complex[], complex[], complex, double, ???> => struct<`zero`:complex[], `pole`:complex[], `gain`:double>;
type `bilinear.Zpg` <struct<`zero`:complex[], `pole`:complex[], `gain`:double> | struct<`zero`:double[], `pole`:complex[], `gain`:complex>, double, ???> => struct<`zero`:complex[], `pole`:complex[], `gain`:double>;
type `blackman` <double> => double[];
type `boxcar` <double> => double[];
type `butter.default` <double, double, character[], character[], ???> => struct<`b`:double[], `a`:double[]>;
type `butter.FilterOfOrder` <struct<`n`:double, `Wc`:double, `type`:character>, ???> => struct<`b`:double[], `a`:double[]>;
type `buttord` <double, double, double, double> => struct<`n`:double, `Wc`:double, `type`:character>;
type `cheb` <double, double[]> => double[];
type `cheb1ord` <double, double, double, double> => struct<`n`:double, `Wc`:double, `type`:character, `Rp`:double>;
type `chebwin` <double, double> => double[];
type `cheby1.default` <double, double, double, character[], character[], ???> => struct<`b`:double[], `a`:double[]>;
type `cheby1.FilterOfOrder` <struct<`n`:double, `Wc`:double, `type`:character, `Rp`:double>, double, double, character, ???> => struct<`b`:double[], `a`:double[]>;
type `cheby2.default` <double, double, double, character[], character[], ???> => struct<`b`:double[], `a`:double[]>;
type `chirp` <double[], double, double, double, character[], double> => double[];
type `conv` <complex[], complex[]> => complex[];
type `decimate` <double[], double, double, character> => double[];
type `ellip_ws` <double, double, double> => double;
type `ellip.default` <double, double, double, double, character[], character[], ???> => struct<`b`:double[], `a`:double[]>;
type `ellip.FilterOfOrder` <struct<`n`:double, `Wc`:double, `type`:character, `Rp`:double, `Rs`:double>, double, double, double, character, ???> => struct<`b`:double[], `a`:double[]>;
type `ellipke` <double[], double> => struct<`k`:double[], `e`:double[]>;
type `ellipord` <double, double, double, double> => struct<`n`:double, `Wc`:double, `type`:character, `Rp`:double, `Rs`:double>;
type `f` <double> => double;
type `fftfilt` <double[], double[], null> => double[];
type `filter` <character[]> => logical[];
type `filter.Arma` <struct<`b`:double[], `a`:double[]>, double[], ???> => double[];
type `filter.default` <double[], double[], double[], ???, ???, ???, ???> => double[];
type `filter.MedianFilter` <struct<`n`:double>, double[], ???> => double[];
type `FilterOfOrder` <double, double[], character, double | ???> => struct<`n`:double, `Wc`:double[], `type`:character, `beta`:double> | struct<`n`:double, `Wc`:double, `type`:character>;
type `filtfilt.Arma` <struct<`b`:double[], `a`:double[]>, double[], ???> => double[];
type `filtfilt.default` <double[], double[], double[], ???> => double[];
type `fir1` <double, double[], character[], double[], character | logical> => double[];
type `fir2` <double, double[], double[], double, double, double[]> => double[];
type `flattopwin` <double, character[]> => double[];
type `freqs.default` <double[], double[], double[], ???> => struct<`H`:complex[], `W`:double[]>;
type `freqz.Arma` <struct<`b`:double[], `a`:double[]>, double | ???> => struct<`h`:complex[], `f`:double[]>;
type `freqz.default` <double[], double[], double, null, double, ???> => struct<`h`:complex[], `f`:double[]>;
type `freqz.Ma` <double[], double | ???> => struct<`h`:complex[], `f`:double[]>;
type `gausswin` <double, double> => double[];
type `grpdelay.Arma` <struct<`b`:double[], `a`:double[]>, double> => struct<`gd`:double[], `w`:double[], `ns`:double, `HzFlag`:logical>;
type `grpdelay.default` <complex[], complex[], double, logical, double, ???> => struct<`gd`:double[], `w`:double[], `ns`:double, `HzFlag`:logical>;
type `hamming` <double> => double[];
type `hanning` <double> => double[];
type `ifft` <complex[]> => complex[];
type `impz.Arma` <struct<`b`:double[], `a`:double[]>, ???> => struct<`x`:double[], `t`:double[]>;
type `impz.default` <double[], double[], null, double, ???> => struct<`x`:double[], `t`:double[]>;
type `interp` <double[], double, double, double> => double[];
type `kaiser` <double, double> => double[];
type `kaiserord` <double[], double[], double, double> => struct<`n`:double, `Wc`:double[], `type`:character, `beta`:double>;
type `lookup` <integer[], double[]> => double[];
type `Ma` <double[]> => double[];
type `medfilt1` <double[], double, ???> => double[];
type `MedianFilter` <double> => struct<`n`:double>;
type `mkpp` <integer[], ^double[], double> => struct<`x`:integer[], `P`:^double[], `n`:double, `k`:integer, `d`:double>;
type `myacosh` <complex[]> => complex[];
type `ncauer` <double, double, double> => struct<`zero`:complex[], `pole`:complex[], `gain`:double>;
type `pchip` <integer[], double[], double[]> => double[];
type `plot.grpdelay` <struct<`gd`:double[], `w`:double[], `ns`:double, `HzFlag`:logical>, character, character, character, ???> => null;
type `poly` <complex[] | ^integer[]> => complex[];
type `postpad` <complex[], double> => complex[];
type `ppval` <struct<`x`:integer[], `P`:^double[], `n`:double, `k`:integer, `d`:double>, double[]> => double[];
type `print.grpdelay` <struct<`gd`:double[], `w`:double[], `ns`:double, `HzFlag`:logical>, ???> => struct<`gd`:double[], `w`:double[], `ns`:double, `HzFlag`:logical>;
type `remez` <double, double[], double[], double[], character[], double> => double[];
type `resample` <double[], integer, double, double> => double[];
type `roots` <integer[], character> => complex[];
type `sftrans.default` <complex[], complex[], complex, double, logical, ???> => struct<`zero`:complex[], `pole`:complex[], `gain`:double> | struct<`zero`:double[], `pole`:complex[], `gain`:complex>;
type `sftrans.Zpg` <struct<`zero`:complex[], `pole`:complex[], `gain`:double> | struct<`zero`:double[], `pole`:complex[], `gain`:complex>, double, logical, ???> => struct<`zero`:complex[], `pole`:complex[], `gain`:double> | struct<`zero`:double[], `pole`:complex[], `gain`:complex>;
type `sgolay` <double, double, double, symbol> => ^double[];
type `sgolayfilt` <double[], double, double, double, double> => double[];
type `sinc` <double[]> => double[];
type `specgram` <^double[], double, double, double[], double> => struct<`S`:^complex[], `f`:double[], `t`:double[]>;
type `triang` <double> => double[];
type `unwrap` <double[], double, double> => double[];
type `Zpg` <complex[], complex[], complex> => struct<`zero`:complex[], `pole`:complex[], `gain`:double> | struct<`zero`:double[], `pole`:complex[], `gain`:complex>;
type `zplane.Arma` <struct<`b`:double[], `a`:double[]>, ???> => null;
type `zplane.default` <double[], double[], ???> => null;
type `zplane.Zpg` <struct<`zero`:complex[], `pole`:complex[], `gain`:double>, ???> => null;
