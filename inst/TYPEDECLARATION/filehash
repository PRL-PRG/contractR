type `.local` <character, null | character[] | integer | environment | any => any, null | symbol | null | character | double[], symbol | null | logical, null> => struct<`a`:double[], `b`:double[]> | character[] | double[];
type `[` <character[], null, null, logical> => struct<`a`:double[], `b`:double[]>;
type `[[` <struct<`message`:character, `call`:language>, character, null, null> => double[] | struct<`message`:character, `call`:language>;
type `$` <double | environment, character> => null | double[] | environment;
type `$<-` <character[] | double[]> => character;
type `asMethod` <character, logical> => struct<`a`:double[], `b`:integer[]>;
type `checkMap` < > => integer;
type `createLockFile` <character> => logical;
type `createQ` < > => character;
type `db2env` < > => environment;
type `dbCreate` <character, null | character | null> => logical;
type `dbDelete` <character, null> => null | logical;
type `dbExists` <character, null> => logical;
type `dbFetch` <character, null> => null | character[] | double[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>;
type `dbInit` <null | character | null> => character;
type `dbInsert` <character, null | double[] | character[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>, null> => null | logical;
type `dbLazyLoad` <environment | null> => character[];
type `dbList` <null> => character[];
type `dbLoad` <environment | null> => character[];
type `dbMultiFetch` <character[], null> => struct<`a`:double[], `b`:double[]>;
type `dbReorganize` <null> => logical;
type `dbStartup` <character, character, character> => logical;
type `dbUnlink` <null> => logical;
type `deleteLockFile` <character> => logical;
type `doFUN` <character> => logical;
type `dumpDF` <character, null> => struct<`y`:double[], `x`:double[], `z`:double[]>;
type `dumpList` <character, null> => struct<`a`:double, `b`:double, `c`:double> | struct<`y`:double[], `x`:double[], `z`:double[]>;
type `filehashFormats` <null> => struct<`RDS`:struct<`create`:any => any, `initialize`:any => any>, `DB1`:struct<`create`:any => any, `initialize`:any => any>>;
type `filehashOption` <null> => struct<`defaultType`:character>;
type `filesize` <integer> => double;
type `filter` <character[]> => logical[];
type `fun` <character | symbol, character | symbol> => null;
type `FUN` <character> => double[];
type `getMap` < > => null | environment;
type `gotoEndPos` <integer> => double;
type `hasWorkingFtell` < > => logical;
type `isEmpty` <null> => logical;
type `lapply` <any => any, null> => struct<`a`:double, `b`:double>;
type `lockFile` <integer, null> => character;
type `make.f` <character> => any => any;
type `makeMetaEnv` <character> => struct<`updatesize`:any => any, `updatemap`:any => any, `getmap`:any => any, `getsize`:any => any>;
type `mangleName` <character> => character;
type `objectFile` <character> => character;
type `openDBConn` <character, character> => integer;
type `pop` <null> => double;
type `push` <double, null> => null;
type `readKeyMap` <integer, null | environment, double> => environment;
type `readKeys` <integer, environment, character[]> => struct<`a`:double[], `b`:double[]>;
type `readSingleKey` <integer, environment, character> => null | character[] | double[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>;
type `sha1` <struct<`value`:double, `nextkey`:null>, integer> => character;
type `show` < > => null;
type `top` <null> => double;
type `unMangleName` <character[]> => character[];
type `validityMethod` < > => logical;
type `with` <language, null> => double[] | struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `x`:double[], `z`:double[]>>;
type `wrap` <character, environment> => null;
type `writeKeyValue` <integer, character, null | character[] | double[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>> => null;
type `writeNullKeyValue` <integer, character> => null;
