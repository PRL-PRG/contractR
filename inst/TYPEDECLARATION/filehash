type `.local` <character, ? character[] | integer | environment | any => any, ? symbol | ??? | character | double[], symbol | ??? | logical, ???> => struct<`a`:double[], `b`:double[]> | character[] | double[];
type `[` <character[], ???, ???, logical> => struct<`a`:double[], `b`:double[]>;
type `[[` <struct<`message`:character, `call`:language>, character, ???, ???> => double[] | struct<`message`:character, `call`:language>;
type `$` <double | environment, character> => ? double[] | environment;
type `$<-` <character[] | double[]> => character;
type `asMethod` <character, logical> => struct<`a`:double[], `b`:integer[]>;
type `checkMap` < > => integer;
type `createLockFile` <character> => logical;
type `createQ` < > => character;
type `db2env` < > => environment;
type `dbCreate` <character, ? character | ???> => logical;
type `dbDelete` <character, ???> => ? logical;
type `dbExists` <character, ???> => logical;
type `dbFetch` <character, ???> => ? character[] | double[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>;
type `dbInit` <? character | ???> => character;
type `dbInsert` <character, ? double[] | character[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>, ???> => ? logical;
type `dbLazyLoad` <environment | ???> => character[];
type `dbList` <???> => character[];
type `dbLoad` <environment | ???> => character[];
type `dbMultiFetch` <character[], ???> => struct<`a`:double[], `b`:double[]>;
type `dbReorganize` <???> => logical;
type `dbStartup` <character, character, character> => logical;
type `dbUnlink` <???> => logical;
type `deleteLockFile` <character> => logical;
type `doFUN` <character> => logical;
type `dumpDF` <character, null> => struct<`y`:double[], `x`:double[], `z`:double[]>;
type `dumpList` <character, null> => struct<`a`:double, `b`:double, `c`:double> | struct<`y`:double[], `x`:double[], `z`:double[]>;
type `filehashFormats` <???> => struct<`RDS`:struct<`create`:any => any, `initialize`:any => any>, `DB1`:struct<`create`:any => any, `initialize`:any => any>>;
type `filehashOption` <???> => struct<`defaultType`:character>;
type `filesize` <integer> => double;
type `filter` <character[]> => logical[];
type `fun` <character | symbol, character | symbol> => null;
type `FUN` <character> => double[];
type `getMap` < > => ? environment;
type `gotoEndPos` <integer> => double;
type `hasWorkingFtell` < > => logical;
type `isEmpty` <???> => logical;
type `lapply` <any => any, ???> => struct<`a`:double, `b`:double>;
type `lockFile` <integer, ???> => character;
type `make.f` <character> => any => any;
type `makeMetaEnv` <character> => struct<`updatesize`:any => any, `updatemap`:any => any, `getmap`:any => any, `getsize`:any => any>;
type `mangleName` <character> => character;
type `objectFile` <character> => character;
type `openDBConn` <character, character> => integer;
type `pop` <???> => double;
type `push` <double, ???> => null;
type `readKeyMap` <integer, ? environment, double> => environment;
type `readKeys` <integer, environment, character[]> => struct<`a`:double[], `b`:double[]>;
type `readSingleKey` <integer, environment, character> => ? character[] | double[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>;
type `sha1` <struct<`value`:double, `nextkey`:null>, integer> => character;
type `show` < > => null;
type `top` <???> => double;
type `unMangleName` <character[]> => character[];
type `validityMethod` < > => logical;
type `with` <language, ???> => double[] | struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`y`:double[], `x`:double[], `z`:double[]>>;
type `wrap` <character, environment> => null;
type `writeKeyValue` <integer, character, ? character[] | double[] | struct<`value`:double, `nextkey`:character> | struct<`value`:double, `nextkey`:null>> => null;
type `writeNullKeyValue` <integer, character> => null;
