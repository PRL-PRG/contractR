type `[.optimx` <struct<`ymax`:double[], `xhalf`:double[], `value`:double[], `fevals`:double[], `gevals`:^double[], `niter`:^double[], `convcode`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, null | integer[] | double | character> => struct<`ymax`:double, `xhalf`:double> | ^double[];
type `filter` <character[]> => logical[];
type `optimx` <double[], any => any, null | any => any, null | any => any, double, double, character[] | language, null, logical, tuple<> | struct<`all.methods`:logical>, null | double> => struct<`xhalf`:double, `value`:double, `fevals`:double, `gevals`:double, `niter`:null, `convcode`:double, `kkt1`:logical, `kkt2`:logical, `xtime`:double>;
type `optimx.check` <double[], any => any, null | any => any, null | any => any, double, double, symbol | logical, struct<`follow.on`:logical, `save.failures`:logical, `trace`:double, `kkt`:logical, `all.methods`:logical, `starttests`:logical, `maximize`:logical, `dowarn`:logical, `usenumDeriv`:logical, `kkttol`:double, `kkt2tol`:double, `badval`:double, `scaletol`:double>, logical, language | logical, null | double> => struct<`grbad`:logical, `hessbad`:logical, `scalebad`:logical>;
type `optimx.run` <double[], any => any, null | any => any, null | any => any | language, double, double, character[], null, logical, struct<`follow.on`:logical, `save.failures`:logical, `trace`:double, `kkt`:logical, `all.methods`:logical, `starttests`:logical, `maximize`:logical, `dowarn`:logical, `usenumDeriv`:logical, `kkttol`:double, `kkt2tol`:double, `badval`:double, `scaletol`:double, `have.bounds`:logical>, null | double> => struct<`xhalf`:double, `value`:double, `fevals`:double, `gevals`:double, `niter`:null, `convcode`:double, `kkt1`:double, `kkt2`:double, `xtime`:double>;
type `optimx.setup` <double[], any => any, null | any => any, null | any => any, double, double, character[] | symbol, symbol, symbol, tuple<> | struct<`all.methods`:logical>, null | double> => struct<`fname`:character, `npar`:integer, `ctrl`:struct<`follow.on`:logical, `save.failures`:logical, `trace`:double, `kkt`:logical, `all.methods`:logical, `starttests`:logical, `maximize`:logical, `dowarn`:logical, `usenumDeriv`:logical, `kkttol`:double, `kkt2tol`:double, `badval`:double, `scaletol`:double>, `usenumDeriv`:logical, `ufn`:any => any, `have.bounds`:logical, `method`:character[]> | struct<`fname`:character, `npar`:integer, `ctrl`:struct<`follow.on`:logical, `save.failures`:logical, `trace`:double, `kkt`:logical, `all.methods`:logical, `starttests`:logical, `maximize`:logical, `dowarn`:logical, `usenumDeriv`:logical, `kkttol`:double, `kkt2tol`:double, `badval`:double, `scaletol`:double>, `usenumDeriv`:logical, `ufn`:any => any, `have.bounds`:logical, `method`:character> | struct<`fname`:character, `npar`:integer, `ctrl`:struct<`follow.on`:logical, `save.failures`:logical, `trace`:double, `kkt`:logical, `all.methods`:logical, `starttests`:logical, `maximize`:logical, `dowarn`:logical, `usenumDeriv`:logical, `kkttol`:double, `kkt2tol`:double, `badval`:double, `scaletol`:double>, `usenumDeriv`:logical, `ufn`:any => any, `ugr`:any => any, `have.bounds`:logical, `method`:character[]> | struct<`fname`:character, `npar`:integer, `ctrl`:struct<`follow.on`:logical, `save.failures`:logical, `trace`:double, `kkt`:logical, `all.methods`:logical, `starttests`:logical, `maximize`:logical, `dowarn`:logical, `usenumDeriv`:logical, `kkttol`:double, `kkt2tol`:double, `badval`:double, `scaletol`:double>, `usenumDeriv`:logical, `ufn`:any => any, `ugr`:any => any, `uhess`:any => any, `have.bounds`:logical, `method`:character[]>;
type `scalecheck` <double[], double, double, language> => struct<`lpratio`:double, `lbratio`:null>;
type `[.opm` <struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, integer[] | null | character | double> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]> | ^double[];
type `as.data.frame.opm` <struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, null, logical, symbol> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>;
type `as.data.frame.optimx` <struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `niter`:^double[], `convcode`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, null, logical, symbol> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `niter`:^double[], `convcode`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>;
type `axsearch` <double[], any => any, double, double[], double[], null, double, null> => struct<`bestfn`:double, `par`:double[], `details`:struct<`par0`:double[], `fback`:double[], `fmin0`:double[], `ffwd`:double[], `parstep`:double[], `tilt`:double[], `roc`:double[]>> | struct<`bestfn`:double, `par`:double[], `details`:struct<`par0`:double[], `fback`:^logical[], `fmin0`:double[], `ffwd`:double[], `parstep`:double[], `tilt`:double[], `roc`:double[]>>;
type `bmstep` <double[], double[], double[], double[], double[], double> => double;
type `cnvtst` <symbol | double, symbol | double, symbol | double, symbol | double, symbol | double, symbol | double, ^double[], double, double, double[] | symbol, double[], double> => struct<`conv`:double, `flast1`:double, `ipivot1`:double[]>;
type `coef.opm` <struct<`p1`:^double[], `p2`:^double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:^logical[], `kkt2`:^logical[], `xtime`:double[]>, null> => ^double[];
type `coef.optimx` <struct<`p1`:double[], `p2`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `niter`:^double[], `convcode`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, null> => ^double[];
type `crash` <double[], double[], double[]> => struct<`ipivot`:double[], `ierror`:double, `xnew`:double[]>;
type `ctrldefault` <double> => struct<`acctol`:double, `all.methods`:logical, `allmeth`:character[], `allpkg`:character[], `badval`:double, `bdmeth`:character[], `bigval`:double, `defgrapprox`:character, `defmethod`:character, `defstep`:double, `dowarn`:logical, `eps`:double, `epstol`:double, `fnscale`:double, `grtesttol`:double, `have.bounds`:logical, `hessasymtol`:double, `hesstesttol`:double, `keepinputpar`:logical, `kkt`:logical, `kkttol`:double, `kkt2tol`:double, `maskmeth`:character[], `maximize`:logical, `maxit`:double, `maxfeval`:double, `offset`:double, `parchanged`:logical, `parscale`:double[], `reltest`:double, `save.failures`:logical, `scaletol`:double, `stepdec`:double, `steplen0`:double, `stepmax`:double, `stepmin`:double, `stepredn`:double, `stopbadupdate`:logical, `tol`:double, `trace`:double, `watch`:logical>;
type `efn` <double[], double | null> => double;
type `egr` <double[], null | double> => double[];
type `ehess` <double[], double | null> => ^double[];
type `f` <double[], null | double> => double;
type `ffn` <double[], double | null> => double;
type `fn` <double[], double | null> => double;
type `fnchk` <double[] | symbol, any => any | symbol, double, ^integer[] | null | character | symbol> => struct<`fval`:^double[], `infeasible`:logical, `excode`:double, `msg`:character> | struct<`fval`:null, `infeasible`:logical, `excode`:double, `msg`:character>;
type `fun` <double[], double | null> => double;
type `func` <double[], double | null> => double;
type `ggr` <double[], double | null> => double[];
type `gr` <double[], null | double> => double[];
type `gradient` <double[], null | double> => double[];
type `grback` <double[], any => any, null, environment, double> => double[];
type `grcentral` <double[], any => any, null, environment, double> => double[];
type `grchk` <double[], any => any, any => any, double, double, double | null> => logical;
type `grfwd` <double[], any => any, null, environment, null | double> => double[];
type `grnd` <double[], any => any, null | double> => double[];
type `gtims` <double[], double[], double[], double, double, any => any, double | null> => double[];
type `hess` <double[], double | null> => ^double[];
type `hesschk` <double[], any => any, any => any, any => any, double, double, double | null> => logical;
type `hessian` <double[], double | null> => ^double[];
type `hjn` <double[], any => any, double[], double[], null | double[], struct<`trace`:double>, null | double> => struct<`par`:double[], `value`:double, `counts`:^double[], `convergence`:double>;
type `initpc` <double[], double, symbol | logical> => struct<`td`:double[]>;
type `kktchk` <double[], any => any, any => any, null, double[], double[], logical, struct<`trace`:double>, null> => struct<`gmax`:double, `evratio`:null, `kkt1`:logical, `kkt2`:logical, `hev`:double[], `ngatend`:double[], `nhatend`:^double[]>;
type `lin1` <double[], double[], double, double, double[], any => any, double | null> => struct<`xnew`:double[], `fnew`:double, `gnew`:double[], `nf1`:integer, `ierror`:double, `alpha1`:double>;
type `modz` <double[], double[], double[], double[], double[] | symbol, symbol, double, symbol> => struct<`flast1`:double, `ipivot1`:double[]>;
type `msolve` <double[], double, symbol | logical, symbol | double, double[]> => struct<`y`:double[]>;
type `multistart` <^double[], any => any, any => any, double, double, character, logical, struct<`trace`:double>, null> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `value`:double[], `fevals`:double[], `gevals`:double[], `convergence`:double[]>;
type `mygr` <double[], double | null | any => any, null | double> => double[];
type `ndia3` <double[], double[], double[] | symbol, double[], double | language> => double[];
type `norm2` <double[]> => double;
type `objective` <double[], double | null> => double;
type `opm` <double[], any => any, null | any => any | character, null | any => any, double[], double[], character[], logical, null | double[] | struct<`trace`:double> | pairlist | struct<`kkt`:logical> | character[], double | null> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>;
type `optchk` <double[], any => any, any => any, null, double[], double[], struct<`acctol`:double, `all.methods`:logical, `allmeth`:character[], `allpkg`:character[], `badval`:double, `bdmeth`:character[], `bigval`:double, `defgrapprox`:character, `defmethod`:character, `defstep`:double, `dowarn`:logical, `eps`:double, `epstol`:double, `fnscale`:double, `grtesttol`:double, `have.bounds`:logical, `hessasymtol`:double, `hesstesttol`:double, `keepinputpar`:logical, `kkt`:logical, `kkttol`:double, `kkt2tol`:double, `maskmeth`:character[], `maximize`:logical, `maxit`:double, `maxfeval`:double, `offset`:double, `parchanged`:logical, `parscale`:double[], `reltest`:double, `save.failures`:logical, `scaletol`:double, `stepdec`:double, `steplen0`:double, `stepmax`:double, `stepmin`:double, `stepredn`:double, `stopbadupdate`:logical, `tol`:double, `trace`:double, `watch`:logical>, null> => struct<`grOK`:logical, `hessOK`:null, `scalebad`:logical, `scaleratios`:double[]>;
type `optimr` <double[], any => any, null | any => any | character, null | any => any, double[], double[], character, logical, struct<`trace`:double> | symbol | tuple<> | double[] | struct<`maxit`:double>, null | double> => struct<`convergence`:double, `value`:double, `par`:^logical[], `counts`:^logical[]> | struct<`par`:double[], `value`:double, `convergence`:double, `message`:character, `counts`:^double[], `nitns`:null> | struct<`par`:double[], `value`:double, `convergence`:double, `niter`:double, `counts`:^double[]> | struct<`par`:double[], `value`:double, `counts`:^double[], `convergence`:double, `message`:null> | struct<`value`:double, `par`:double[], `convergence`:double, `counts`:^logical[]> | struct<`value`:double, `par`:^logical[], `convergence`:double, `counts`:null>;
type `polyopt` <double[], any => any, any => any, double, double, struct<`method`:integer[], `maxit`:double[], `maxfeval`:double[]>, logical, struct<`trace`:double>, null> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `value`:double[], `fevals`:double[], `gevals`:^double[], `convergence`:double[]>;
type `proptimr` <struct<`convergence`:double, `value`:double, `par`:double[], `counts`:^integer[], `message`:character> | struct<`par`:double[], `value`:double, `counts`:double[], `convergence`:double, `message`:character>> => null;
type `Rcgmin` <double[], symbol | any => any, null | any => any, null | double[], null | double[], null | double[], struct<`trace`:double> | tuple<> | struct<`maxit`:double> | integer, null | double> => tuple<double[], null, double[], double, character> | struct<`par`:double[], `value`:double, `counts`:double[], `convergence`:double, `message`:character>;
type `Rvmmin` <double[], any => any, null | character | any => any, null | double[], null | double[], null | double[], struct<`trace`:double> | tuple<> | struct<`maxit`:double>, null | double> => struct<`par`:double[], `value`:double, `counts`:double[], `convergence`:double, `message`:character>;
type `Rvmminb` <double[], any => any, any => any | character, double[], double[], double[], tuple<> | struct<`trace`:double, `dowarn`:logical>, null | double> => struct<`par`:double[], `value`:double, `counts`:double[], `convergence`:double, `message`:character, `bdmsk`:double[]>;
type `Rvmminu` <double[], any => any, any => any | character, tuple<> | struct<`trace`:double>, null | double> => struct<`par`:double[], `value`:double, `counts`:double[], `convergence`:double, `message`:character>;
type `scalechk` <double[], double[], double[], null | logical, logical> => struct<`lpratio`:double, `lbratio`:double>;
type `sfun` <double[], double | null> => double;
type `snewton` <double[], any => any, any => any, any => any, struct<`trace`:double> | struct<`offset`:double>, null | double> => struct<`par`:double[], `value`:double, `grad`:double[], `Hess`:^double[], `counts`:struct<`niter`:double, `nfn`:double, `ngr`:double, `nhess`:double>, `convcode`:double, `message`:character>;
type `snewtonm` <double[], any => any, any => any, any => any, struct<`trace`:double>, null | double> => struct<`par`:double[], `value`:double, `grad`:double[], `Hess`:^double[], `counts`:struct<`niter`:double, `nfn`:double, `ngr`:double, `nhess`:double>, `convcode`:double, `message`:character>;
type `ssbfgs` <double[], double[], double[], double, double, double, double> => double[];
type `step1` <double, ^double[], double> => double;
type `stpmax` <double, double, double[], double[], double[], double[] | symbol, double[] | symbol> => double;
type `summary.opm` <struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, null | symbol | character, integer[], null> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `convergence`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>;
type `summary.optimx` <struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `niter`:^double[], `convcode`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>, null | symbol | any => any | language | character, integer[] | double, null> => struct<`p1`:double[], `p2`:double[], `p3`:double[], `p4`:double[], `p5`:double[], `p6`:double[], `p7`:double[], `p8`:double[], `p9`:double[], `p10`:double[], `value`:double[], `fevals`:^double[], `gevals`:^double[], `niter`:^double[], `convcode`:double[], `kkt1`:logical[], `kkt2`:logical[], `xtime`:double[]>;
type `tn` <double[], any => any, double, double | null> => struct<`xstar`:double[], `f`:double, `g`:double[], `ierror`:double, `nfngr`:double>;
type `tnbc` <double[], any => any, double[], double[], double, null> => struct<`xstar`:double[], `f`:double, `g`:double[], `ierror`:double, `nfngr`:double>;
type `ztime` <double[], double[]> => double[];
