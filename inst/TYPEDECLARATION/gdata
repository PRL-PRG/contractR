type `.checkLevelsMap` <struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character> | struct<`b`:integer, `c`:integer, `d`:integer, `e`:integer, `l`:integer, `m`:integer, `n`:integer, `o`:integer, `p`:integer, `s`:integer, `w`:integer, `x`:integer, `y`:integer, `z`:integer>, character> => null;
type `.unknownList` <struct<`xFac`:^integer[], `xInt`:^double[]>, character[] | double | tuple<character, double> | struct<`.default`:double, `xFac`:character>> => character[] | double[] | struct<`xFac`:character, `xInt`:double>;
type `[.levelsMap` <struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character>, integer[]> => struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>;
type `[[` <symbol> => logical;
type `ans` < > => null;
type `Args` <symbol, logical> => struct<`value`:character[]>;
type `as.object_sizes` <double[]> => double[];
type `bindData` <struct<`y1`:double[], `f1`:integer[], `ch`:character[], `fa`:integer[], `nu`:double[], `id`:integer[]>, struct<`y2`:double[], `f2`:integer[], `ch`:character[], `fa`:integer[], `nu`:double[], `id`:integer[]>, character[]> => struct<`id`:integer[], `nu`:double[], `ch`:character[], `fa`:integer[], `y1`:^double[], `f1`:^integer[], `y2`:^double[], `f2`:^character[]>;
type `c.levelsMap` <struct<`0`:character, `1`:character, `2`:character, `3`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character>, logical, logical> => struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>;
type `c.listLevelsMap` <tuple<struct<`0`:character, `1`:character, `2`:character, `3`:character>, struct<`999`:character>> | tuple<struct<`0`:character, `1`:character, `2`:character, `3`:character>, struct<`NA`:character>> | tuple<struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character>, struct<`e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>>, logical, logical> => struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>;
type `case` <double[], double, ? character> => ^integer[];
type `cbindX` <^character[] | struct<>> => ^character[] | struct<>;
type `centerText` <character[], integer> => character[];
type `ConvertMedUnits` <double[], character, ???, character, logical> => double[];
type `drop.levels.data.frame` <struct<`Concentration`:double[]>, logical, ???> => struct<`Concentration`:double[]>;
type `drop.levels.default` <character[] | double[], logical | symbol, ???> => character[] | double[];
type `drop.levels.factor` <integer[], logical, ???> => integer[];
type `drop.levels.list` <struct<`Concentration`:double[]> | struct<`f`:integer[], `i`:integer[], `c`:character[]>, symbol | logical, ???> => struct<`Concentration`:double[]> | struct<`f`:integer[], `i`:integer[], `c`:integer[]> | struct<`PlateDay`:integer[], `Read`:integer[]> | struct<`f`:integer[], `i`:integer[], `c`:character[]>;
type `filter` <character[]> => logical[];
type `findPerl` <character | ???, logical | character> => character;
type `first` <^character[] | struct<> | integer[] | struct<`a`:double, `b`:double, `c`:double>, double, ???> => ^character[] | struct<> | integer | struct<`a`:double>;
type `first<-` <^character[] | struct<> | integer[] | struct<`a`:double, `b`:double, `c`:double>, double, ???, character | integer[] | double> => ^character[] | struct<> | double[] | struct<`a`:character, `b`:double, `c`:double>;
type `format.object_sizes` <double[], logical | language, character, symbol | character | ???, double, null, character, character[] | language, ???> => character[];
type `frameApply` <struct<`PlateDay`:integer[], `Read`:integer[], `Description`:character[], `Concentration`:^double[], `Signal`:double[]>, character[], character[], any => any, language | logical | symbol, logical, character, logical | ???> => struct<`Concentration`:double[], `Mean`:double[], `SD`:double[], `N`:double[]>;
type `fun` <symbol, symbol> => null;
type `FUN` <^character[] | ^double[] | tuple<struct<`0`:character, `1`:character, `2`:character, `3`:character>, struct<`999`:character>> | tuple<struct<`0`:character, `1`:character, `2`:character, `3`:character>, struct<`NA`:character>> | tuple<struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character>, struct<`e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>> | struct<> | struct<`0`:character, `1`:character, `2`:character, `3`:character> | struct<`999`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character> | struct<`e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character> | struct<`NA`:character>, double | character | ???, character[], double | symbol, ? double, symbol> => ? ^character[] | ^double[] | tuple<null, null>;
type `get` <? any => any | double | struct<`coefficients`:double, `residuals`:double, `effects`:double, `rank`:integer, `fitted.values`:double, `assign`:integer, `qr`:struct<`qr`:^double[], `qraux`:double, `pivot`:integer, `tol`:double, `rank`:integer>, `df.residual`:integer, `call`:language, `terms`:language, `model`:struct<`1`:double>>> => logical;
type `getDay.Date` <double, character, ???> => character;
type `getDay.POSIXct` <double, character, ???> => character;
type `getDay.POSIXlt` <struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer, `zone`:character, `gmtoff`:integer>, character, ???> => character;
type `getMonth.Date` <double, character, ???> => character;
type `getMonth.POSIXct` <double, character, ???> => character;
type `getMonth.POSIXlt` <struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer, `zone`:character, `gmtoff`:integer>, character, ???> => character;
type `getYear.Date` <double, character, ???> => character;
type `getYear.POSIXct` <double, character, ???> => character;
type `getYear.POSIXlt` <struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer, `zone`:character, `gmtoff`:integer>, character, ???> => character;
type `humanReadable` <double[], character | symbol, character[], double, ? double, character, character[]> => character[];
type `interleave` <^double[], logical, character, logical> => ^character[] | ^integer[];
type `is.levelsMap` <struct<`0`:character, `1`:character, `2`:character, `3`:character> | struct<`999`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character> | struct<`b`:integer, `c`:integer, `d`:integer, `e`:integer, `l`:integer, `m`:integer, `n`:integer, `o`:integer, `p`:integer, `s`:integer, `w`:integer, `x`:integer, `y`:integer, `z`:integer> | struct<`e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character> | struct<`NA`:character>> => logical;
type `is.listLevelsMap` <tuple<struct<`0`:character, `1`:character, `2`:character, `3`:character>, struct<`999`:character>> | tuple<struct<`0`:character, `1`:character, `2`:character, `3`:character>, struct<`NA`:character>> | tuple<struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character>, struct<`e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>>> => logical;
type `is.object_sizes` <double[]> => logical;
type `isUnknown.default` <^double[], ^double[] | ^character[], ???> => logical[];
type `isUnknown.list` <struct<`xFac`:integer[], `xInt`:double[]>, character[] | tuple<character, double> | struct<`.default`:double, `xFac`:character>, ???> => struct<`xFac`:logical[], `xInt`:logical[]>;
type `last` <^character[] | struct<> | integer[] | struct<`a`:double, `b`:double, `c`:double>, double, ???> => ^character[] | struct<> | integer | struct<`c`:double>;
type `last<-` <^character[] | struct<> | double[] | struct<`a`:character, `b`:double, `c`:double>, double, ???, character | tuple<double[]> | double> => ^character[] | struct<> | double[] | struct<`a`:character, `b`:double, `c`:character>;
type `left.data.frame` <struct<`Col_1`:integer[], `Col_2`:integer[], `Col_3`:integer[], `Col_4`:integer[], `Col_5`:integer[], `Col_6`:integer[], `Col_7`:integer[], `Col_8`:integer[], `Col_9`:integer[], `Col_10`:integer[]>, double> => struct<`Col_1`:integer[], `Col_2`:integer[], `Col_3`:integer[], `Col_4`:integer[], `Col_5`:integer[], `Col_6`:integer[]>;
type `left.matrix` <^integer[], double> => ^integer[];
type `lowerTriangle` <^integer[], logical, logical> => integer[];
type `lowerTriangle<-` <^character[] | ^integer[], logical, logical, ? character[] | integer[]> => ^character[] | ^integer[];
type `mapLevels.character` <character, logical, logical, logical, logical, ???> => struct<`999`:character> | struct<`NA`:character>;
type `mapLevels.factor` <character | ^integer[], logical, logical, symbol | logical, logical, ???> => struct<`999`:character> | struct<`NA`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character> | struct<`b`:integer, `c`:integer, `d`:integer, `e`:integer, `l`:integer, `m`:integer, `n`:integer, `o`:integer, `p`:integer, `s`:integer, `w`:integer, `x`:integer, `y`:integer, `z`:integer> | struct<`e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>;
type `mapLevels<-.default` <^integer[] | character[], struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character> | struct<`b`:integer, `c`:integer, `d`:integer, `e`:integer, `l`:integer, `m`:integer, `n`:integer, `o`:integer, `p`:integer, `s`:integer, `w`:integer, `x`:integer, `y`:integer, `z`:integer>> => ^integer[];
type `matchcols` <^logical[], character[], character[] | ???, character[], ???> => character[];
type `mv` <character, character, environment> => null;
type `NAToUnknown.default` <^double[], double, logical, logical, ???> => double[];
type `NAToUnknown.factor` <^integer[], character | double, logical, logical, ???> => integer[];
type `NAToUnknown.list` <struct<`xFac`:^integer[], `xInt`:^double[]>, double, logical, logical, ???> => struct<`xFac`:integer[], `xInt`:double[]>;
type `nobs.data.frame` <struct<`x`:^double[], `y`:^double[]>, ???> => integer[];
type `nobs.default` <^double[], ???> => integer;
type `nPairs` <struct<`V1`:double[], `V2`:^double[], `V3`:^double[], `V4`:^double[]>, logical, logical, logical, ???> => ^integer[];
type `object.size` <? any => any | ^character[] | struct<> | ^double[] | expression | language | tuple<> | struct<`a`:character, `b`:double, `c`:character> | struct<`epsilon`:double, `maxit`:double, `trace`:logical> | struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `simulate`:any => any> | struct<`platform`:character, `arch`:character, `os`:character, `system`:character, `status`:character, `major`:character, `minor`:character, `year`:character, `month`:character, `day`:character, `svn rev`:character, `language`:character, `version.string`:character, `nickname`:character> | struct<`qr`:^double[], `rank`:integer, `qraux`:double[], `pivot`:integer[], `tol`:double> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer, `zone`:character, `gmtoff`:integer>> => double[];
type `print.object_sizes` <double[], logical, logical, character, ???, double, null, character, character[], ???> => double[];
type `read.xls` <character, double | character, logical, ???, character[], ??? | character | double, character[], character> => struct<`A`:integer[], `B`:integer[], `C`:integer[]>;
type `remove.vars` <struct<`first`:integer[], `second`:integer[], `third`:integer[]>, character, logical> => struct<`first`:integer[], `third`:integer[]>;
type `rename.vars` <struct<`x`:integer[], `y`:integer[], `z`:integer[]>, character[], character[], logical> => struct<`first`:integer[], `second`:integer[], `third`:integer[]>;
type `reorder.factor` <integer[], ???, ???, ???, logical, ??? | character[] | double[], any => any | symbol> => ^integer[];
type `resample` <double[], ???, logical, null> => double[];
type `sheetCmd` <character, character, logical, character> => character[] | integer;
type `sheetCount` <character, logical, character> => integer;
type `sheetNames` <character, logical, character> => character[];
type `show` <character> => null;
type `sort.levelsMap` <struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>, logical, logical, ???> => struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `e`:character, `f`:character, `f`:character, `g`:character, `g`:character, `h`:character, `h`:character, `i`:character, `i`:character, `j`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>;
type `startsWith` <character[], character, logical, logical> => logical[];
type `summary.nPairs` <^integer[], ???> => ^double[];
type `trim.character` <character[], logical | symbol, ???> => character[];
type `trim.data.frame` <struct<`s`:integer[], `f`:integer[], `i`:integer[]>, logical, ???> => struct<`s`:integer[], `f`:integer[], `i`:integer[]>;
type `trim.default` <integer[], logical, ???> => integer[];
type `trim.factor` <integer[], logical, ???> => integer[];
type `trim.list` <struct<`s`:integer[], `f`:integer[], `i`:integer[]> | struct<`s`:character[], `f`:integer[], `i`:integer[]>, logical, ???> => struct<`s`:integer[], `f`:integer[], `i`:integer[]> | struct<`s`:character[], `f`:integer[], `i`:integer[]>;
type `trimSum` <^integer[], double, logical, logical, ???> => ^integer[];
type `unique.levelsMap` <struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `e`:character, `f`:character, `f`:character, `g`:character, `g`:character, `h`:character, `h`:character, `i`:character, `i`:character, `j`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>, logical, ???> => struct<`0`:character, `1`:character, `2`:character, `3`:character, `999`:character> | struct<`0`:character, `1`:character, `2`:character, `3`:character, `NA`:character> | struct<`a`:character, `b`:character, `c`:character, `d`:character, `e`:character, `f`:character, `g`:character, `h`:character, `i`:character, `j`:character, `k`:character, `l`:character, `m`:character, `n`:character>;
type `unknownToNA.default` <^double[], double, logical, ???> => ^double[];
type `unknownToNA.factor` <^integer[], character, logical, ???> => ^integer[];
type `update.list` <struct<`a`:double, `b`:character, `c`:double> | struct<`a`:double, `b`:character, ``:double, ``:double, ``:double>, struct<`b`:character, `c`:double> | struct<`b`:character, ``:double, ``:double, ``:double>, logical, ???> => struct<`a`:double, `b`:character, `c`:double> | struct<`a`:double, `b`:character, ``:double, ``:double, ``:double>;
type `upperTriangle` <^character[] | ^integer[], logical, logical> => character[] | integer[];
type `upperTriangle<-` <^integer[], logical, logical, ? integer[]> => ^integer[];
type `wideByFactor` <struct<`y1`:double[], `y2`:double[], `f1`:integer[], `f2`:integer[], `c1`:integer[], `c2`:double[]>, character, character[], logical, logical> => struct<`c1`:integer[], `c2`:double[], `f1`:integer[], `y1.a`:^double[], `y2.a`:^double[], `f2.a`:^integer[], `y1.b`:^double[], `y2.b`:^double[], `f2.b`:^integer[]>;
type `write.fwf` <struct<`num1`:^integer[], `num2`:^double[], `num3`:^double[], `int1`:^integer[]>, character, logical, logical, character, character, logical, logical, null, character, logical, logical, ? double, character, character[], logical, ???> => null;
