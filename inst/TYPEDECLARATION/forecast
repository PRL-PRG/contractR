type `accuracy` <class<`ARIMA`, `Arima`, `forecast_ARIMA`> | class<`ets`> | class<`forecast`> | class<`forecast`, `splineforecast`> | class<`ts`>, ...> => class<`matrix`>;
type `accuracy.default` <class<`ARIMA`, `Arima`, `forecast_ARIMA`> | class<`ets`> | class<`forecast`> | class<`forecast`, `splineforecast`> | class<`ts`>, any, null | integer[], null, null, ...> => class<`matrix`>;
type `Acf` <class<`ts`>, double | null, character[], logical, class<`function`>, any, ...> => class<`acf`>;
type `admissible` <double, double | null, null | double, double | null, any> => double;
type `arfima` <double[], double[], character[], null, null, logical, double[], ...> => class<`ARFIMA`, `fracdiff`>;
type `Arima` <class<`ts`> | double[], double[], double[] | list<double[]>, null, logical, logical, any, double | null, logical, character[], null | class<`ARIMA`, `Arima`, `forecast_ARIMA`>, class<`ts`> | double[], ...> => class<`ARIMA`, `Arima`, `forecast_ARIMA`>;
type `arima2` <double[], class<`ARIMA`, `Arima`, `forecast_ARIMA`>, any, character[]> => class<`ARIMA`, `Arima`, `forecast_ARIMA`>;
type `arimaorder` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>> => integer[];
type `arima.string` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, logical> => character;
type `arroots` <class<`ar`> | class<`ARIMA`, `Arima`, `forecast_ARIMA`>> => class<`armaroots`>;
type `as.character.Arima` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, ...> => character;
type `as.data.frame.forecast` <class<`forecast`> | class<`forecast`, `splineforecast`>, ...> => class<`data.frame`>;
type `auto.arima` <class<`ts`> | double[], null, null, double, double, double, double, double, double, double, double, double, double, double, logical, logical, character[], logical, double, logical> => class<`ARIMA`, `Arima`, `forecast_ARIMA`>;
type `autolayer.forecast` <class<`forecast`> | class<`forecast`, `splineforecast`>, null, logical, logical, ...> => class<`Layer`, `LayerInstance`, `gg`, `ggproto`>;
type `autolayer.mforecast` <class<`mforecast`>, null, logical, ...> => list<class<`Layer`, `LayerInstance`, `gg`, `ggproto`>>;
type `autolayer.ts` <class<`ts`>, logical, character, ...> => class<`Layer`, `LayerInstance`, `gg`, `ggproto`>;
type `autoplot.acf` <class<`acf`>, double, ...> => class<`gg`, `ggplot`>;
type `autoplot.ar` <class<`ar`>, ...> => class<`gg`, `ggplot`>;
type `autoplot.Arima` <class<`ar`> | class<`ARIMA`, `Arima`, `forecast_ARIMA`>, any, ...> => class<`gg`, `ggplot`>;
type `autoplot.decomposed.ts` <class<`decomposed.ts`>, null, null, ...> => class<`gg`, `ggplot`>;
type `autoplot.ets` <class<`ets`>, null, ...> => class<`gg`, `ggplot`>;
type `autoplot.forecast` <class<`forecast`>, any, logical, any, character, double, ...> => class<`gg`, `ggplot`>;
type `autoplot.mforecast` <class<`mforecast`>, logical, logical, logical, ...> => (class<`gg`, `ggplot`> | null);
type `autoplot.mstl` <class<`mstl`, `msts`, `mts`, `ts`> | class<`mstl`, `mts`, `ts`>, ...> => class<`gg`, `ggplot`>;
type `autoplot.mts` <class<`mstl`, `msts`, `mts`, `ts`> | class<`mstl`, `mts`, `ts`> | class<`matrix`, `mts`, `ts`>, logical, logical, character, character[], null, ...> => class<`gg`, `ggplot`>;
type `autoplot.splineforecast` <class<`forecast`, `splineforecast`>, logical, ...> => class<`gg`, `ggplot`>;
type `autoplot.stl` <class<`stl`>, null, logical, ...> => class<`gg`, `ggplot`>;
type `autoplot.ts` <class<`ts`>, character | null, character, character, null | character, ...> => class<`gg`, `ggplot`>;
type `avnnet` <class<`matrix`>, double[], double, logical, logical, ...> => class<`nnetarmodels`>;
type `baggedModel` <class<`ts`>, list<class<`ts`>>, class<`function`>, ...> => class<`baggedModel`>;
type `bizdays` <class<`ts`>, character> => class<`ts`>;
type `bld.mbb.bootstrap` <class<`ts`>, double, null> => list<class<`ts`>>;
type `BoxCox` <class<`ts`>, double> => class<`ts`>;
type `BoxCox.lambda` <class<`ts`>, character[], double, double> => double;
type `calcOCSBCritVal` <double> => double;
type `Ccf` <class<`ts`>, class<`ts`>, null, character[], logical, class<`function`>, ...> => class<`acf`>;
type `check.param` <double, double | null, null | double, double | null, double[], double[], character, any> => double;
type `checkresiduals` <class<`ets`>, any, null, any, logical, ...> => class<`htest`>;
type `class1` <double, double[], character, character, any, any, double, double[]> => list<double[]>;
type `class2` <double, double[], character, character, logical, any, double, double[]> => list<double[]>;
type `class3` <double, double[], character, any, logical, double, double, double[]> => list<double[]>;
type `croston` <integer[], double, double, integer[]> => class<`forecast`>;
type `croston2` <integer[], double, any, logical> => (class<`ts`> | list<class<`ts`> | list<class<`forecast`>>>);
type `CV` <class<`lm`, `tslm`>> => double[];
type `CVar` <class<`ts`>, double, class<`function`>, logical, logical, double, ...> => class<`CVar`, `nnetar`>;
type `datamat` <..., logical, logical> => class<`data.frame`>;
type `dm.test` <class<`ts`>, class<`ts`>, character[], double, double> => class<`htest`>;
type `easter` <class<`ts`>, logical> => class<`ts`>;
type `ets` <class<`ts`> | double[], character | class<`ets`>, logical | null, null, null, null, null, logical, null, any, double[], double[], character[], double, character[], character[], logical, logical, logical, character[]> => class<`ets`>;
type `etsmodel` <class<`ts`>, character, character, character, logical, null | double, null | double, null, null | double, double[], double[], character, double, character, double, null, null, logical> => list<any>;
type `etsTargetFunctionInit` <double[], class<`ts`>, integer, character, character, character, logical, null | double[], double[], double[], character, integer, character, any, character[], null | character[]> => environment;
type `findfrequency` <class<`msts`, `ts`> | class<`ts`>> => integer;
type `fitted.ar` <class<`ar`>, ...> => class<`ts`>;
type `fitted.Arima` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, double, ...> => class<`ts`>;
type `fitted.ets` <class<`ets`>, double, ...> => class<`ts`>;
type `fitted.forecast_ARIMA` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, double, ...> => class<`ts`>;
type `fitted.lagwalk` <class<`lagwalk`>, ...> => class<`ts`>;
type `fitted.nnetar` <class<`nnetar`>, double, ...> => class<`ts`>;
type `fitted.tslm` <class<`lm`, `tslm`>, ...> => class<`ts`>;
type `forecast` <class<`ar`> | class<`ARFIMA`, `fracdiff`> | class<`ARIMA`, `Arima`, `forecast_ARIMA`> | class<`baggedModel`> | class<`ets`> | class<`HoltWinters`> | class<`lagwalk`> | class<`lm`, `tslm`> | class<`mstl`, `mts`, `ts`> | class<`nnetar`> | class<`stl`> | class<`stlm`> | class<`StructTS`> | class<`ts`> | class<`lm`, `mlm`> | class<`lm`, `mlm`, `tslm`>, ...> => (class<`forecast`> | class<`mforecast`>);
type `forecast2plotdf` <class<`forecast`> | class<`forecast`, `splineforecast`>, class<`data.frame`>, logical, logical, ...> => class<`data.frame`>;
type `forecast.ar` <class<`ar`>, double, double[], logical, double | null, logical, double, logical, ...> => class<`forecast`>;
type `forecast.baggedModel` <class<`baggedModel`>, double, ...> => class<`forecast`>;
type `forecast.ets` <class<`ets`>, double, any, any, logical, logical, double, logical, null, null, ...> => class<`forecast`>;
type `forecast.forecast_ARIMA` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, any, double[], logical, class<`matrix`> | null, null | double, logical, double, null, ...> => class<`forecast`>;
type `forecast.fracdiff` <class<`ARFIMA`, `fracdiff`>, double, double[], logical, null, null, ...> => class<`forecast`>;
type `forecast.HoltWinters` <class<`HoltWinters`>, double, double[], logical, null, null, ...> => class<`forecast`>;
type `forecast.lagwalk` <class<`lagwalk`>, double, double[], logical, null, logical, double, any, ...> => class<`forecast`>;
type `forecast.lm` <class<`lm`> | class<`lm`, `tslm`>, any, double, double[], logical, null, null, logical, ...> => class<`forecast`>;
type `forecast.mlm` <class<`lm`, `mlm`> | class<`lm`, `mlm`, `tslm`>, any, double, any, logical, any, null, logical, ...> => class<`mforecast`>;
type `forecast.mstl` <class<`mstl`, `mts`, `ts`>, character[], character, null, double, double[], logical, double, logical, null, null, logical, ...> => class<`forecast`>;
type `forecast.nnetar` <class<`nnetar`>, double, logical, double[], logical, null, null, logical, double, null, ...> => class<`forecast`>;
type `forecast.stl` <class<`mstl`, `mts`, `ts`> | class<`stl`>, character[], character, null, double, double[], logical, double | null, logical | null, null, null, logical, ...> => class<`forecast`>;
type `forecast.stlm` <class<`stlm`>, double, double[], logical, null, null, null, logical, ...> => class<`forecast`>;
type `forecast.StructTS` <class<`StructTS`>, double, double[], logical, null, null, ...> => class<`forecast`>;
type `forecast.ts` <class<`ts`>, double, double[], logical, logical, null, logical, logical, logical, class<`ets`> | null, ...> => class<`forecast`>;
type `fourier` <class<`msts`, `ts`> | class<`ts`>, double[], double | null> => class<`matrix`>;
type `...fourier` <class<`msts`, `ts`> | class<`ts`>, double[], integer[]> => class<`matrix`>;
type `FUN` <double[] | class<`ts`>> => logical;
type `geom_forecast` <class<`uneval`>, class<`data.frame`>, character, character, logical, null, logical, logical, logical, null, ...> => class<`Layer`, `LayerInstance`, `gg`, `ggproto`>;
type `getResponse` <class<`lm`> | class<`mforecast`> | class<`lm`, `tslm`> | class<`ar`> | class<`ARFIMA`, `fracdiff`> | class<`ARIMA`, `Arima`, `forecast_ARIMA`> | class<`ets`> | class<`forecast`> | class<`forecast`, `splineforecast`> | class<`nnetar`> | class<`ts`>, ...> => (class<`matrix`, `mts`, `ts`> | class<`ts`> | double[] | null);
type `getResponse.ar` <class<`ar`>, ...> => class<`ts`>;
type `getResponse.Arima` <class<`ar`> | class<`ARIMA`, `Arima`, `forecast_ARIMA`>, ...> => class<`ts`>;
type `getResponse.default` <class<`ets`> | class<`forecast`> | class<`forecast`, `splineforecast`> | class<`nnetar`> | class<`ts`>, ...> => (class<`ts`> | double[] | null);
type `getResponse.fracdiff` <class<`ARFIMA`, `fracdiff`>, ...> => class<`ts`>;
type `getResponse.lm` <class<`lm`> | class<`lm`, `tslm`>, ...> => (class<`matrix`, `mts`, `ts`> | class<`ts`> | double[]);
type `getResponse.mforecast` <class<`mforecast`>, ...> => class<`matrix`, `mts`, `ts`>;
type `getxreg` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>> => class<`matrix`>;
type `ggAcf` <class<`ts`>, null, any, logical, any, logical, ...> => class<`gg`, `ggplot`>;
type `ggAddExtras` <character | null, character[] | null, null | character> => list<class<`labels`>>;
type `ggCcf` <any, any, null, any, logical, any, ...> => class<`gg`, `ggplot`>;
type `gghistogram` <class<`ts`>, logical, logical, logical, any, double> => class<`gg`, `ggplot`>;
type `gglagchull` <class<`matrix`, `mts`, `ts`> | class<`ts`>, double, integer[], logical, character, ...> => class<`gg`, `ggplot`>;
type `gglagplot` <class<`matrix`, `mts`, `ts`> | class<`ts`>, double, integer[], logical, character, logical, logical, any, logical, logical, ...> => class<`gg`, `ggplot`>;
type `ggseasonplot` <class<`ts`>, null, logical, logical, null, character[] | null, logical, logical, double, ...> => class<`gg`, `ggplot`>;
type `ggsubseriesplot` <class<`ts`>, null, any, class<`ts`>, ...> => class<`gg`, `ggplot`>;
type `ggtsdisplay` <class<`ts`>, character, logical, logical, any, class<`function`>, class<`gg`, `theme`> | null, ...> => class<`gg`, `ggplot`>;
type `guerrero` <class<`ts`>, double, double, double> => double;
type `head.ts` <class<`ts`>, double, ...> => class<`ts`>;
type `hfitted` <class<`ets`>, double, character, ...> => class<`ts`>;
type `holt` <class<`ts`>, double, logical, double[], logical, character[], logical, null, null, null, null, logical, class<`ts`>, ...> => class<`forecast`>;
type `HoltWintersZZ` <double[], double, logical, logical, character[], logical, null, null, any, logical> => class<`ets`>;
type `hw` <class<`ts`>, double, character[], logical, double[], logical, character[], logical, null, null, null, null, null, logical, class<`ts`>, ...> => class<`forecast`>;
type `initparam` <double | null, any, any, any, character, character, logical, double[], double[], any> => double[];
type `initstate` <class<`ts`>, character, character> => double[];
type `InvBoxCox` <class<`array`> | class<`matrix`> | class<`matrix`, `mts`, `ts`> | class<`ts`>, double, logical | null, any> => (class<`array`> | class<`matrix`> | class<`matrix`, `mts`, `ts`> | class<`ts`>);
type `is.Arima` <class<`ar`> | class<`ARIMA`, `Arima`, `forecast_ARIMA`>> => logical;
type `is.constant` <double[] | class<`ts`>> => logical;
type `is.ets` <class<`ets`>> => logical;
type `is.forecast` <class<`forecast`> | class<`uneval`>> => logical;
type `is.mforecast` <class<`mforecast`> | class<`uneval`>> => logical;
type `is.nnetar` <class<`nnetar`>> => logical;
type `lagwalk` <class<`ts`> | double[], double, logical, null, any> => class<`lagwalk`>;
type `ma` <class<`ts`>, double, logical> => class<`ts`>;
type `make.Sigma` <integer, double> => class<`matrix`>;
type `maroots` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>> => class<`armaroots`>;
type `MBB` <double[], double> => class<`array`>;
type `meanf` <class<`ts`> | double[], double, double[], logical, null, logical, logical, double, class<`ts`> | double[]> => class<`forecast`>;
type `mlmsplit` <class<`lm`, `mlm`> | class<`lm`, `mlm`, `tslm`>, integer> => class<`lm`>;
type `modeldf` <class<`ets`>, ...> => integer;
type `modeldf.ets` <class<`ets`>, ...> => integer;
type `monthdays` <class<`ts`>> => class<`ts`>;
type `mstl` <class<`msts`, `ts`> | class<`ts`>, null | character, double, double, ...> => (class<`mstl`, `msts`, `mts`, `ts`> | class<`mstl`, `mts`, `ts`>);
type `msts` <class<`msts`, `ts`> | class<`ts`>, double[], double, ...> => (class<`msts`, `ts`> | class<`ts`>);
type `[.msts` <class<`msts`, `ts`>, logical[], any, logical> => integer[];
type `myarima` <class<`ts`>, double[], double[], logical, character, logical, logical, any, class<`matrix`> | null, null, ...> => class<`ARIMA`, `Arima`, `forecast_ARIMA`>;
type `na.ends` <class<`ts`> | double[]> => (class<`ts`> | double[]);
type `na.interp` <class<`ts`>, any, any> => class<`ts`>;
type `naive` <class<`ts`>, double, double[], logical, null, logical, ..., class<`ts`>> => class<`forecast`>;
type `ndiffs` <class<`ts`>, double, character[], character[], double, ...> => double;
type `newmodel` <double, double, double, double, double, double, logical, class<`matrix`>> => logical;
type `nnetar` <class<`ts`>, any, double, any, double, null, null, null | class<`nnetar`>, null, logical, class<`ts`>, ...> => class<`nnetar`>;
type `nsdiffs` <class<`ts`>, double, any, character[], double, ...> => double;
type `ocsb.test` <class<`ts`>, character[], double> => class<`OCSBtest`>;
type `oldmodel_avnnet` <class<`matrix`>, double[], double, class<`nnetar`>> => class<`nnetarmodels`>;
type `overwrite_s3_generic` <character, character> => (class<`function`> | null);
type `Pacf` <class<`ts`>, null, logical, class<`function`>, logical, ...> => class<`acf`>;
type `pegelsresid.C` <class<`ts`>, double, double[], character, character, character, logical, double, any, any, any, double> => list<double[] | class<`ts`> | class<`matrix`>>;
type `plot.ar` <class<`ar`>, any, character, character, ...> => null;
type `plot.Arima` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, character[], any, character, character, ...> => null;
type `plot.armaroots` <class<`armaroots`>, character, character, any, ...> => null;
type `plot.ets` <class<`ets`>, ...> => null;
type `plot.forecast` <class<`forecast`, `splineforecast`> | class<`forecast`>, any, logical, logical, logical, any, null, double, double, double, double, null, null | character, character, character, character, double, double, ...> => list<any>;
type `plotlmforecast` <class<`forecast`>, logical, logical, null, double, double, any, any, null, null, character, character, character, ...> => null;
type `plot.mforecast` <class<`mforecast`>, character, character, ...> => null;
type `plot.splineforecast` <class<`forecast`, `splineforecast`>, double, character, double, ...> => null;
type `print.CVar` <class<`CVar`, `nnetar`>, ...> => class<`CVar`, `nnetar`>;
type `print.forecast` <class<`forecast`> | class<`forecast`, `splineforecast`>, ...> => class<`data.frame`>;
type `print.forecast_ARIMA` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, double, logical, ...> => class<`ARIMA`, `Arima`, `forecast_ARIMA`>;
type `print.nnetar` <class<`nnetar`>, double, ...> => class<`nnetar`>;
type `print.nnetarmodels` <class<`nnetarmodels`>, ...> => class<`nnet`>;
type `register_s3_method` <character, character, character, null> => null;
type `remainder` <class<`mstl`, `mts`, `ts`> | class<`stl`>> => class<`ts`>;
type `residuals.ar` <class<`ar`>, character[], ...> => class<`ts`>;
type `residuals.Arima` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, character[], double, ...> => class<`ts`>;
type `residuals.ets` <class<`ets`>, character[], double, ...> => class<`ts`>;
type `residuals.forecast` <class<`forecast`>, character[], ...> => class<`ts`>;
type `residuals.forecast_ARIMA` <class<`ARIMA`, `Arima`, `forecast_ARIMA`>, character[], double, ...> => class<`ts`>;
type `residuals.nnetar` <class<`nnetar`>, character[], double, ...> => class<`matrix`, `mts`, `ts`>;
type `residuals.tslm` <class<`lm`, `tslm`>, character[], ...> => class<`ts`>;
type `rwf` <class<`ts`> | double[], double, logical, double[], logical, null, any, ..., class<`ts`> | double[]> => class<`forecast`>;
type `scale.ts` <class<`ts`>, double, double> => class<`ts`>;
type `seasadj` <class<`decomposed.ts`> | class<`mstl`, `mts`, `ts`> | class<`stl`>, ...> => class<`ts`>;
type `seasadj.decomposed.ts` <class<`decomposed.ts`>, ...> => class<`ts`>;
type `seasadj.mstl` <class<`mstl`, `mts`, `ts`> | class<`stl`>, ...> => class<`ts`>;
type `seasadj.stl` <class<`mstl`, `mts`, `ts`> | class<`stl`>, ...> => class<`ts`>;
type `seas.heuristic` <class<`ts`>> => double;
type `seasonal` <class<`stl`>> => class<`ts`>;
type `seasonalaxis` <double, double, character, logical> => double[];
type `seasonaldummy` <class<`ts`>, double | null> => class<`matrix`>;
type `seasonplot` <class<`ts`>, any, null, logical, logical, character, any, null, character, character[] | double, double, ...> => double[];
type `ses` <class<`ts`> | double[], double, any, logical, character[], null | double, null, logical, class<`ts`> | double[], ...> => class<`forecast`>;
type `simulate.ets` <class<`ets`>, double, null, logical, logical, null, ...> => class<`ts`>;
type `sindexf` <class<`stl`>, double> => class<`ts`>;
type `snaive` <class<`ts`>, double, double[], logical, null, logical, ..., class<`ts`>> => class<`forecast`>;
type `splinef` <class<`ts`>, double, double[], logical, null, logical, character[], class<`ts`>> => class<`forecast`, `splineforecast`>;
type `spline.matrices` <integer, double, double, double> => list<class<`matrix`>>;
type `stlf` <class<`ts`>, double, double, null, logical, double, logical, class<`ts`>, ...> => class<`forecast`>;
type `stlm` <class<`ts`>, double, logical, character[], class<`function`>, null, character, null, logical, null, logical, class<`ts`>, ...> => class<`stlm`>;
type `subset.ts` <class<`ts`>, null, character | null, null | double, null, null | double, null, ...> => class<`ts`>;
type `summary.forecast` <class<`forecast`> | class<`forecast`, `splineforecast`>, ...> => class<`data.frame`>;
type `tail.ts` <class<`ts`>, double, ...> => class<`ts`>;
type `testaccuracy` <class<`ts`> | class<`forecast`>, class<`ts`> | double[], integer[] | null, any, any> => double[];
type `thetaf` <class<`ts`>, double, double[], logical, class<`ts`>> => class<`forecast`>;
type `trainingaccuracy` <class<`ARIMA`, `Arima`, `forecast_ARIMA`> | class<`ets`> | class<`forecast`> | class<`forecast`, `splineforecast`>, null, any, any> => double[];
type `trendcycle` <class<`mstl`, `mts`, `ts`> | class<`stl`>> => class<`ts`>;
type `tsclean` <class<`ts`>, logical, null> => class<`ts`>;
type `tsdisplay` <class<`ts`>, character[], logical, character[], any, class<`function`>, null, character, character, double, double, ...> => null;
type `tslm` <class<`formula`>, any, any, null, logical, ...> => (class<`lm`, `mlm`, `tslm`> | class<`lm`, `tslm`>);
type `tsoutliers` <class<`ts`>, double, null> => list<double[]>;
type `undo.na.ends` <class<`ts`> | double[], class<`ts`>> => class<`ts`>;
type `unfracdiff` <class<`ts`>, class<`ts`>, integer, double, double> => class<`ts`>;
type `window.msts` <class<`msts`, `ts`>, ...> => class<`msts`, `ts`>;
type `zzhw` <class<`ts`>, integer, double, any, any, character, double, logical, logical, double, logical, double, any, double> => list<double[]>;
