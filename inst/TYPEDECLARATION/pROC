type `are.paired` <...> => logical;
type `are.paired.roc` <class<`smooth.roc`> | class<`roc`>, class<`roc`>, logical, logical, logical, logical, ...> => logical;
type `are.paired.smooth.roc` <class<`smooth.roc`>, class<`roc`>, ...> => logical;
type `auc` <...> => class<`auc`, `numeric`>;
type `auc.default` <class<`factor`>, double[], ...> => class<`auc`, `numeric`>;
type `auc.multiclass.roc` <class<`multiclass.roc`>, ...> => class<`multiclass.auc`, `numeric`>;
type `auc.mv.multiclass.roc` <class<`mv.multiclass.roc`>, ...> => class<`mv.multiclass.auc`, `numeric`>;
type `auc.roc` <class<`roc`> | class<`smooth.roc`>, double[], any, logical, logical, ...> => class<`auc`, `numeric`>;
type `auc.smooth.roc` <class<`smooth.roc`>, ...> => class<`auc`, `numeric`>;
type `cdagger` <double, double, double> => double;
type `cddagger` <double> => double;
type `ci` <...> => class<`ci`, `ci.auc`, `numeric`>;
type `ci.auc` <...> => class<`ci`, `ci.auc`, `numeric`>;
type `ci.auc.auc` <class<`auc`, `numeric`>, ...> => class<`ci`, `ci.auc`, `numeric`>;
type `ci.auc.bootstrap` <class<`roc`>, double, double, logical, character, logical, ...> => double[];
type `ci.auc.delong` <class<`roc`>, double> => double[];
type `ci.auc.roc` <class<`roc`>, double, character[] | null, double, logical, logical, any, logical> => class<`ci`, `ci.auc`, `numeric`>;
type `ci.auc.smooth.roc` <class<`smooth.roc`>, double, double, logical, logical, character, logical, ...> => class<`ci`, `ci.auc`, `numeric`>;
type `ci.coords` <...> => class<`ci`, `ci.coords`, `list`>;
type `ci.coords.roc` <class<`roc`>, character | double[], character, character[], any, any, character[], double> => class<`ci`, `ci.coords`, `list`>;
type `ci.coords.smooth.roc` <class<`smooth.roc`>, double, character, character[], any, double[], character[], double> => class<`ci`, `ci.coords`, `list`>;
type `ci.roc` <class<`roc`>, character[], ...> => class<`ci`, `ci.auc`, `numeric`>;
type `ci.se` <...> => class<`ci`, `ci.se`, `matrix`>;
type `ci.se.roc` <class<`roc`>, double[], double, double, logical, character, logical, ...> => class<`ci`, `ci.se`, `matrix`>;
type `ci.se.smooth.roc` <class<`smooth.roc`>, double[], double, double, logical, character, logical, ...> => class<`ci`, `ci.se`, `matrix`>;
type `ci.sp` <...> => class<`ci`, `ci.sp`, `matrix`>;
type `ci.sp.roc` <class<`roc`>, double[], double, double, logical, character, logical, ...> => class<`ci`, `ci.sp`, `matrix`>;
type `ci.sp.smooth.roc` <class<`smooth.roc`>, double[], double, double, logical, character, logical, ...> => class<`ci`, `ci.sp`, `matrix`>;
type `ci.thresholds` <...> => class<`ci`, `ci.thresholds`, `list`>;
type `ci.thresholds.roc` <class<`roc`>, double, double, logical, character | double[], character, logical, ...> => class<`ci`, `ci.thresholds`, `list`>;
type `compute.pair.AUC` <class<`data.frame`> | class<`matrix`>, character, character, class<`factor`>, any, logical, character, ...> => class<`roc`>;
type `coords` <...> => (class<`data.frame`> | class<`matrix`>);
type `coords.roc` <class<`smooth.roc`> | class<`roc`>, character | double[], character[], character[], logical, logical, any, any> => (class<`data.frame`> | class<`matrix`> | double);
type `coords.smooth.roc` <class<`smooth.roc`>, double, character, character[], logical, logical, any, any> => (double | class<`data.frame`>);
type `cov` <...> => double;
type `cov.auc` <class<`auc`, `numeric`>, class<`roc`>, ...> => double;
type `cov.default` <...> => double;
type `cov.params.obuchowski` <double, double, double, double, double, double, double, any> => double;
type `cov.roc` <class<`roc`>, class<`roc`>, character[], logical, double, logical, logical, any> => double;
type `cov.roc.obuchowski` <class<`roc`>, class<`roc`>> => double;
type `covvar` <class<`roc`>, class<`roc`>, character[], ...> => list<double>;
type `delong.paired.test` <class<`roc`>, class<`roc`>> => double;
type `delongPlacements` <class<`roc`>> => list<double[]>;
type `delongPlacementsCpp` <class<`roc`>> => list<double[]>;
type `expr1` <double, double> => double;
type `expr2` <double> => double;
type `expr3` <double, double> => double;
type `expr4` <double, double> => double;
type `f.full` <double, double> => double;
type `f.partial` <double, double, double, double> => double;
type `get.aes.for.ggplot` <class<`roc`>, logical, character[] | null> => list<class<`uneval`> | class<`Scale`, `ScaleContinuous`, `ScaleContinuousPosition`, `gg`, `ggproto`>>;
type `get.coords.for.ggplot` <class<`roc`>> => class<`data.frame`>;
type `g.full` <double, double> => double;
type `ggroc` <class<`roc`> | list<class<`roc`>>, ...> => class<`gg`, `ggplot`>;
type `ggroc.list` <list<class<`roc`>>, any, logical, ...> => class<`gg`, `ggplot`>;
type `ggroc.roc` <class<`roc`>, logical, ...> => class<`gg`, `ggplot`>;
type `g.partial` <double, double, double, double> => double;
type `has.partial.auc` <class<`auc`, `numeric`> | class<`roc`> | class<`smooth.roc`>> => (logical | null);
type `has.partial.auc.auc` <class<`auc`, `numeric`> | null> => (logical | null);
type `has.partial.auc.roc` <class<`smooth.roc`> | class<`roc`>> => (logical | null);
type `has.partial.auc.smooth.roc` <class<`smooth.roc`>> => logical;
type `lines.roc` <class<`roc`>, ...> => class<`roc`>;
type `lines.roc.roc` <class<`roc`>, double, ...> => class<`roc`>;
type `load.ggplot2` < > => logical;
type `load.suggested.package` <character> => logical;
type `Math.auc` <class<`auc`, `numeric`>, ...> => double;
type `Math.ci.auc` <class<`ci`, `ci.auc`, `numeric`>, ...> => double[];
type `multiclass.roc` <...> => (class<`multiclass.roc`> | class<`mv.multiclass.roc`>);
type `multiclass.roc.default` <class<`factor`> | class<`factor`, `ordered`>, class<`data.frame`> | double[] | class<`matrix`>, character[] | double[], logical, any, ...> => (class<`mv.multiclass.roc`> | class<`multiclass.roc`>);
type `multiclass.roc.formula` <class<`formula`>, class<`data.frame`>, ...> => class<`mv.multiclass.roc`>;
type `multiclass.roc.multivariate` <class<`factor`>, class<`matrix`> | class<`data.frame`>, character[], logical, character, ...> => class<`mv.multiclass.roc`>;
type `multiclass.roc.univariate` <class<`factor`, `ordered`>, double[], character[] | double[], logical, character, ...> => class<`multiclass.roc`>;
type `ncases.obuchowski` <class<`roc`>, class<`roc`>, double, double, character[], ...> => double;
type `ncases.obuchowski.params` <list<double>, double, double, double> => double;
type `Ops.auc` <class<`auc`, `numeric`> | double, double | class<`auc`, `numeric`>> => double;
type `Ops.ci.auc` <class<`ci`, `ci.auc`, `numeric`>, double> => double[];
type `plot.ci.se` <class<`ci`, `ci.se`, `matrix`>, character[], double, character, logical, ...> => class<`ci`, `ci.se`, `matrix`>;
type `plot.ci.sp` <class<`ci`, `ci.sp`, `matrix`>, character[], double, character, logical, ...> => class<`ci`, `ci.sp`, `matrix`>;
type `plot.ci.thresholds` <class<`ci`, `ci.thresholds`, `list`>, double, character, ...> => class<`ci`, `ci.thresholds`, `list`>;
type `plot.roc` <class<`factor`> | class<`roc`>, ...> => class<`roc`>;
type `plot.roc.default` <class<`factor`>, double[], ...> => class<`roc`>;
type `plot.roc.roc` <class<`roc`>, logical, logical, logical, logical, any, any, any> => class<`roc`>;
type `plot.smooth.roc` <class<`smooth.roc`>, ...> => class<`smooth.roc`>;
type `power.roc.test` <...> => class<`power.htest`>;
type `power.roc.test.list` <list<double>, null, double | null, double | null, null | double, double, character[], ...> => class<`power.htest`>;
type `power.roc.test.numeric` <class<`auc`, `numeric`> | double | null, null | double, null | double, double | null, null | double, double, character[], ...> => class<`power.htest`>;
type `power.roc.test.roc` <class<`roc`>, any, double | null, double | null, character[], logical, any, ...> => class<`power.htest`>;
type `print.auc` <class<`auc`, `numeric`>, double, ...> => class<`auc`, `numeric`>;
type `print.ci.auc` <class<`ci`, `ci.auc`, `numeric`>, double, ...> => class<`ci`, `ci.auc`, `numeric`>;
type `print.dataline` <class<`roc`>> => null;
type `print.roc` <class<`roc`>, double, logical, ...> => class<`roc`>;
type `print.smooth.roc` <class<`smooth.roc`>, double, logical, ...> => class<`smooth.roc`>;
type `remove.ci.attributes` <class<`ci`, `ci.auc`, `numeric`> | double> => double[];
type `roc` <...> => (class<`roc`> | class<`smooth.roc`> | list<class<`roc`>>);
type `roc.cc.nochecks` <double[], double[], logical, character, class<`function`>, logical, any, any> => (class<`roc`> | class<`smooth.roc`>);
type `roc.default` <any, any, any, any, any, any, any, logical> => (class<`roc`> | class<`smooth.roc`>);
type `roc.formula` <class<`formula`>, any, ...> => (class<`roc`> | list<class<`roc`>>);
type `roc.test` <...> => class<`htest`>;
type `roc.test.auc` <class<`auc`, `numeric`>, class<`roc`>, ...> => class<`htest`>;
type `roc.test.default` <class<`factor`>, class<`data.frame`> | double[], null | class<`factor`, `ordered`>, logical, null, ...> => class<`htest`>;
type `roc.test.roc` <class<`roc`>, class<`roc`>, character[] | null, null, null, character[], null, logical> => class<`htest`>;
type `roc.utils.calc.coords` <double, ^double[] | null, double[], double[], integer, integer, double[]> => class<`matrix`>;
type `roc.utils.extract.formula` <class<`formula`>, any, logical, class<`call`>, ...> => (list<class<`factor`> | character[] | class<`data.frame`>> | list<character | class<`factor`> | class<`data.frame`>>);
type `roc.utils.get.progress.bar` <character, character, character, any, any, any, ...> => list<class<`function`>>;
type `roc.utils.is.perfect.curve` <class<`roc`> | class<`smooth.roc`>> => logical;
type `roc.utils.match.coords.ret.args` <character[], logical> => character[];
type `roc.utils.max.partial.auc` <double[], any> => double;
type `roc.utils.max.thresholds.idx` <double[], double[], double[]> => logical[];
type `roc.utils.min.partial.auc` <double[], logical> => double;
type `roc.utils.optim.crit` <double[], double[], any, double[], character> => double[];
type `roc.utils.thresholds` <double[], any> => double[];
type `roc.utils.thr.idx` <class<`roc`>, double> => double;
type `roc.utils.unpercent` <class<`auc`, `numeric`> | class<`roc`>> => (class<`auc`, `numeric`> | class<`roc`>);
type `roc.utils.unpercent.auc` <class<`auc`, `numeric`>> => class<`auc`, `numeric`>;
type `roc.utils.unpercent.roc` <class<`roc`>> => class<`roc`>;
type `smooth` <...> => class<`smooth.roc`>;
type `smooth.roc` <class<`roc`>, character[], double, character, null | character | class<`function`>, null | character | class<`function`> | double[], null | character | class<`function`> | double[], null | list<double>> => class<`smooth.roc`>;
type `smooth.roc.binormal` <class<`roc`>, double> => list<double[] | class<`lm`>>;
type `smooth.roc.density` <class<`roc`>, any, double[] | class<`function`> | null, double[] | class<`function`> | null, any, double, double, any> => list<double[]>;
type `smooth.roc.fitdistr` <class<`roc`>, any, character | class<`function`>, character | class<`function`>, null | list<double>, null | list<double>, ...> => list<double[] | class<`fitdistr`>>;
type `smooth.roc.logcondens` <class<`roc`>, double> => list<double[] | list<double[] | class<`dlc`>>>;
type `smooth.roc.logcondens.smooth` <class<`roc`>, double> => list<double[] | list<double[] | class<`dlc`>>>;
type `solve.nd` <double, double, double, double, double> => double;
type `solve.zalpha` <double, double, double, double, double> => double;
type `solve.zbeta` <double, double, double, double, double> => double;
type `sort.roc` <class<`roc`>> => class<`roc`>;
type `sort.smooth.roc` <class<`smooth.roc`>> => class<`smooth.roc`>;
type `stratified.ci.coords` <class<`roc`>, character | double[], character, character[], any, any, any> => class<`matrix`>;
type `stratified.ci.smooth.coords` <class<`roc`>, double, character, character[], any, double[], class<`call`>, any> => class<`matrix`>;
type `var` <...> => double;
type `var0.delta.covvar` <list<double>> => double;
type `var.auc` <class<`auc`, `numeric`>, ...> => double;
type `var.default` <...> => double;
type `var.delta.covvar` <list<double>> => double;
type `var.params.obuchowski` <double, double, double, any, any> => double;
type `var.roc` <class<`roc`>, character[], double, logical, logical, any, logical, ...> => double;
type `var.roc.obuchowski` <class<`roc`>> => double;
type `var.theta.obuchowski` <double, double> => double;
type `zalpha.obuchowski` <class<`roc`>, class<`roc`>, double, character[], ...> => double;
type `zalpha.obuchowski.params` <list<double>, double, double, double> => double;
type `zbeta.obuchowski` <class<`roc`>, class<`roc`>, double, character[], ...> => double;
type `zbeta.obuchowski.params` <list<double>, double, double, double> => double;
