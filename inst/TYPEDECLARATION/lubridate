type `-` <? double[], ??? | double[]> => ? double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>;
type `!=.POSIXt` <struct<`sec`:double, `min`:double, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double, `min`:integer, `hour`:double, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>, double> => logical;
type `.add_truncated` <character, double> => character[];
type `.best_formats` <character[], character[], character, any => any | symbol, logical | symbol> => ? character[];
type `.build_formats` <symbol, character[], character[]> => ? character[];
type `.difftime_from_num` <double[], character> => double[];
type `.difftime_from_pieces` <struct<`day`:double> | struct<`days`:double> | struct<`minute`:double> | struct<`second`:double>> => double;
type `.duration_from_num` <double, character> => double;
type `.duration_from_units` <struct<`day`:double> | struct<`days`:double> | struct<`hours`:double> | struct<`mins`:double> | struct<`minute`:double> | struct<`second`:double>> => double;
type `.enclose` <character> => character;
type `.enclosed.na` <character[]> => logical[];
type `.get_locale_regs` <character> => struct<`alpha_flex`:character[], `num_flex`:character[], `alpha_exact`:character[], `num_exact`:character[], `wday_names`:struct<`abr`:character[], `full`:character[]>, `month_names`:struct<`abr`:character[], `full`:character[]>>;
type `.get_train_set` <character[]> => character[];
type `.int_to_period` <double> => double;
type `.local` <character | double[], ? character | double, ???> => double[];
type `.local_parse` <character[], logical> => ? ^double[];
type `.mklt` <struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer>, character> => struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:null, `yday`:null, `isdst`:integer>;
type `.num_to_date` <? character[]> => ? character[];
type `.number_to_interval` <double, double, ???> => double;
type `.parse_date_time` <character[], character[], character, symbol, symbol> => ? ^double[];
type `.parse_hms` <character[], character, logical> => ^double[];
type `.parse_iso_dt` <character[], character> => double[];
type `.parse_xxx` <character[] | double, character, symbol, ? character, character, double> => double[];
type `.parse_xxx_hms` <? character[], character[] | language, double, symbol | logical, character, character> => ? double[];
type `.period_from_num` <double[], character[]> => double;
type `.period_from_units` <struct<`day`:double[]> | struct<`month`:integer[]> | struct<`hours`:double, `minutes`:double> | struct<`month`:double> | struct<`second`:double> | struct<`year`:double> | struct<`hour`:double[]> | struct<`minute`:double[]> | struct<`months`:double[]> | struct<`week`:double>> => double[];
type `.quick_month_add` <double, double[]> => double[];
type `.rep_maybe` <double[], double> => double[];
type `.select_formats` <integer[], logical> => character[];
type `.shift_wday_names` <character[], integer> => character[];
type `.strptime` <character[], character, character, logical | symbol, symbol | character> => ? ^double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>;
type `.substitute_formats` <character, character[], logical> => ? character[];
type `.train_formats` <character[], character[], symbol | character> => integer[];
type `.units_within_seconds` <double, character> => struct<``:double, `minute`:double>;
type `.with_tz` <? double[], character> => ? double[];
type `[` <double, logical, ???, ???, logical> => double[];
type `[<-` <double, logical, ???, ???, double[]> => double;
type `*` <integer[] | double, double> => double[];
type `%m-%` <double, double> => double;
type `%m+%` <double, double[]> => double[];
type `+` <? struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | double[], double[]> => ? struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | ^double[];
type `<.POSIXt` <double[], double> => logical[];
type `<=.POSIXt` <double[], double> => logical[];
type `==.POSIXt` <double, double> => logical;
type `>` <double, double | character> => logical;
type `>.POSIXt` <double, double> => logical;
type `>=.POSIXt` <double[], double> => logical[];
type `$<-` <double, character, double> => double;
type `add_duration_to_date` <double, ? double> => ? double;
type `add_duration_to_duration` <double, double> => double;
type `add_months` <struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]>, double[]> => struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>;
type `add_period_to_date` <double[], double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>> => ^double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>;
type `add_period_to_period` <double, double> => double;
type `add_with_rollback` <double, double[], logical, logical> => double[];
type `am` <double> => logical;
type `as_date` <double[], ???> => double[];
type `as_datetime` <double[], character> => double[];
type `as_POSIXct` <double[], symbol> => double[];
type `as.double` <???, ???> => double[];
type `as.duration` <double[] | character, ???> => double[];
type `as.interval` <double, double, ???> => double;
type `as.numeric` <???, ???> => double;
type `as.period` <character | double, ??? | character, ???> => double;
type `c` <???, ???> => double[];
type `C_force_tz` <double[], character, logical> => ? double[];
type `C_force_tzs` <double[], character[], character, logical> => double[];
type `C_local_time` <double[], character[]> => double[];
type `C_update_dt` <double, double[], double | integer[], integer[], double | integer[], integer[], double[], double[], double[], character, logical, integer> => double[];
type `C_valid_tz` <character> => logical;
type `ceil_multi_unit` <double, double> => double;
type `ceil_multi_unit1` <double, double> => double;
type `ceiling_date` <double, character, ? logical, language | double> => double;
type `date_to_posix` <double, character> => double;
type `date.default` <double> => double;
type `date<-` <double, double> => double;
type `day<-` <double[], double> => double[];
type `days` <double[]> => double[];
type `ddays` <double> => double;
type `decimal_date.default` <double[]> => double[];
type `dhours` <double> => double;
type `dminutes` <double> => double;
type `dseconds` <double> => double;
type `dst.default` <double> => logical;
type `duration` <? character | double, character, ??? | double> => double;
type `dweeks` <double> => double;
type `f` <double, double, ???> => double;
type `fast_strptime` <character[], character, character, logical, integer> => ? ^double[];
type `filter` <character[]> => logical[];
type `floor_date` <double[], character, double | language> => double[];
type `floor_multi_unit` <double | integer[], double> => double[];
type `floor_multi_unit1` <double[], double> => double[];
type `force_tz` <double[], character, logical> => ? double[];
type `force_tzs` <double[], character[], character, logical> => double[];
type `fun` <symbol, symbol> => null;
type `FUN` <? character[] | ^double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>, character[] | ???, logical | ???> => ? character[] | ^double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>;
type `guess_formats` <character[], character[], character, logical, logical> => ? character[];
type `hm` <character[], logical, logical> => double[];
type `hms` <character[], logical, logical> => double[];
type `hour.default` <struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | double | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>> => integer[];
type `hour<-` <double | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>, double> => double | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>;
type `hours` <double[]> => double[];
type `initialize` <double[], double[]> => double[];
type `int_aligns` <double, double> => logical;
type `int_diff` <double[]> => double[];
type `int_end` <double> => double;
type `int_end<-` <double, double> => double;
type `int_flip` <double[]> => double[];
type `int_length` <double> => double;
type `int_overlaps` <double, double> => logical;
type `int_shift` <double, double> => double;
type `int_standardize` <double> => double;
type `int_start` <double> => double;
type `int_start<-` <double, double> => double;
type `interval` <double[], double[], character> => double[];
type `is.Date` <? double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<>> => logical;
type `is.difftime` <double> => logical;
type `is.duration` <double> => logical;
type `is.instant` <double> => logical;
type `is.interval` <double[]> => logical;
type `is.period` <double> => logical;
type `is.POSIXct` <double[] | struct<>> => logical;
type `is.POSIXlt` <? double[]> => logical;
type `is.POSIXt` <character | double[] | struct<>> => logical;
type `is.timepoint` <double> => logical;
type `is.timespan` <double> => logical;
type `leap_year` <double> => logical;
type `local_time` <double[], ? character[], character> => double[];
type `make_date` <double[] | character, character[] | double[], double | integer[]> => double[];
type `make_datetime` <double[], double | integer[], double | integer[], double[], double[], double[], character> => double[];
type `make_difftime` <? double, character, double | ???> => double[];
type `mday.default` <double[] | struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>> => integer[];
type `minute.default` <struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | double | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>> => integer[];
type `minute<-` <struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | double, double> => struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | double;
type `minutes` <double[]> => double[];
type `month.default` <double[], logical, logical, language | character> => double[];
type `month.numeric` <double[], logical, logical, character> => integer[];
type `month.Period` <double[], logical, logical, language> => double[];
type `month<-` <double, double> => double;
type `months.numeric` <integer[] | double, ???> => double[];
type `ms` <character[], logical, logical> => double[];
type `multiply_duration_by_number` <double, integer[] | double> => double[];
type `multiply_period_by_number` <double[], double | integer[]> => double[];
type `now` <character> => double;
type `parse_date_time` <? character[], character[] | language | symbol, character, double, logical | symbol, character, symbol | any => any, logical, logical, logical> => ? ^double[];
type `parse_date_time2` <character, character, character, logical, logical, integer> => double | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:null, `yday`:null, `isdst`:integer>;
type `parse_dt` <character[], character, logical, logical, integer> => ? ^double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer>;
type `parse_interval` <character, character> => double;
type `parse_period` <character[]> => double[];
type `parse_period_unit` <character> => struct<`n`:double, `unit`:character>;
type `period` <? double[] | character, character[], double[] | ???> => double[];
type `period_to_seconds` <double> => double;
type `pm` <double> => logical;
type `pretty_dates` <double[], double, ???> => double[];
type `pretty_point` <double, character, double, logical, ???> => double;
type `quarter` <double[], logical, double> => double[];
type `reclass_date_maybe` <double | struct<`sec`:double, `min`:integer, `hour`:double, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:double, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double[], `min`:double[], `hour`:integer[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double[], `min`:integer[], `hour`:double[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[], `zone`:character[], `gmtoff`:integer[]>, double[], character | symbol> => double[];
type `reclass_date.Date` <struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | double, double[]> => double[];
type `reclass_date.POSIXct` <? struct<`sec`:^double[], `min`:^integer[], `hour`:^integer[], `mday`:^integer[], `mon`:^integer[], `year`:^integer[], `wday`:^integer[], `yday`:^integer[], `isdst`:integer[]> | double[] | struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double, `min`:integer, `hour`:double, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:double, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double[], `min`:double[], `hour`:integer[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double[], `min`:integer[], `hour`:double[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[], `zone`:character[], `gmtoff`:integer[]>, ? double[]> => ? ^double[];
type `reclass_date.POSIXlt` <^double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>, struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>> => struct<`sec`:^double[], `min`:^integer[], `hour`:^integer[], `mday`:^integer[], `mon`:^integer[], `year`:^integer[], `wday`:^integer[], `yday`:^integer[], `isdst`:integer[]>;
type `rollback` <double[], logical, logical> => double[];
type `round_date` <double[], character, language> => double[];
type `second.default` <struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | double | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer>> => double[];
type `second<-` <struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | double, double> => struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | double;
type `seconds` <double> => double;
type `seconds_to_unit` <double[], character> => double[];
type `semester` <double[], logical> => double[];
type `standardise_date_names` <character[]> => character[];
type `standardise_difftime_names` <character[]> => character[];
type `standardise_period_names` <character> => character;
type `trunc_multi_unit` <double[], character, double> => struct<`sec`:double, `min`:integer, `hour`:double, `mday`:integer, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:double, `mon`:integer, `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | struct<`sec`:double[], `min`:double[], `hour`:integer[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double[], `min`:integer[], `hour`:double[], `mday`:integer[], `mon`:integer[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[], `zone`:character[], `gmtoff`:integer[]>;
type `trunc_one` <character> => character[];
type `tz.default` <double[] | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer, `zone`:character, `gmtoff`:integer>> => character;
type `update.Date` <double[], double[]> => double[];
type `update.POSIXt` <struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:double, `min`:integer, `hour`:integer, `mday`:integer, `mon`:^double[], `year`:integer, `wday`:integer, `yday`:integer, `isdst`:integer> | double[], double[], logical, double, ? logical> => struct<`sec`:double[], `min`:integer[], `hour`:integer[], `mday`:integer[], `mon`:double[], `year`:integer[], `wday`:integer[], `yday`:integer[], `isdst`:integer[]> | struct<`sec`:^double[], `min`:^integer[], `hour`:^integer[], `mday`:^integer[], `mon`:^integer[], `year`:^integer[], `wday`:^integer[], `yday`:^integer[], `isdst`:integer[]> | double[];
type `validityMethod` <double[]> => logical;
type `wday.default` <double[], logical, logical, double, language | character> => double[];
type `wday.numeric` <double[], logical, logical, double, character> => integer[];
type `with_tz` <double[], character> => double[];
type `yday.default` <double> => double;
type `yday<-` <double, double> => double;
type `year.default` <double[]> => double[];
type `year.Period` <double[]> => double[];
type `years` <double> => double;
type `ymd` <character[] | double, logical, ? character, character, double> => double[];
type `ymd_hms` <character[], logical, character, character, double> => ? double[];
type `::` <? character | double[], logical | character, character | language, character, double> => ? double[];
type `.deprecated` <character, character, character> => null;
type `.deprecated_fun` <character, character, double> => null;
type `<.Date` <double[], double> => logical[];
type `<=.Date` <double[], double> => logical[];
type `$` <double, character> => double;
type `c.POSIXct` <double[], logical> => double[];
type `seconds_to_period` <double> => double;
type `weeks` <double> => double;
type `ymd_h` <character, logical, character, character, double> => double;
