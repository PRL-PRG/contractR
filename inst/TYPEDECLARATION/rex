type `%==%` <logical, logical> => logical;
type `add_options` <character | class<`regex`>, null | character> => (character | class<`regex`>);
type `add_type` <class<`regex`>, character[]> => class<`regex`>;
type `as.character.regex` <class<`regex`>, ...> => class<`regex`>;
type `auto_name` <character[]> => character[];
type `capture` <..., character | null> => class<`regex`>;
type `capture_group` <character | double> => class<`regex`>;
type `character_class` <character | class<`regex`>> => class<`character_class`, `regex`>;
type `character_class_escape` <character | class<`regex`> | list<character | class<`regex`>>> => (class<`regex`> | list<class<`regex`>>);
type `character_class_escape.character` <character> => class<`regex`>;
type `character_class_escape_dots` <...> => character[];
type `character_class_escape.list` <list<character | class<`regex`>>> => list<class<`regex`>>;
type `character_class_escape.regex` <class<`regex`>> => class<`regex`>;
type `escape` <character | class<`character_class`, `regex`> | class<`regex`> | list<any>> => (class<`regex`> | list<class<`regex`>>);
type `escape.character` <character> => class<`regex`>;
type `escape.character_class` <class<`character_class`, `regex`>> => class<`regex`>;
type `escape_dots` <...> => character[];
type `escape.list` <list<any>> => list<class<`regex`>>;
type `escape.regex` <class<`regex`>> => class<`regex`>;
type `except` <...> => class<`regex`>;
type `filter` <character[]> => logical[];
type `fun` <any, any> => environment | <any, any> => null;
type `FUN` <character | class<`regex`> | list<character | class<`regex`>>> => (class<`regex`> | list<class<`regex`>>) | <character | class<`character_class`, `regex`> | class<`regex`> | list<any>> => (class<`regex`> | list<class<`regex`>>);
type `group` <...> => class<`regex`>;
type `%if_next_is%` <character | class<`character_class`, `regex`>, character | class<`character_class`, `regex`>> => class<`regex`>;
type `%if_next_isnt%` <class<`character_class`, `regex`>, class<`character_class`, `regex`>> => class<`regex`>;
type `%if_prev_is%` <character, character> => class<`regex`>;
type `match_args` <character, character[]> => character;
type `no_capture` <integer[]> => logical;
type `none_of` <...> => class<`regex`>;
type `one_of` <...> => class<`regex`>;
type `or` <...> => class<`regex`>;
type `p` <...> => class<`regex`>;
type `process_matches` <integer[], any> => (class<`data.frame`> | logical[]);
type `range` <character, character> => class<`character_class`, `regex`>;
type `regex` <character | class<`regex`>, ...> => class<`regex`>;
type `register` <...> => environment;
type `re_matches` <character[], class<`regex`>, logical, null, logical, ...> => (class<`data.frame`> | logical[]);
type `re_substitutes` <character[], character, character, logical, character | null, ...> => character[];
type `rex` <..., any> => class<`regex`>;
type `rex_` <class<`lazy_dots`>, any> => class<`regex`>;
type `sanitize` <character, character[]> => character;
type `zero_or_more` <..., character[]> => class<`regex`>;
