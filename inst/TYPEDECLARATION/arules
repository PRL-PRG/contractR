type `.aremtypes` < > => character[];
type `.barplot_horiz` <double[], double, double, character, null, null> => ^double[];
type `.barplot_vert` <double[], double, double, null, character, null> => ^double[];
type `.combineMeta` <character, null> => struct<`support`:double[], `confidence`:double[], `lift`:double[], `count`:integer[]>;
type `.density_Matrix` < > => double;
type `.getCounts` <logical> => struct<`f11`:double[], `f1x`:double[], `fx1`:double[], `f0x`:double[], `fx0`:double[], `f10`:double[], `f01`:double[], `f00`:double[], `N`:integer>;
type `.hyperConfidence` <logical, logical, logical, null> => double[];
type `.hyperLift` <logical, double, null> => double[];
type `.imbalance` <logical> => double[];
type `.improvement` <symbol, logical, character> => double[];
type `.is.subset_sparse` < > => logical;
type `.joinedList` < > => list<double[]>;
type `.kulc` <logical> => double[];
type `.list2object` <character> => struct<`support`:double> | struct<`supp`:double>;
type `.local` <tuple<character[], character[]> | tuple<integer[], integer[], integer[], integer[], integer[]> | character[], null | character[] | double | symbol | null | language, null | character | null | double, null | character | symbol | struct<`transactions`:null> | struct<> | null | double, null | character | double | null, null | double | null, double | null | character, double, logical, logical, logical, double, null, null, null, null> => null | struct<`formula`:language, `as.table`:logical, `aspect.fill`:logical, `panel`:any => any, `page`:null, `layout`:null, `skip`:logical, `strip`:logical, `strip.left`:logical, `xscale.components`:any => any, `yscale.components`:any => any, `axis`:any => any, `xlab`:character, `ylab`:character, `xlab.default`:character, `ylab.default`:character, `xlab.top`:null, `ylab.right`:null, `main`:null, `sub`:null, `x.between`:double, `y.between`:double, `par.settings`:struct<`background`:struct<`col`:character>>, `plot.args`:null, `lattice.options`:null, `par.strip.text`:null, `index.cond`:tuple<integer>, `perm.cond`:integer, `condlevels`:tuple<character>, `call`:language, `x.scales`:struct<`draw`:logical, `axs`:character, `tck`:double[], `tick.number`:double, `at`:logical, `labels`:logical, `log`:logical, `alternating`:double[], `relation`:character, `abbreviate`:logical, `minlength`:double, `limits`:null, `format`:null, `equispaced.log`:logical, `lty`:logical, `lwd`:logical, `cex`:logical[], `rot`:logical[], `col`:logical, `col.line`:logical, `alpha`:logical, `alpha.line`:logical, `font`:logical, `fontfamily`:logical, `fontface`:logical, `lineheight`:logical>, `y.scales`:struct<`draw`:logical, `axs`:character, `tck`:double[], `tick.number`:double, `at`:logical, `labels`:logical, `log`:logical, `alternating`:double[], `relation`:character, `abbreviate`:logical, `minlength`:double, `limits`:null, `format`:null, `equispaced.log`:logical, `lty`:logical, `lwd`:logical, `cex`:logical[], `rot`:logical[], `col`:logical, `col.line`:logical, `alpha`:logical, `alpha.line`:logical, `font`:logical, `fontfamily`:logical, `fontface`:logical, `lineheight`:logical>, `panel.args.common`:struct<`x`:integer[], `y`:integer[], `z`:double[], `at`:double[], `region`:logical, `col.regions`:character[]>, `panel.args`:tuple<struct<`subscripts`:integer[]>>, `packet.sizes`:double, `x.limits`:double[], `y.limits`:double[], `x.used.at`:null, `y.used.at`:null, `x.num.limit`:null, `y.num.limit`:null, `aspect.ratio`:double, `prepanel.default`:character, `prepanel`:null> | ^double[] | struct<> | tuple<character[]> | list<character[]> | tuple<integer[], integer[], integer[], integer[], integer[]> | list<integer[]> | struct<`4`:character[], `5`:character[], `6`:character[]> | character[] | struct<`1`:character[]> | struct<`100`:character[], `200`:character[], `300`:character[], `400`:character, `500`:character[], `600`:character[]>;
type `.maxConf` <logical> => double[];
type `.nextMethod` < > => integer | struct<> | null;
type `.rediscretizeDF` <struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:integer[], `Petal.Width`:integer[], `Species`:integer[]>, struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>> => struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:integer[], `Petal.Width`:integer[], `Species`:integer[]>;
type `.RLD` <logical> => ^double[];
type `.translate_index` <character[], character[], language> => integer[];
type `[` <integer[] | null | character[], null | symbol, logical> => integer[] | null | double;
type `%ain%` <character[]> => logical[];
type `%in%` <character> => logical[];
type `%oin%` <character> => logical[];
type `%pin%` <character> => logical[];
type `abbreviate` <character[], double> => character[];
type `addAggregate` <character> => character;
type `addComplement` <null | character> => character[];
type `affinity` <^double[]> => ^double[];
type `aggregate` < > => character[];
type `apriori` <null | struct<`items`:character[]> | struct<`none`:character[]> | struct<`rhs`:character[]>, null> => null | struct<`supp`:double, `conf`:double> | struct<`support`:double>;
type `asMethod` <symbol | struct<`supp`:double> | struct<`support`:double> | struct<> | ^logical[], character | symbol, logical> => tuple<character[]> | list<character[]> | struct<`4`:character[], `5`:character[], `6`:character[]> | ^logical[] | struct<`1`:character[]> | struct<`100`:character[], `200`:character[], `300`:character[], `400`:character, `500`:character[], `600`:character[]>;
type `c` <null> => null;
type `coverage` <null | symbol, logical> => double[];
type `crossTable` <character | logical> => ^double[];
type `DATAFRAME` <character | null | logical> => struct<`items`:integer[], `transactionID`:character[]>;
type `decode` <tuple<integer[], integer[], integer[], integer[], integer[]>, character[]> => tuple<character[], character[], character[], character[], character[]>;
type `dim` <null> => integer[];
type `dimnames` <null> => tuple<character[], character[]> | tuple<null, character[]>;
type `dimnames<-` <null> => null;
type `discretize` <double[], character, double[], null | character[], logical, logical, double, logical, logical, logical, null, null> => integer[];
type `discretizeDF` <struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, null | struct<`Petal.Length`:struct<`method`:character, `breaks`:double, `labels`:character[]>, `Petal.Width`:struct<`method`:character, `breaks`:double, `labels`:character[]>> | struct<`Sepal.Length`:null, `Sepal.Width`:null, `Petal.Length`:struct<`breaks`:double[], `method`:character, `labels`:character[]>, `Petal.Width`:struct<`breaks`:double[], `method`:character, `labels`:character[]>, `Species`:null>, null | struct<`method`:character>> => struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:integer[], `Petal.Width`:integer[], `Species`:integer[]>;
type `dissimilarity` <^double[], null, null | character, null | struct<`transactions`:null> | symbol, character | null> => double[];
type `duplicated` <symbol | logical, null> => logical[];
type `eclat` <null> => struct<`supp`:double>;
type `encode` <character[]> => tuple<character[], character[]>;
type `filter` <character[]> => logical[];
type `filterAggregate` <null, null> => null;
type `FUN` <^integer[] | character[] | double[], character[]> => null | character[] | struct<`$0-$40#000`:integer[], `$40#000+`:integer[]> | struct<`0`:integer[], `1+`:integer[]> | struct<`1-9`:integer[], `10+`:integer[]> | struct<`1`:integer[], `2+`:integer[]> | struct<`14-34`:integer[], `35+`:integer[]> | struct<`Adm-clerical`:integer[], `Armed-Forces`:integer[], `Craft-repair`:integer[], `Exec-managerial`:integer[], `Farming-fishing`:integer[], `Handlers-cleaners`:integer[], `Machine-op-inspct`:integer[], `Other-service`:integer[], `Priv-house-serv`:integer[], `Prof-specialty`:integer[], `Protective-serv`:integer[], `Sales`:integer[], `Tech-support`:integer[], `Transport-moving`:integer[]> | struct<`Amer-Indian-Eskimo`:integer[], `Asian-Pac-Islander`:integer[], `Black`:integer[], `Other`:integer[], `White`:integer[]> | struct<`american indian`:integer[], `asian`:integer[], `black`:integer[], `east indian`:integer[], `hispanic`:integer[], `pacific islander`:integer[], `white`:integer[], `other`:integer[]> | struct<`Cambodia`:integer[], `Canada`:integer[], `China`:integer[], `Columbia`:integer[], `Cuba`:integer[], `Dominican-Republic`:integer[], `Ecuador`:integer[], `El-Salvador`:integer[], `England`:integer[], `France`:integer[], `Germany`:integer[], `Greece`:integer[], `Guatemala`:integer[], `Haiti`:integer[], `Holand-Netherlands`:integer, `Honduras`:integer[], `Hong`:integer[], `Hungary`:integer[], `India`:integer[], `Iran`:integer[], `Ireland`:integer[], `Italy`:integer[], `Jamaica`:integer[], `Japan`:integer[], `Laos`:integer[], `Mexico`:integer[], `Nicaragua`:integer[], `Outlying-US(Guam-USVI-etc)`:integer[], `Peru`:integer[], `Philippines`:integer[], `Poland`:integer[], `Portugal`:integer[], `Puerto-Rico`:integer[], `Scotland`:integer[], `South`:integer[], `Taiwan`:integer[], `Thailand`:integer[], `Trinadad&Tobago`:integer[], `United-States`:integer[], `Vietnam`:integer[], `Yugoslavia`:integer[]> | struct<`Divorced`:integer[], `Married-AF-spouse`:integer[], `Married-civ-spouse`:integer[], `Married-spouse-absent`:integer[], `Never-married`:integer[], `Separated`:integer[], `Widowed`:integer[]> | struct<`english`:integer[], `spanish`:integer[], `other`:integer[]> | struct<`Federal-gov`:integer[], `Local-gov`:integer[], `Never-worked`:integer[], `Private`:integer[], `Self-emp-inc`:integer[], `Self-emp-not-inc`:integer[], `State-gov`:integer[], `Without-pay`:integer[]> | struct<`Female`:integer[], `Male`:integer[]> | struct<`house`:integer[], `condominium`:integer[], `apartment`:integer[], `mobile Home`:integer[], `other`:integer[]> | struct<`Husband`:integer[], `Not-in-family`:integer[], `Other-relative`:integer[], `Own-child`:integer[], `Unmarried`:integer[], `Wife`:integer[]> | struct<`male`:integer[], `female`:integer[]> | struct<`married`:integer[], `cohabitation`:integer[], `divorced`:integer[], `widowed`:integer[], `single`:integer[]> | struct<`no college graduate`:integer[], `college graduate`:integer[]> | struct<`None`:integer[], `Low`:integer[], `High`:integer[]> | struct<`not married`:integer[], `yes`:integer[], `no`:integer[]> | struct<`own`:integer[], `rent`:integer[], `live with parents/family`:integer[]> | struct<`Part-time`:integer[], `Full-time`:integer[], `Over-time`:integer[], `Workaholic`:integer[]> | struct<`Preschool`:integer[], `1st-4th`:integer[], `5th-6th`:integer[], `7th-8th`:integer[], `9th`:integer[], `10th`:integer[], `11th`:integer[], `12th`:integer[], `HS-grad`:integer[], `Prof-school`:integer[], `Assoc-acdm`:integer[], `Assoc-voc`:integer[], `Some-college`:integer[], `Bachelors`:integer[], `Masters`:integer[], `Doctorate`:integer[]> | struct<`professional/managerial`:integer[], `sales`:integer[], `laborer`:integer[], `clerical/service`:integer[], `homemaker`:integer[], `student`:integer[], `military`:integer[], `retired`:integer[], `unemployed`:integer[]> | struct<`small`:integer[], `large`:integer[]> | struct<`Young`:integer[], `Middle-aged`:integer[], `Senior`:integer[], `Old`:integer[]> | struct<`breaks`:double[], `method`:character, `labels`:character[]> | ^double[];
type `generatingItemsets` <null, null> => null;
type `head` < > => null | character | double;
type `hits` <integer, null, character[], logical> => double[];
type `image` <null> => struct<`formula`:language, `as.table`:logical, `aspect.fill`:logical, `panel`:any => any, `page`:null, `layout`:null, `skip`:logical, `strip`:logical, `strip.left`:logical, `xscale.components`:any => any, `yscale.components`:any => any, `axis`:any => any, `xlab`:character, `ylab`:character, `xlab.default`:character, `ylab.default`:character, `xlab.top`:null, `ylab.right`:null, `main`:null, `sub`:null, `x.between`:double, `y.between`:double, `par.settings`:struct<`background`:struct<`col`:character>>, `plot.args`:null, `lattice.options`:null, `par.strip.text`:null, `index.cond`:tuple<integer>, `perm.cond`:integer, `condlevels`:tuple<character>, `call`:language, `x.scales`:struct<`draw`:logical, `axs`:character, `tck`:double[], `tick.number`:double, `at`:logical, `labels`:logical, `log`:logical, `alternating`:double[], `relation`:character, `abbreviate`:logical, `minlength`:double, `limits`:null, `format`:null, `equispaced.log`:logical, `lty`:logical, `lwd`:logical, `cex`:logical[], `rot`:logical[], `col`:logical, `col.line`:logical, `alpha`:logical, `alpha.line`:logical, `font`:logical, `fontfamily`:logical, `fontface`:logical, `lineheight`:logical>, `y.scales`:struct<`draw`:logical, `axs`:character, `tck`:double[], `tick.number`:double, `at`:logical, `labels`:logical, `log`:logical, `alternating`:double[], `relation`:character, `abbreviate`:logical, `minlength`:double, `limits`:null, `format`:null, `equispaced.log`:logical, `lty`:logical, `lwd`:logical, `cex`:logical[], `rot`:logical[], `col`:logical, `col.line`:logical, `alpha`:logical, `alpha.line`:logical, `font`:logical, `fontfamily`:logical, `fontface`:logical, `lineheight`:logical>, `panel.args.common`:struct<`x`:integer[], `y`:integer[], `z`:double[], `at`:double[], `region`:logical, `col.regions`:character[]>, `panel.args`:tuple<struct<`subscripts`:integer[]>>, `packet.sizes`:double, `x.limits`:double[], `y.limits`:double[], `x.used.at`:null, `y.used.at`:null, `x.num.limit`:null, `y.num.limit`:null, `aspect.ratio`:double, `prepanel.default`:character, `prepanel`:null>;
type `initialize` < > => double | null;
type `inspect` <null | character> => null | struct<`items`:integer[]>;
type `interestMeasure` <character[] | null, null | symbol, logical, null | character> => struct<`confidence`:double[], `oddsRatio`:^double[], `leverage`:double[]> | ^double[];
type `is.redundant` <null> => logical[];
type `is.significant` <character, double, character> => logical[];
type `is.subset` <logical, logical, null> => ^logical[];
type `is.superset` <logical, logical, null> => ^logical[];
type `is.zeroone` <^double[]> => logical;
type `itemFrequency` <logical | character | null> => double[];
type `itemFrequencyPlot` <null> => ^double[];
type `itemInfo` < > => struct<>;
type `itemInfo<-` < > => struct<`labels`:character[], `level2`:integer[], `level1`:integer[]>;
type `itemLabels` <null> => character[];
type `itemLabels<-` < > => character[];
type `items` <null, null> => null;
type `itemSetdiff` <null, null> => null;
type `itemsetInfo` < > => struct<>;
type `itemUnion` <null, null> => null;
type `labels` <character | null> => character[];
type `length` <null> => integer;
type `lhs` <null, null> => null;
type `LIST` <logical | null> => tuple<character[]> | list<character[]> | tuple<integer[], integer[], integer[], integer[], integer[]> | list<integer[]> | struct<`1`:character[]> | struct<`100`:character[], `200`:character[], `300`:character[], `400`:character, `500`:character[], `600`:character[]> | struct<`4`:character[], `5`:character[], `6`:character[]>;
type `match` <null, null> => ^integer[];
type `merge` <null> => ^logical[];
type `nitems` <null> => integer;
type `quality` < > => struct<>;
type `quality<-` < > => struct<`support`:double[], `count`:integer[]>;
type `recode` < > => character[];
type `rhs` <null, null> => null;
type `ruleInduction` <null, null> => null;
type `ruleInduction.ptree` <logical, logical> => double;
type `sample` <logical, null, null> => double;
type `show` < > => null;
type `size` <null> => integer[];
type `sort` <logical, character | null> => integer[];
type `subset` < > => language;
type `summary` < > => null;
type `support` <character> => double[];
type `support.ptree` <null> => integer[];
type `tidLists` < > => null;
type `transactionInfo` < > => struct<>;
type `transactionInfo<-` < > => struct<`transactionID`:double[], `weight`:double[]>;
type `union` <null, null> => null;
type `unique` <null> => logical;
type `validityMethod` < > => logical;
