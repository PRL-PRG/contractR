type `as_factor` <character[] | double[], ...> => class<`factor`>;
type `as_factor.character` <character[], ...> => class<`factor`>;
type `as_factor.numeric` <double[], ...> => class<`factor`>;
type `check_calc_levels` <class<`factor`>, double[] | null> => list<class<`factor`> | double[] | class<`factor`> | integer[]>;
type `check_factor` <^character[] | class<`factor`> | class<`factor`, `ordered`>> => (class<`factor`> | class<`factor`, `ordered`>);
type `check_factor_list` <list<class<`factor`>>, character> => list<class<`factor`>>;
type `check_recode_levels` <...> => character[];
type `check_weights` <double[] | null, any> => (double[] | null);
type `digits` <integer[]> => integer;
type `f` <character[], class<`factor`>> => character[];
type `fct_anon` <class<`factor`>, character> => class<`factor`>;
type `fct_c` <...> => class<`factor`>;
type `fct_collapse` <class<`factor`>, ..., null, character> => class<`factor`>;
type `fct_count` <class<`factor`>, logical, logical> => class<`data.frame`, `tbl`, `tbl_df`>;
type `fct_cross` <..., character, logical> => class<`factor`>;
type `fct_drop` <class<`factor`>, any> => class<`factor`>;
type `fct_expand` <class<`factor`>, ...> => class<`factor`>;
type `fct_explicit_na` <class<`factor`>, character> => class<`factor`>;
type `fct_infreq` <class<`factor`>, null> => class<`factor`>;
type `fct_inorder` <^character[] | class<`factor`>, null> => class<`factor`>;
type `fct_inseq` <class<`factor`>, null> => class<`factor`>;
type `fct_lump` <class<`factor`>, any, any, null, character, character[]> => class<`factor`>;
type `fct_lump_lowfreq` <class<`factor`>, character> => class<`factor`>;
type `fct_lump_min` <class<`factor`>, double, null, character> => class<`factor`>;
type `fct_lump_n` <class<`factor`>, double, double[] | null, character, character[]> => class<`factor`>;
type `fct_lump_prop` <class<`factor`>, double, null, character> => class<`factor`>;
type `fct_match` <class<`factor`>, character[]> => logical[];
type `fct_other` <class<`factor`>, any, any, character> => class<`factor`>;
type `fct_recode` <class<`factor`>, ...> => class<`factor`>;
type `fct_relabel` <class<`factor`>, class<`formula`> | class<`function`>, ...> => class<`factor`>;
type `fct_relevel` <class<`factor`>, ..., double> => class<`factor`>;
type `fct_reorder` <class<`factor`>, double[], class<`function`>, ..., logical> => class<`factor`>;
type `fct_reorder2` <class<`factor`>, double[], double[], class<`function`>, ..., logical> => class<`factor`>;
type `fct_rev` <class<`factor`>> => class<`factor`>;
type `fct_shift` <class<`factor`, `ordered`>, double> => class<`factor`, `ordered`>;
type `fct_shuffle` <class<`factor`> | class<`factor`, `ordered`>> => (class<`factor`> | class<`factor`, `ordered`>);
type `fct_unify` <list<class<`factor`>>, character[]> => list<class<`factor`>>;
type `fct_unique` <class<`factor`>> => class<`factor`>;
type `filter` <character[]> => logical[];
type `.fun` <double, double> => double;
type `FUN` <^character[] | class<`factor`> | class<`factor`, `ordered`>> => (class<`factor`> | class<`factor`, `ordered`>) | <class<`factor`>, ..., double> => class<`factor`> | <class<`factor`>, character[]> => class<`factor`> | <character> => logical | <integer> => double;
type `in_smallest` <integer[]> => logical[];
type `lump_cutoff` <integer[]> => double;
type `lvls_expand` <class<`factor`>, character[]> => class<`factor`>;
type `lvls_reorder` <class<`factor`> | class<`factor`, `ordered`>, double[], null> => (class<`factor`> | class<`factor`, `ordered`>);
type `lvls_revalue` <class<`factor`>, character[]> => class<`factor`>;
type `lvls_seq` <class<`factor`> | class<`factor`, `ordered`>> => integer[];
type `lvls_union` <list<class<`factor`>>> => character[];
type `refactor` <class<`factor`> | class<`factor`, `ordered`>, character[], null> => (class<`factor`> | class<`factor`, `ordered`>);
type `shift` <integer, double> => double[];
type `zero_pad` <integer[]> => character[];
