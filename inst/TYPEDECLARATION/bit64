type `-.integer64` <null | double[], double[] | null> => double[];
type `:.default` <double, double> => integer[];
type `:.integer64` <double, double> => double[];
type `!.integer64` <double[]> => ^logical[];
type `!=.integer64` <double[], double[]> => ^logical[];
type `[.integer64` <^double[], null | double[]> => ^double[];
type `[[.integer64` <double[], double> => double;
type `[[<-.integer64` <double[], double, double> => double[];
type `[<-.integer64` <^double[], character | double | integer[] | null, null | integer[] | double> => ^double[];
type `*.integer64` <double[], double[]> => double[];
type `/.integer64` <double[], double> => double[];
type `&.integer64` <double[], double[]> => ^logical[];
type `%/%.integer64` <double[], double> => double[];
type `%in%.default` <^integer[] | character | double, ^integer[] | character[]> => logical[];
type `%in%.integer64` <double[], double[], null> => logical[];
type `^.integer64` <double[], double[]> => double[];
type `+.integer64` <null | ^double[], double[]> => ^double[];
type `<.integer64` <double[], double[]> => ^logical[];
type `<=.integer64` <double[], double[]> => ^logical[];
type `==.integer64` <double[], double[]> => ^logical[];
type `>.integer64` <double[], double[]> => ^logical[];
type `>=.integer64` <double[], double[]> => ^logical[];
type `|.integer64` <double[], double[]> => ^logical[];
type `A` <double> => double[];
type `abs.integer64` <double[]> => double[];
type `all.integer64` <double[], logical> => null | logical;
type `any.integer64` <double[], logical> => null | logical;
type `as.bitstring.integer64` <double[], null> => character[];
type `as.character.integer64` <double[], null> => ^character[];
type `as.data.frame.integer64` <^double[], null | logical> => struct<`x`:double[]>;
type `as.double.integer64` <double[], logical, null> => ^double[];
type `as.integer.integer64` <double[], null> => ^integer[];
type `as.integer64.character` <character[], null> => double[];
type `as.integer64.double` <null | ^double[], logical, null> => double[];
type `as.integer64.factor` <^integer[], null> => double[];
type `as.integer64.integer` <null | ^integer[], double | null> => double[];
type `as.integer64.integer64` <null | ^double[], null> => null | ^double[];
type `as.integer64.logical` <null | ^logical[], null> => double[];
type `as.logical.integer64` <double[], null> => ^logical[];
type `asMethod` <character[], character, logical> => double[];
type `benchmark64` <double, double, any => any> => ^double[];
type `binattr` <null | ^double[], double[]> => null | struct<`class`:character>;
type `c.integer64` <^double[] | tuple<^double[], ^double[], ^double[]>, logical> => ^double[];
type `cache` <double[]> => null | environment;
type `cbind` <double[]> => ^double[];
type `ceiling.integer64` <double[]> => double[];
type `cummax.integer64` <double[]> => double[];
type `cummin.integer64` <double[]> => double[];
type `cumprod.integer64` <double[]> => double[];
type `cumsum.integer64` <double[]> => double[];
type `diff.integer64` <double[], double, double, null> => double[];
type `duplicated.integer64` <double[], logical, null, null, null> => logical[];
type `filter` <character[]> => logical[];
type `floor.integer64` <double[]> => double[];
type `format.integer64` <double[], character, null> => character[];
type `fun` <symbol, symbol> => null;
type `FUN` <null | double | language | symbol> => null | character | double[];
type `getcache` <double[], character> => double;
type `hashcache` <double[], null, null> => environment;
type `hashdup.cache_integer64` <environment, null> => logical[];
type `hashfin.cache_integer64` <environment, double[], null> => logical[];
type `hashfun.integer64` <double[], double, null, null> => integer[];
type `hashmap.integer64` <double[], null | integer, double, null | integer, null | environment, null> => environment;
type `hashmaptab.integer64` <double[], null, double, null, null> => struct<`values`:double[], `counts`:integer[]>;
type `hashmapuni.integer64` <double[], null | integer, double, null, null> => double[];
type `hashmapupo.integer64` <double[], null, double, null, null> => integer[];
type `hashpos.cache_integer64` <environment, double[], null | integer, null> => ^integer[];
type `hashrev.cache_integer64` <environment, double[], null, null> => ^integer[];
type `hashrin.cache_integer64` <environment, double[], null> => logical[];
type `hashtab.cache_integer64` <environment, null> => struct<`values`:double[], `counts`:integer[]>;
type `hashuni.cache_integer64` <environment, logical, null> => double[];
type `hashupo.cache_integer64` <environment, logical, null> => integer[];
type `identical.integer64` <null | character[] | struct<> | ^double[], character[] | struct<> | ^double[], logical, logical, logical, logical> => logical;
type `integer64` <double> => double[];
type `is.double.default` <^double[]> => logical;
type `is.double.integer64` <double[]> => logical;
type `is.integer64` <null | ^double[] | tuple<raw[], raw[]> | ^character[]> => logical;
type `is.na.integer64` <double[]> => logical[];
type `is.sorted.integer64` <double[], null> => logical;
type `jamcache` <double[]> => environment;
type `keypos.integer64` <double[], null, null> => integer[];
type `length<-.integer64` <double[], double> => double[];
type `list.names` <language | symbol> => character[];
type `log.integer64` <double[], double> => double[];
type `log10.integer64` <double[]> => double[];
type `log2.integer64` <double[]> => double[];
type `match.default` <^integer[] | double, ^integer[], null> => ^integer[];
type `match.integer64` <double[], double[], null | integer, null, null, null> => ^integer[];
type `max.integer64` <double[], logical> => double;
type `mean.integer64` <double[], logical, null> => double;
type `median.integer64` <double[], logical, null> => double;
type `mergeorder.integer64` <double[], integer[], logical, logical, logical, null> => integer;
type `mergesort.integer64` <double[], logical, logical, logical, null> => integer;
type `mergesortorder.integer64` <double[], integer[], logical, logical, logical, null> => integer;
type `min.integer64` <double[], logical> => double;
type `minusclass` <character[], character> => character[];
type `na.count.integer64` <double[], null> => integer;
type `newcache` <double[]> => environment;
type `nties.integer64` <double[], null> => integer;
type `nunique.integer64` <double[], null> => integer;
type `nvalid.integer64` <double[], null> => integer;
type `optimizer64` <double, double, any => any, character[], double[], pairlist, logical> => list<^double[]>;
type `order.default` <^double[]> => integer[];
type `order.integer64` <language | symbol | double[], logical, logical, logical, logical, character[] | language, logical> => integer[];
type `ordercache` <double[], null, null, character> => double[];
type `orderdup.integer64` <double[], integer[], null | double, null> => logical[];
type `orderfin.integer64` <double[], integer[], double[], null, null> => logical[];
type `ordernut.integer64` <double[], integer[], null> => integer[];
type `orderpos.integer64` <double[], integer[], double[], null, null | double, null> => ^integer[];
type `orderqtl.integer64` <double[], integer[], integer, double[], null> => double[];
type `orderrnk.integer64` <double[], integer[], integer, null> => ^double[];
type `ordertab.integer64` <double[], integer[], integer | symbol, logical, logical, null> => integer[];
type `orderuni.integer64` <double[], integer[], integer, logical, null> => double[];
type `orderupo.integer64` <double[], integer[], integer, logical, null> => integer[];
type `plusclass` <null | character, character> => character[];
type `prank.integer64` <double[], null, null> => ^double[];
type `prod.integer64` <double[], logical> => double;
type `qtile.integer64` <double[], double[], logical, null, symbol | null> => double[];
type `quantile.integer64` <double[], double[], logical, logical, integer, null> => double[];
type `radixsort.integer64` <double[], logical, logical, logical, integer, null> => integer;
type `radixsortorder.integer64` <double[], integer[], logical, logical, logical, integer, null> => integer;
type `ramorder.integer64` <double[], integer[], logical, logical, logical, logical, character[], logical, null> => integer;
type `ramsort.integer64` <double[], logical, logical, logical, logical | symbol, character[], logical, null> => integer;
type `ramsortorder.integer64` <double[], integer[], logical, logical, logical, logical, character[], logical, null> => integer;
type `range.integer64` <^double[], logical> => double[];
type `rank.default` <^integer[] | double[], character | null> => ^double[];
type `rank.integer64` <double[], null, null> => ^double[];
type `rbind` <double[]> => ^double[];
type `remcache` <^double[]> => null;
type `rep.integer64` <^double[], double[]> => ^double[];
type `setcache` <double[], character, double[]> => environment;
type `sign.integer64` <double[]> => double[];
type `signif.integer64` <double[], double> => double[];
type `sort.integer64` <double[], logical, logical, null | logical, logical, character[] | language, logical, null> => double[];
type `sortcache` <double[], null> => double[];
type `sortfin.integer64` <double[], double[], null, null> => logical[];
type `sortnut.integer64` <double[], null> => integer[];
type `sortordercache` <double[], null, null> => double[];
type `sortorderdup.integer64` <double[], integer[], null | double, null> => logical[];
type `sortorderkey.integer64` <double[], integer[], integer, null> => integer[];
type `sortorderpos.integer64` <double[], integer[], double[], null, null, null> => ^integer[];
type `sortorderrnk.integer64` <double[], integer[], integer, null> => ^double[];
type `sortordertab.integer64` <double[], integer[], logical, null> => integer[];
type `sortordertie.integer64` <double[], integer[], integer, null> => integer[];
type `sortorderuni.integer64` <double[], double[], integer[], integer, null> => double[];
type `sortorderupo.integer64` <double[], integer[], integer, logical, null> => integer[];
type `sortp` <struct<`values`:double[], `counts`:integer[]>> => struct<`values`:double[], `counts`:integer[]>;
type `sortqtl.integer64` <double[], integer, double[], null> => double[];
type `sorttab.integer64` <double[], integer, null> => integer[];
type `sortuni.integer64` <double[], integer, null> => double[];
type `sqrt.integer64` <double[]> => double[];
type `still.identical` <double[], double[]> => logical;
type `str.integer64` <^double[], integer, logical, logical, language> => null;
type `sum.integer64` <double[], logical> => double;
type `summary.integer64` <double[], null> => double[];
type `table.integer64` <symbol | language, character[], character[], null, null, character[], double> => struct<`x`:double[], `y`:double[], `Freq`:integer[]> | ^integer[] | struct<`values`:double[], `counts`:integer[]>;
type `tiepos.integer64` <double[], null, null, null> => integer[];
type `trunc.integer64` <double[], null> => double[];
type `unipos.integer64` <double[], logical, character[], null, null, null> => integer[];
type `unique.integer64` <double[], logical, character[], null, null, null | symbol> => double[];
type `xor.integer64` <double[], double[]> => ^logical[];
type `::` <double, null> => character;
