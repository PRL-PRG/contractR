type `as.expression.norMix` <class<`norMix`>, logical, ...> => expression;
type `as.function.norMix` <class<`norMix`>, logical, environment, ...> => class<`function`>;
type `cc` <class<`matrix`>> => double[];
type `clus2norMix` <integer[], double[], character> => class<`norMix`>;
type `dnorMix` <double[], class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>, logical> => double[];
type `dnorMixL` <class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>, null, logical, double[] | null, double> => list<double[]>;
type `dpnorMix` <double[], class<`norMix`>, logical> => list<double[]>;
type `emstep.nm` <double[], class<`norMix`>> => class<`norMix`>;
type `estep.nm` <double[], any, any> => class<`matrix`>;
type `f` <double> => double | <double> => double;
type `filter` <character[]> => logical[];
type `f.make` <any> => class<`function`>;
type `fn` <double[]> => double;
type `FUN` <integer> => double[] | <double[]> => list<double>;
type `is.norMix` <class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>> => logical;
type `lines.norMix` <class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>, character, double, null, double, logical, any, ...> => null;
type `llnorMix` <double[], double[], double, any> => double;
type `mean.norMix` <class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>, ...> => double;
type `m.norMix` <class<`norMix`>> => integer;
type `mstep.nm` <double[], class<`matrix`>> => list<double[]>;
type `mySfun` <double[], double[], ...> => class<`function`>;
type `nM2par` <class<`norMix`>, character[]> => double[];
type `.nM2par` <double[], double[], character, double[], logical> => double[];
type `norMix` <double[], any, any, double[] | null, character | null, logical> => class<`norMix`>;
type `[.norMix` <class<`norMix`> | class<`fitEM`, `nMfit`, `norMix`>, any, any, logical> => (class<`norMix`> | double[]);
type `norMix2call` <class<`norMix`>, logical> => class<`call`>;
type `norMixEM` <double[], class<`factor`> | double | integer[], null, double, any, double, double, double> => class<`fitEM`, `nMfit`, `norMix`>;
type `norMixMLE` <double[], integer[], null, character[], double, double, double> => class<`fitMLE`, `nMfit`, `norMix`>;
type `outRange` <double> => double[];
type `.par2nM` <double[], any> => list<double[]>;
type `par2norMix` <double[], character[], character> => class<`norMix`>;
type `plot.norMix` <class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>, character, double, null, null, any, character, character, character, double, logical, logical> => (class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>);
type `pnorMix` <double[], class<`norMix`>, logical, logical> => double[];
type `pPar` <double[]> => character;
type `print.norMix` <class<`norMix`>, ...> => class<`norMix`>;
type `qnorMix` <double[], class<`norMix`>, logical, logical, any, double, double, any, any, double> => double[];
type `rnorMix` <double, class<`norMix`>> => double[];
type `r.norMix` <class<`norMix`>, null, null, double, logical> => (double[] | list<double[]>);
type `safeUroot` <class<`function`>, any, double, double, double, double, double, double, double, double, ...> => list<double | null>;
type `sformat` <double[]> => character[];
type `sort.norMix` <class<`norMix`>, logical, ...> => class<`norMix`>;
type `sub_seq` <integer, double> => double[];
type `var.norMix` <class<`fitEM`, `nMfit`, `norMix`> | class<`norMix`>, ...> => double;
