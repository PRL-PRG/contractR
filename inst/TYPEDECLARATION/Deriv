type `Cache` <class<`call`>, environment, character> => class<`call`>;
type `deCache` <class<`call`> | class<`name`> | double> => (class<`call`> | class<`name`> | double);
type `Deriv` <character, character[], environment, logical, logical, null, character> => character;
type `Deriv_` <class<`call`> | class<`if`> | class<`name`> | double, character[], any, any, any, any, any> => (class<`call`> | class<`if`> | double);
type `filter` <character[]> => logical[];
type `format1` <class<`(`> | class<`call`> | class<`if`> | class<`name`> | double> => character;
type `FUN` <class<`call`> | class<`name`> | double> => (class<`call`> | class<`name`> | double) | <class<`call`> | class<`if`> | class<`name`> | double, character[], any, any, any, any, any> => (class<`call`> | class<`if`> | double) | <class<`(`> | class<`call`> | class<`if`> | class<`name`> | double> => character | <class<`call`> | class<`name`> | double> => logical | <list<logical | list<null | double | list<class<`name`> | double>>>> => list<logical | list<null | double | list<class<`name`> | double>>> | <character> => (class<`call`> | double) | <list<logical | list<double | list<class<`call`> | double>> | logical | list<null | double | list<class<`name`> | double>>>> => logical | <character> => logical | <class<`call`> | class<`name`>> => (class<`call`> | class<`name`> | double) | <class<`(`> | class<`call`> | class<`name`> | double> => logical | <list<logical | list<double | list<class<`call`> | double>> | logical | list<null | double | list<class<`name`> | double>>>> => list<any> | <integer> => environment | <integer> => integer[] | <class<`call`> | class<`name`> | double | class<`if`>> => logical | <list<any>, any, null | logical> => class<`call`> | <list<logical | list<double | list<class<`call`> | double>> | logical | list<null | double | list<class<`name`> | double>>>> => (null | list<double>) | <integer> => class<`call`> | <class<`(`> | class<`call`> | class<`name`> | double | class<`if`>, any> => (class<`call`> | class<`name`> | double | class<`if`>) | <integer> => integer[];
type `is.conuloch` <class<`call`> | class<`name`> | double | class<`if`>> => logical;
type `is.neg.expr` <double> => logical;
type `is.numconst` <class<`call`> | class<`name`> | double, double | null> => logical;
type `is.subindex` <class<`call`>> => logical;
type `is.uminus` <class<`call`> | class<`if`> | class<`name`> | double> => logical;
type `is.uplus` <class<`call`> | class<`name`> | double> => logical;
type `lc2expr` <list<list<logical | list<double | list<class<`call`> | double>> | logical | list<null | double | list<class<`name`> | double>>>>, environment> => class<`call`>;
type `Leaves` <class<`call`> | class<`name`> | double, any, environment> => environment;
type `li2sum` <list<class<`call`> | double>> => class<`call`>;
type `Lincomb` <class<`call`>> => list<list<logical | list<double | list<class<`call`> | double>> | logical | list<null | double | list<class<`name`> | double>>>>;
type `nd2expr` <list<any>, any, null | logical> => class<`call`>;
type `negate.expr` <double> => double;
type `Numden` <double | class<`call`> | class<`name`>> => list<any>;
type `Simplify` <class<`call`> | class<`if`>, any, environment> => (class<`call`> | class<`if`>);
type `Simplify_` <class<`(`> | class<`call`> | class<`name`> | double | class<`if`>, any> => (class<`call`> | class<`name`> | double | class<`if`>);
type `Simplify.*` <class<`call`>, logical, any> => class<`call`>;
type `Simplify.+` <class<`call`>, logical, any> => class<`call`>;
type `Simplify.rule` <class<`call`>, logical, any> => class<`call`> | <class<`if`>, any> => class<`if`> | <class<`call`>, any> => (class<`call`> | class<`name`>) | <class<`call`>, any> => class<`call`> | <class<`call`>, any> => class<`call`> | <class<`call`>, any> => class<`call`> | <class<`(`>, any> => class<`call`> | <class<`call`>, any> => class<`call`>;
