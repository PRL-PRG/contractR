type `betahat.fun` <class<`matrix`> | class<`data.frame`>, class<`matrix`>, double[], logical, class<`function`>> => (double[] | list<double[] | class<`matrix`>>);
type `betahat.fun.A` <class<`matrix`>, class<`matrix`>, double[], logical, class<`function`>> => double[];
type `cond.sample` <double, class<`matrix`>, class<`matrix`>, double[], any, class<`matrix`>, double[], null, class<`function`>, ...> => class<`matrix`>;
type `corr` <double[], double[], double[] | null, null | class<`matrix`>, character, null> => double;
type `corr.matrix` <class<`matrix`> | class<`data.frame`>, class<`matrix`> | null | class<`data.frame`>, double, class<`function`>, ...> => class<`matrix`>;
type `cprod` <class<`matrix`> | double[], class<`matrix`> | double[]> => class<`matrix`>;
type `distance.function` <double[], double[], double[] | null, null | class<`matrix`>, character, null> => double;
type `estimator` <class<`matrix`>, class<`matrix`>, double[], double[], null, class<`function`>> => double[];
type `FUN` <double[]> => double[];
type `func` <double[]> => double[];
type `ht` <class<`matrix`> | class<`data.frame`>> => class<`matrix`>;
type `interpolant` <double[], double[], class<`matrix`>, class<`matrix`>, null, logical, double[], null, class<`function`>, logical, class<`function`>, ...> => (double | list<double[] | class<`matrix`>>);
type `interpolant.quick` <class<`matrix`>, double[], class<`matrix`> | class<`data.frame`>, class<`matrix`>, double[], null, class<`function`>, logical, class<`function`>, ...> => (double[] | list<double[]>);
type `int.qq` <class<`matrix`>, double[], class<`matrix`>, class<`matrix`>, class<`matrix`>, class<`function`>> => double[];
type `latin.hypercube` <double, double, null, logical, logical> => class<`matrix`>;
type `model` <double> => double;
type `optimal.scale` <class<`matrix`>, double[], logical, logical, class<`function`>, ...> => double;
type `optimal.scales` <class<`matrix`>, double[], double[], logical, logical, class<`function`>, ...> => double[];
type `pad` <character, double, character, logical> => character;
type `prior.b` <class<`matrix`>, class<`matrix`>, double[], null, null> => class<`matrix`>;
type `prior.B` <class<`matrix`>, class<`matrix`>, null> => class<`matrix`>;
type `quad.3diag` <class<`matrix`>, class<`matrix`>, class<`matrix`>> => complex[];
type `quad.3form` <class<`matrix`>, class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `quad.3tdiag` <class<`matrix`>, class<`matrix`>, class<`matrix`>> => complex[];
type `quad.3tform` <class<`matrix`>, class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `quad.diag` <class<`matrix`>, class<`matrix`>> => complex[];
type `quad.form` <class<`matrix`>, class<`matrix`> | double[], logical> => (class<`matrix`> | double);
type `quad.form.inv` <class<`matrix`>, class<`matrix`> | double[]> => (class<`matrix`> | double);
type `quad.tdiag` <class<`matrix`>, class<`matrix`>> => complex[];
type `quad.tform` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `quad.tform.inv` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `regressor.basis` <double[]> => double[];
type `regressor.multi` <class<`data.frame`> | class<`matrix`>, class<`function`>> => class<`matrix`>;
type `sample.from.exp.est` <double, class<`data.frame`>, logical, double> => class<`matrix`>;
type `sample.n.fit` <double, double, double, class<`function`>, ...> => list<list<double[]>>;
type `scales.likelihood` <null, double[], class<`matrix`>, logical, double[], logical, class<`function`>> => double;
type `s.chi` <class<`matrix`>, class<`matrix`>, double[], double, logical> => (class<`matrix`> | double);
type `sigmahatsquared` <class<`matrix`>, class<`matrix`>, double[]> => double;
type `sigmahatsquared.A` <class<`matrix`>, class<`matrix`>, double[]> => double;
type `tcprod` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `tr` <class<`matrix`>> => integer;
type `var.conditional` <class<`matrix`>, class<`matrix`>, double[], any, class<`matrix`>, double[], null, class<`function`>, class<`function`>, ...> => class<`matrix`>;
