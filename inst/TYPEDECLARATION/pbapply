type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null;
type `::` <struct<`getVal`:any => any, `up`:any => any, `kill`:any => any> | language, double | language> => null | double;
type `$` <double> => null | double;
type `closepb` <null | struct<`getVal`:any => any, `up`:any => any, `kill`:any => any>> => null;
type `dopb` < > => logical;
type `FUN` <double[]> => integer[];
type `getTimeAsString` <double> => character;
type `pblapply` <list<integer[]> | double[] | struct<`a`:integer[], `beta`:double[], `logic`:logical[]> | struct<`a`:double, ``:double, `c`:double>, any => any, null | double[], null | integer | tuple<struct<`con`:integer, `host`:character, `rank`:integer>>> => tuple<double[], double[], double[], double[], double[]> | list<double[]> | list<list<null>> | list<null> | struct<`A`:^double[], `B`:^double[], `C`:^double[], `D`:^double[]> | struct<`a`:double[], `beta`:double[], `logic`:double[]> | struct<`a`:double, ``:double, `c`:null>;
type `pbmapply` <any => any, character[] | double[], null | struct<`x`:double>, logical, logical> => tuple<double, double[], double[], double[]> | tuple<integer[], integer[], integer[], integer> | struct<`A`:character, `B`:character, `C`:character, `D`:character, `E`:character, `F`:character> | struct<`a`:double, `b`:double[], `c`:double[]>;
type `pboptions` <character | double | struct<`type`:character, `char`:character, `txt.width`:double, `gui.width`:double, `style`:double, `initial`:double, `title`:character, `label`:character, `nout`:integer, `min_time`:double, `use_lb`:logical>> => struct<`type`:character, `char`:character, `txt.width`:double, `gui.width`:double, `style`:double, `initial`:double, `title`:character, `label`:character, `nout`:integer, `min_time`:double, `use_lb`:logical>;
type `pbreplicate` <double, language, character, null | integer | tuple<struct<`con`:integer, `host`:character, `rank`:integer>, struct<`con`:integer, `host`:character, `rank`:integer>>> => ^double[];
type `pbsapply` <struct<`a`:integer[], `beta`:double[], `logic`:logical[]> | list<integer[]> | double[] | character[], any => any, null | double[], character | logical, logical, null | integer | tuple<struct<`con`:integer, `host`:character, `rank`:integer>, struct<`con`:integer, `host`:character, `rank`:integer>>> => ^double[] | tuple<>;
type `pbtypes` < > => character[];
type `setpb` <struct<`getVal`:any => any, `up`:any => any, `kill`:any => any> | symbol, double | symbol> => null | double;
type `splitpb` <double, double, null | double> => tuple<integer[], integer[], integer[]> | list<integer[]>;
type `startpb` <double, double | language | symbol> => null | struct<`getVal`:any => any, `up`:any => any, `kill`:any => any>;
type `timerProgressBar` <double, double, double, character, null | double, null, null, double, character, double> => struct<`getVal`:any => any, `up`:any => any, `kill`:any => any>;
type `up` <double> => null;
