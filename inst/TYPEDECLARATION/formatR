type `[[` <struct<`message`:character, `call`:null> | symbol> => character[];
type `$` <language | double | symbol, struct<`handler`:any => any, `call`:any => any, `leaf`:any => any> | symbol> => language | double | symbol;
type `capture_usage` <any => any> => character[];
type `count_tokens` <language> => integer[];
type `filter` <character[]> => logical[];
type `find_breaks` <integer[], double, double | symbol, any => any | symbol, integer> => struct<`breaks`:integer[], `overflow`:integer[]> | struct<`breaks`:integer[], `overflow`:null>;
type `fix_parse_data` <struct<`line1`:integer[], `col1`:integer[], `line2`:integer[], `col2`:integer[], `id`:integer[], `parent`:integer[], `token`:character[], `terminal`:logical[], `text`:character[]>, character | symbol> => struct<`line1`:integer[], `col1`:integer[], `line2`:integer[], `col2`:integer[], `id`:integer[], `parent`:integer[], `token`:character[], `terminal`:logical[], `text`:character[]>;
type `FUN` <? struct<`x1`:symbol> | struct<`x3`:symbol> | struct<`...`:symbol> | tuple<> | struct<`y4`:double> | struct<`y2`:double> | struct<`x2`:symbol> | struct<`y1`:double> | struct<`y3`:double> | struct<`x4`:symbol> | character[] | double | language | symbol | struct<`out`:character[], `warn`:character[]> | struct<`a`:character> | struct<`b`:character> | any => any | logical[]> => any => any | double | symbol | integer[] | struct<`...`:symbol> | list<struct<`...`:symbol>> | list<logical[]> | struct<`out`:character[], `warn`:character[]> | tuple<> | struct<`a`:character> | struct<`b`:character> | struct<`x1`:symbol> | struct<`x2`:symbol> | struct<`x3`:symbol> | struct<`x4`:symbol> | struct<`y1`:double> | struct<`y2`:double> | struct<`y3`:double> | struct<`y4`:double> | character[];
type `make_fn` <struct<`x1`:symbol, `x2`:symbol, `x3`:symbol, `x4`:symbol, `y1`:double, `y2`:double, `y3`:double, `y4`:double, `...`:symbol, `a`:character, `b`:character>> => any => any;
type `mask_comments` <character[], double | symbol, logical, logical> => character[];
type `mask_line_break` <character[]> => character[];
type `move_leftbrace` <character[]> => character[];
type `n_spaces` <integer> => character;
type `overflow_message` <integer[], integer, integer, character> => character;
type `parse_only` <character[]> => expression;
type `parse_source` <character[]> => expression;
type `rand_string` <double> => character;
type `re` <integer> => character;
type `reflow_comments` <character[], double> => character[];
type `reindent_lines` <character[], double> => character[];
type `replace_assignment` <expression> => tuple<language, language>;
type `special_encoding` <character[]> => character[];
type `subsets` <struct<`a`:character, `b`:character> | struct<`x1`:symbol, `x2`:symbol, `x3`:symbol, `x4`:symbol, `y1`:double, `y2`:double, `y3`:double, `y4`:double>> => tuple<tuple<>, struct<`a`:character>, struct<`b`:character>, struct<`a`:character, `b`:character>> | list<*>;
type `subsets_lgl` <integer> => tuple<logical[], logical[], logical[], logical[]> | list<logical[]>;
type `tidy_block` <character[], double, logical> => character[];
type `tidy_dir` <character, logical, ???> => null;
type `tidy_eval` <character, character[] | ???, character, character, environment> => null;
type `tidy_file` <character[], ???> => null;
type `tidy_source` <character | symbol, logical, logical, language | logical, logical, language | double, language | logical, logical, ? character[], language | double, ??? | character> => struct<`text.tidy`:character[], `text.mask`:character[]>;
type `tidy_usage` <character, character[], double, double, character> => character;
type `tidy.res` <character[], double | ???> => character[];
type `track` <symbol> => null;
type `trimws` <character[], character> => character[];
type `unmask_source` <character[]> => character[];
type `usage` <character | any => any, double, logical, logical, logical, character[]> => character[];
