type `addControlDddot` < > => double | ???;
type `AIC.maxLik` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???, double> => double;
type `compareDerivatives` <any => any, any => any, null, double[], double, logical, ???> => struct<`t0`:double[], `f.t0`:double, `compareGrad`:struct<`analytic`:double[], `numeric`:^double[], `rel.diff`:^double[]>, `maxRelDiffGrad`:double> | struct<`t0`:double, `f.t0`:double[], `compareGrad`:struct<`analytic`:double[], `numeric`:^double[], `rel.diff`:^double[]>, `maxRelDiffGrad`:double>;
type `condiNumber.default` <^double[], logical, logical, double, double, integer, ???> => double[];
type `constrOptim2` <double[], any => any, ? any => any, ^double[], double[], double, struct<`trace`:double, `REPORT`:double, `fnscale`:double, `reltol`:double, `maxit`:integer, `parscale`:double[], `alpha`:double, `beta`:double, `gamma`:double, `temp`:double, `tmax`:integer>, character, double, double, any => any> => struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `outer.iterations`:integer, `barrier.value`:double>;
type `convert` <character | double> => character | double;
type `filter` <character[]> => logical[];
type `fn` <double[], any => any, double, double[], ???> => ? double;
type `fnSubset` <double, any => any, double, double[], ???> => double;
type `fun` <symbol, symbol> => null;
type `gPenalty` <double[]> => ^double[];
type `gr` <double[], any => any> => double[];
type `gradient.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:struct<`theta0`:double[], `f0`:double, `climb`:double[]>, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???> => double[];
type `hessian.default` <struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:null, `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???> => ? ^double[];
type `hessPenalty` <symbol> => ^double[];
type `logLik.maxLik` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???> => double;
type `logLik.summary.maxLik` <struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical, `NActivePar`:integer, `constraints`:null>, ???> => double;
type `max.eigen` <^double[]> => double;
type `maxBFGSRCompute` <any => any, double[], logical | character, logical[], any => any> => struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:struct<`theta0`:double[], `f0`:double, `climb`:double[]>, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:null, `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null> | struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null>;
type `maxBHHH` <any => any, any => any, null, double, character, ???> => struct<`maximum`:double, `estimate`:double, `gradient`:double, `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical, `iterations`:double, `type`:character, `gradientObs`:^double[], `control`:null, `objectiveFn`:any => any>;
type `maxControl` <double | ???> => ??? | struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>;
type `maximType.default` <struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical[], `NActivePar`:integer, `constraints`:null>> => character;
type `maximType.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>> => character;
type `maxLik` <any => any, ? any => any, ? any => any, double[], ??? | character, ? struct<`eqA`:^double[], `eqB`:double> | struct<`ineqA`:^double[], `ineqB`:double[]>, ??? | double[] | struct<`iterlim`:double> | character | any => any | struct<`printLevel`:double>> => struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:null, `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>;
type `maxNRCompute` <any => any, double[], logical | character, logical, logical[], any => any> => struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:null, `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null> | struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null>;
type `maxRoutine` <any => any, ? any => any, null, double[], character, ? struct<`eqA`:^double[], `eqB`:double>> => struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `gradientObs`:^double[], `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `gradientObs`:^double[], `control`:null, `objectiveFn`:any => any, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>>;
type `maxValue.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???> => double;
type `message` <integer> => character;
type `nIter.default` <struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical[], `NActivePar`:integer, `constraints`:null> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:struct<`theta0`:double[], `f0`:double, `climb`:double[]>, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>>, ???> => double;
type `nParam.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, logical, ???> => integer;
type `numericHessian` <any => any, ? any => any, double[], double, logical[] | ???, double[] | ??? | any => any> => ^double[];
type `objectiveFn.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???> => any => any;
type `openParam` < > => character[];
type `penalty` <double[]> => double;
type `print.summary.maxim` <struct<`maximum`:double, `type`:character, `iterations`:double, `code`:double, `message`:character, `unsucc.step`:null, `estimate`:^double[], `hessian`:null, `constraints`:null> | struct<`maximum`:double, `type`:character, `iterations`:double, `code`:double, `message`:character, `unsucc.step`:null, `estimate`:^double[], `hessian`:null, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>> | struct<`maximum`:double, `type`:character, `iterations`:integer, `code`:integer, `message`:character, `unsucc.step`:null, `estimate`:^double[], `hessian`:null, `constraints`:struct<`type`:character, `barrier.value`:double, `outer.iterations`:integer>>, ???> => null;
type `print.summary.maxLik` <struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical[], `NActivePar`:integer, `constraints`:null>, integer, ???> => null;
type `R` <double[], double[], any => any> => ? double;
type `returnCode.default` <struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical[], `NActivePar`:integer, `constraints`:null>, ???> => double;
type `returnCode.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:struct<`theta0`:double[], `f0`:double, `climb`:double[]>, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>>, ???> => double;
type `returnMessage.default` <struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical[], `NActivePar`:integer, `constraints`:null>, ???> => character;
type `returnMessage.maxim` <struct<`maximum`:double, `estimate`:double, `gradient`:double, `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical, `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, ???> => character;
type `setSlot` <character, any => any> => character[];
type `show` < > => null;
type `summary.maxim` <struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>>, logical, logical, ???> => struct<`maximum`:double, `type`:character, `iterations`:double, `code`:double, `message`:character, `unsucc.step`:null, `estimate`:^double[], `hessian`:null, `constraints`:null> | struct<`maximum`:double, `type`:character, `iterations`:double, `code`:double, `message`:character, `unsucc.step`:null, `estimate`:^double[], `hessian`:null, `constraints`:struct<`type`:character, `barrier.value`:double, `code`:double, `message`:character, `outer.iterations`:integer>> | struct<`maximum`:double, `type`:character, `iterations`:integer, `code`:integer, `message`:character, `unsucc.step`:null, `estimate`:^double[], `hessian`:null, `constraints`:struct<`type`:character, `barrier.value`:double, `outer.iterations`:integer>>;
type `summary.maxLik` <struct<`maximum`:double, `estimate`:double[], `gradient`:double[], `hessian`:null, `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any> | struct<`maximum`:double, `estimate`:double[], `gradient`:^double[], `hessian`:^double[], `code`:double, `message`:character, `last.step`:null, `fixed`:logical[], `iterations`:double, `type`:character, `control`:null, `objectiveFn`:any => any>, double, ???> => struct<`maximType`:character, `iterations`:double, `returnCode`:double, `returnMessage`:character, `loglik`:double, `estimate`:^double[], `fixed`:logical[], `NActivePar`:integer, `constraints`:null>;
