type `activePar` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`> | class<`summary.maxLik`>, ...> => logical[];
type `activePar.default` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`> | class<`summary.maxLik`>, ...> => logical[];
type `addControlDddot` <class<`MaxControl`>, ...> => class<`MaxControl`>;
type `addControlList` <class<`MaxControl`>, list<any> | null, logical> => class<`MaxControl`>;
type `addFixedPar` <double[], any, null | logical[], ...> => double[];
type `AIC.maxLik` <class<`list`, `maxLik`, `maxim`>, ..., double> => double;
type `bread.maxLik` <class<`list`, `maxLik`, `maxim`>, ...> => class<`matrix`>;
type `callWithoutArgs` <any, character, character[], ...> => (class<`matrix`> | double[]);
type `checkBhhhGrad` <class<`matrix`>, any, logical, logical[]> => any;
type `checkFuncArgs` <class<`function`>, any, character, any> => null;
type `coef.maxim` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => double[];
type `coef.maxLik` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => double[];
type `compareDerivatives` <class<`function`>, class<`function`>, null, double[], double, logical, ...> => (list<double[] | list<double[] | class<`matrix`>>> | list<double | list<double | class<`matrix`>>> | list<integer[] | double | list<double[] | class<`matrix`>>>);
type `condiNumber` <class<`matrix`>, ...> => double[];
type `condiNumber.default` <class<`matrix`>, logical, logical, double, double, integer, ...> => double[];
type `constrOptim2` <double[], class<`function`>, null, class<`matrix`>, double, double, list<double[]>, character, double, double, ...> => list<double[] | ^integer[] | null>;
type `estfun.maxLik` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => class<`matrix`>;
type `fnSubset` <double, class<`function`>, double, double[], ...> => double;
type `gradient` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => double[];
type `gradient.maxim` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => double[];
type `hessian` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => (class<`matrix`> | null);
type `hessian.default` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => (class<`matrix`> | null);
type `logLikFunc` <double[], class<`function`>, any, any, null | double[], null | logical[], logical, ...> => (class<`matrix`> | double[]);
type `logLikGrad` <double[], class<`function`>, class<`function`> | null, any, null | double[], null | logical[], logical, null, ...> => (double[] | class<`matrix`>);
type `logLikHess` <double[], class<`function`>, null, null, null, null, null, null, ...> => class<`matrix`>;
type `logLik.maxLik` <class<`list`, `maxLik`, `maxim`>, ...> => double;
type `logLik.summary.maxLik` <class<`summary.maxLik`>, ...> => double;
type `maxBFGS` <class<`function`>, null, null, double[], null, null, null, logical, double[], ...> => class<`maxim`>;
type `maxBFGSR` <class<`function`>, null, null, double[], null | list<class<`matrix`> | double>, logical, null | double | logical[], null, null | class<`MaxControl`>, ...> => class<`list`, `maxim`>;
type `maxBFGSRCompute` <class<`function`>, double[], character | logical, logical[], class<`MaxControl`>, ...> => class<`list`, `maxim`>;
type `maxBHHH` <class<`function`>, class<`function`>, null, double, character, ...> => class<`list`, `maxim`>;
type `maxControl` <any, ...> => class<`MaxControl`> | <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => class<`MaxControl`> | <class<`MaxControl`>, ...> => class<`MaxControl`> | <class<`list`, `maxim`>, ...> => class<`MaxControl`> | <any, ...> => class<`MaxControl`>;
type `maximMessage` <double> => character;
type `maximType` <class<`list`, `maxim`> | class<`maxim`> | class<`summary.maxLik`>> => character;
type `maximType.default` <class<`summary.maxLik`>> => character;
type `maximType.maxim` <class<`list`, `maxim`> | class<`maxim`>> => character;
type `maxLik` <class<`function`>, class<`function`> | null, class<`function`> | null, double[], any, null, ...> => any;
type `maxNM` <class<`function`>, null, null, double[], null, list<double>, list<class<`matrix`> | double>, logical, double[], ...> => class<`maxim`>;
type `maxNR` <class<`function`>, class<`function`> | null, class<`function`> | null, double[], null | list<class<`matrix`> | double>, logical | character, logical, null | character | logical[], null, null | class<`MaxControl`> | list<double>, ...> => any;
type `maxNRCompute` <class<`function`>, double[], character | logical, logical, logical[], class<`MaxControl`>, ...> => any;
type `maxOptim` <class<`function`>, class<`function`> | null, class<`function`> | null, double[], character, null, null | list<class<`matrix`> | double>, logical | character, double[], class<`MaxControl`>, ...> => class<`maxim`>;
type `maxValue` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => double;
type `maxValue.maxim` <class<`list`, `maxim`> | class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, ...> => double;
type `nIter` <class<`list`, `maxim`> | class<`summary.maxLik`>, ...> => double;
type `nIter.default` <class<`list`, `maxim`> | class<`summary.maxLik`>, ...> => double;
type `nObs.maxLik` <class<`list`, `maxLik`, `maxim`>, ...> => integer;
type `nParam.maxim` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, logical, ...> => integer;
type `numericGradient` <class<`function`>, double[], double, any, ...> => class<`matrix`>;
type `numericHessian` <class<`function`>, class<`function`> | null, double[], double, any, ...> => class<`matrix`>;
type `numericNHessian` <class<`function`>, double[], double, any, ...> => class<`matrix`>;
type `objectiveFn` <class<`list`, `maxim`> | class<`maxim`>, ...> => class<`function`>;
type `objectiveFn.maxim` <class<`list`, `maxim`> | class<`maxim`>, ...> => class<`function`>;
type `observationGradient` <class<`matrix`> | double[], any> => logical;
type `openParam` <class<`MaxControl`>> => character[];
type `prepareFixed` <double[], logical[] | null, null | double | logical[] | character> => logical[];
type `print.summary.maxim` <class<`list`, `summary.maxim`>, ...> => null;
type `print.summary.maxLik` <class<`summary.maxLik`>, integer, ...> => null;
type `returnCode` <class<`list`, `maxim`> | class<`summary.maxLik`>, ...> => double;
type `returnCode.default` <class<`summary.maxLik`>, ...> => double;
type `returnCode.maxim` <class<`list`, `maxim`>, ...> => double;
type `returnMessage` <class<`list`, `maxim`> | class<`summary.maxLik`>, ...> => character;
type `returnMessage.default` <class<`summary.maxLik`>, ...> => character;
type `returnMessage.maxim` <class<`list`, `maxim`>, ...> => character;
type `stdEr.maxLik` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, any, ...> => (double[] | null);
type `sumGradients` <class<`matrix`> | double[], any> => ^double[];
type `summary.maxim` <class<`list`, `maxim`> | class<`maxim`>, logical, logical, ...> => class<`list`, `summary.maxim`>;
type `summary.maxLik` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, double, ...> => class<`summary.maxLik`>;
type `sumt` <class<`function`>, null, null, double[], class<`function`>, list<class<`matrix`> | double>, double, double, double, null, double, double, double, ...> => class<`list`, `maxim`>;
type `vcov.maxLik` <class<`list`, `maxLik`, `maxim`> | class<`maxLik`, `maxim`>, any, ...> => (class<`matrix`> | null);
