type `_fseq` <struct<`City`:character[], `value`:double[], `_order`:integer[]>> => struct<`City`:character[], `N`:integer[], `.rank`:double[]>;
type `::` <^logical[] | ^character[], ^character[], character[], character[]> => character[];
type `[[` <struct<`City`:character[], `value`:double[], `_order`:integer[]>> => struct<`City`:character[], `N`:integer[]>;
type `%<->%` <symbol, symbol> => null;
type `%implies%` <logical[], logical[]> => logical[];
type `%notchin%` <character, character[]> => logical;
type `%notin%` <character[], integer[]> => logical[];
type `%pin%` <character[], character[]> => logical[];
type `ahull` <null, double[], double[], double, double, character, logical> => struct<`x_stalactite`:integer, `h`:double, `w`:double, `xmin`:double, `xmax`:double, `area`:double, `negative`:logical, `ymin`:double, `ymax`:double>;
type `all_same_sign` <null | character | double[]> => logical;
type `any_grepl` <character[], character, logical, logical, logical, logical> => logical;
type `areTrueFalse` <logical> => logical[];
type `average_bearing` <double, double, null | character | double> => double;
type `average_bearing_n` <integer[]> => double;
type `coalesce` <^double[], ^double[]> => double[];
type `Cos` <integer[] | double> => double[];
type `definitely_sorted` <struct<`x`:integer[], `y`:integer[]>, symbol, logical, language, symbol> => logical;
type `drop_col` <struct<`B`:integer[], `C`:integer[]>, character, logical> => struct<`B`:integer[], `C`:integer[]>;
type `drop_colr` <struct<`year`:integer[], `month`:integer[], `day`:integer[], `dep_time`:^integer[], `sched_dep_time`:integer[], `dep_delay`:^double[], `arr_time`:^integer[], `sched_arr_time`:integer[], `arr_delay`:^double[], `carrier`:character[], `flight`:integer[], `tailnum`:^character[], `origin`:character[], `dest`:character[], `air_time`:^double[], `distance`:double[], `hour`:double[], `minute`:double[], `time_hour`:double[]>, character, null | logical, logical> => struct<`year`:integer[], `month`:integer[], `day`:integer[], `dep_delay`:^double[], `arr_delay`:^double[], `carrier`:character[], `flight`:integer[], `tailnum`:^character[], `origin`:character[], `dest`:character[], `distance`:double[], `hour`:double[], `minute`:double[]>;
type `drop_cols` <struct<`C`:integer[]>, character[], logical> => struct<`C`:integer[]>;
type `drop_constant_cols` <struct<`month`:integer[], `day`:integer[], `dep_time`:^integer[], `sched_dep_time`:integer[], `dep_delay`:^double[], `arr_time`:^integer[], `sched_arr_time`:integer[], `arr_delay`:^double[], `carrier`:character[], `flight`:integer[], `tailnum`:^character[], `dest`:character[], `air_time`:^double[], `distance`:double[], `hour`:double[], `minute`:double[], `time_hour`:double[]>, logical> => struct<`month`:integer[], `day`:integer[], `dep_time`:^integer[], `sched_dep_time`:integer[], `dep_delay`:^double[], `arr_time`:^integer[], `sched_arr_time`:integer[], `arr_delay`:^double[], `carrier`:character[], `flight`:integer[], `tailnum`:^character[], `dest`:character[], `air_time`:^double[], `distance`:double[], `hour`:double[], `minute`:double[], `time_hour`:double[]>;
type `drop_empty_cols` <struct<`tailnum`:character[], `year`:^integer[], `type`:character[], `manufacturer`:character[], `model`:character[], `engines`:integer[], `seats`:integer[], `engine`:character[]>, logical> => struct<`tailnum`:character[], `year`:^integer[], `type`:character[], `manufacturer`:character[], `model`:character[], `engines`:integer[], `seats`:integer[], `engine`:character[]>;
type `drop_grep` <struct<`x1`:double, `x2`:double, `y`:double>, character, null, logical> => struct<`y`:double>;
type `duplicated_rows` <struct<`x`:integer[], `y`:integer[], `z`:integer[]>, character[], logical, logical, logical, logical> => struct<`x`:integer[], `y`:integer[], `z`:integer[]>;
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => character;
type `FUN` <^character[] | ^double[]> => ^double[];
type `haversine_distance` <double[], double[], double[], double[]> => double[];
type `mutate_ntile` <struct<`x`:integer[], `y`:integer[], `xDecile`:integer[]>, character, double, null, null | character, null, null, logical, logical, logical> => struct<`x`:integer[], `y`:integer[], `xDecile`:integer[]>;
type `mutate_other` <struct<`City`:character[], `value`:double[]>, character, double, null, null, null | character, null | double, logical, character> => struct<`City`:character[], `value`:double[]>;
type `ngrep` <character, character[], logical, null> => character[] | integer[];
type `RQ` <character, null, struct<`year`:integer[], `month`:integer[], `day`:integer[], `arr_delay`:^double[]>> => struct<`year`:integer[], `month`:integer[], `day`:integer[], `arr_delay`:^double[]>;
type `samp` <integer[], double, logical, logical, null> => integer[];
type `select_grep` <struct<`x1`:double, `x2`:double, `y`:double>, character, null | character, null | character, logical, logical, logical, logical, logical, logical> => struct<`x1`:double, `x2`:double>;
type `select_which` <struct<`x`:integer[], `y`:character[], `AB`:^logical[]>, any => any, character, logical> => struct<`AB`:^logical[], `y`:character[]>;
type `selector` <struct<`year`:integer[], `month`:integer[], `day`:integer[], `dep_time`:^integer[], `sched_dep_time`:integer[], `dep_delay`:^double[], `arr_time`:^integer[], `sched_arr_time`:integer[], `arr_delay`:^double[], `carrier`:character[], `flight`:integer[], `tailnum`:^character[], `origin`:character[], `dest`:character[], `air_time`:^double[], `distance`:double[], `hour`:double[], `minute`:double[], `time_hour`:double[]>, symbol, null, logical, logical> => struct<`year`:integer[], `month`:integer[], `day`:integer[], `arr_delay`:^double[]>;
type `set_colsuborder` <struct<`x`:character[], `z`:integer[], `y`:integer[]>, character[], logical> => struct<`x`:character[], `z`:integer[], `y`:integer[]>;
type `set_local_extrema` <struct<`x`:double[], `y`:double[], `local_min`:logical[], `local_max`:logical[]>> => struct<`x`:double[], `y`:double[], `local_min`:logical[], `local_max`:logical[]>;
type `Sin` <integer[] | double> => double[];
type `Switch` <character[], double, double, null, logical> => double[];
type `weight2rows` <struct<`x`:integer[], `y`:double[]>, character, null | double, logical> => struct<`x`:integer[], `y`:double[]>;
type `weighted_ntile` <integer[], double[], double> => integer[];
