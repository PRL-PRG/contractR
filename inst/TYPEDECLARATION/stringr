type `as_bare_character` <character> => character;
type `boundary` <character, null, ...> => class<`boundary`, `character`, `pattern`>;
type `coll` <character, logical, character, ...> => class<`character`, `coll`, `pattern`>;
type `eval_interp_matches` <character[], class<`data.frame`> | environment | list<double>> => list<character>;
type `extract_expressions` <character[]> => list<expression>;
type `extract_formats` <character[]> => character[];
type `fixed` <character, logical> => class<`character`, `fixed`, `pattern`>;
type `fix_replacement` <character[] | null> => (character[] | null);
type `FUN` <..., character, character | null> => ^character[];
type `interp_placeholders` <character> => list<integer[] | character[] | integer | character>;
type `invert_match` <class<`matrix`>> => class<`matrix`>;
type `opts` <character[] | class<`character`, `pattern`, `regex`> | class<`character`, `fixed`, `pattern`> | class<`character`, `coll`, `pattern`> | class<`boundary`, `character`, `pattern`>> => (null | list<any>);
type `regex` <character, logical, logical, logical, logical, ...> => class<`character`, `pattern`, `regex`>;
type `str_c` <..., character, character | null> => ^character[];
type `str_conv` <character, character> => character;
type `str_count` <character[], character[] | class<`character`, `fixed`, `pattern`> | class<`boundary`, `character`, `pattern`>> => integer[];
type `str_detect` <^character[], class<`character`, `coll`, `pattern`> | class<`character`, `fixed`, `pattern`> | class<`character`, `pattern`, `regex`> | character[], logical> => ^logical[];
type `str_dup` <character[], double[]> => character[];
type `str_ends` <character[], character, logical> => logical[];
type `str_extract` <^character[], character[]> => ^character[];
type `str_extract_all` <^character[], character | class<`boundary`, `character`, `pattern`> | class<`character`, `pattern`, `regex`>, logical> => (class<`matrix`> | list<character[] | character[] | null>);
type `str_flatten` <character[], character> => character;
type `str_glue` <..., character, environment> => class<`character`, `glue`>;
type `str_glue_data` <class<`data.frame`>, ..., character, environment, character> => class<`character`, `glue`>;
type `str_interp` <character[], environment | class<`data.frame`> | list<double>> => character;
type `str_length` <^character[] | class<`factor`> | null> => (^integer[] | null);
type `str_locate` <character[], character[]> => class<`matrix`>;
type `str_locate_all` <character[], character[] | class<`character`, `fixed`, `pattern`>> => list<class<`matrix`>>;
type `str_match` <^character[], character | class<`character`, `pattern`, `regex`>> => class<`matrix`>;
type `str_match_all` <^character[], character> => list<class<`matrix`>>;
type `str_order` <character[], logical, logical, character, logical, ...> => integer[];
type `str_pad` <character[], double[], character[], character[]> => character[];
type `str_remove` <character[], character> => character[];
type `str_remove_all` <character[], character> => character[];
type `str_replace` <character[], character[], character[]> => character[];
type `str_replace_all` <character[], character[], any> => ^character[];
type `str_replace_na` <^character[], character> => character[];
type `str_sort` <character[], logical, logical, character, logical, ...> => character[];
type `str_split` <character[], character | class<`boundary`, `character`, `pattern`>, double, logical> => (class<`matrix`> | list<character[]>);
type `str_split_fixed` <character[], character, double> => class<`matrix`>;
type `str_squish` <character> => character;
type `str_starts` <character[], character, logical> => logical[];
type `str_sub` <character[], class<`matrix`> | double[], any> => character[];
type `str_sub<-` <character[], class<`matrix`> | double, any, logical, character[] | null> => (character[] | null);
type `str_subset` <^character[], character | class<`character`, `coll`, `pattern`>, logical> => character[];
type `str_to_lower` <character, character> => character;
type `str_to_sentence` <character, character> => character;
type `str_to_title` <character, character> => character;
type `str_to_upper` <character, character> => character;
type `str_transform_all` <character[], character, class<`function`>> => character[];
type `str_trim` <character[], character[]> => character[];
type `str_trunc` <character[], double, character[], character> => character[];
type `str_view` <character[], character, logical | null> => class<`htmlwidget`, `str_view`>;
type `str_view_all` <character[], character, null> => class<`htmlwidget`, `str_view`>;
type `str_view_widget` <character[]> => class<`htmlwidget`, `str_view`>;
type `str_which` <^character[], character, logical> => integer[];
type `str_wrap` <character, double, double, double> => character;
type `type` <character[] | class<`boundary`, `character`, `pattern`> | class<`character`, `coll`, `pattern`> | class<`character`, `fixed`, `pattern`> | class<`character`, `pattern`, `regex`>> => character;
type `type.boundary` <class<`boundary`, `character`, `pattern`>> => character;
type `type.character` <character[]> => character;
type `type.coll` <class<`character`, `coll`, `pattern`>> => character;
type `type.fixed` <class<`character`, `fixed`, `pattern`>> => character;
type `type.regex` <class<`character`, `pattern`, `regex`>> => character;
type `word` <character[], double | integer[], double | integer[], class<`character`, `fixed`, `pattern`>> => character[];
