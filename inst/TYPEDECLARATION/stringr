type `filter` <character[]> => logical[];
type `fixed` <character, logical> => character;
type `FUN` <null | character[] | ^integer[], character[], character> => null | expression | character[] | ^integer[];
type `opts` <character[]> => null | struct<`case_insensitive`:logical> | struct<`type`:character> | struct<`locale`:character, `strength`:integer>;
type `str_c` <null | ^character[], character, null | character> => ^character[];
type `str_split` <character[], character[], double, logical> => tuple<character[]> | ^character[];
type `type.character` <character[]> => character;
type `type.fixed` <character> => character;
type `::` <null | ^character[], double | environment | character[], null | character | double, logical | character> => null | list<character[]> | tuple<character[]> | ^character[] | ^integer[];
type `fix_replacement` <null | character[]> => null | character[];
type `str_replace_all` <character[], character[], null | character | null> => ^character[];
type `str_sub` <character[], ^integer[] | double[], language | double[]> => character[];
type `str_match` <^character[], character> => ^character[];
type `str_trim` <character[], character[]> => character[];
type `eval_interp_matches` <character[], environment | struct<> | struct<`value1`:double, `value2`:double>> => struct<`%s`:character> | struct<`%.2f`:character>;
type `extract_expressions` <character[]> => tuple<expression>;
type `extract_formats` <character[]> => character[];
type `interp_placeholders` <character> => struct<`indices`:integer[], `matches`:character[]>;
type `str_detect` <^character[], character[], logical> => ^logical[];
type `str_replace` <character[], character[], character[]> => character[];
type `str_split_fixed` <character[], character, double> => ^character[];
type `str_sub<-` <character[], double | ^integer[], null | integer[] | double | language, logical, null | character[]> => null | character[];
type `str_dup` <character[], double[]> => character[];
type `str_length` <null | ^character[] | integer> => null | ^integer[];
type `str_locate` <character[], character[]> => ^integer[];
type `boundary` <character, null, null> => character[];
type `coll` <character, logical, character, null> => character;
type `invert_match` <^integer[]> => ^integer[];
type `regex` <character, logical, logical, logical, logical, null> => character;
type `str_conv` <character, character> => character;
type `str_count` <character[], character[]> => integer[];
type `str_ends` <character[], character, logical> => logical[];
type `str_extract` <^character[], character[]> => ^character[];
type `str_extract_all` <^character[], character[], logical> => ^character[] | tuple<character[]> | list<character[]>;
type `str_flatten` <character[], character> => character;
type `str_glue` <character, character, environment> => character;
type `str_glue_data` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, character, character, environment, character> => character[];
type `str_interp` <character[], environment | struct<> | struct<`value1`:double, `value2`:double>> => character;
type `str_locate_all` <character[], character[]> => tuple<^integer[]>;
type `str_match_all` <^character[], character> => tuple<^character[], ^character[], ^character[], ^character[]> | list<^character[]>;
type `str_order` <character[], logical, logical, character, logical, null> => integer[];
type `str_pad` <character[], double[], character[], character[]> => character[];
type `str_remove` <character[], character> => character[];
type `str_remove_all` <character[], character> => character[];
type `str_replace_na` <^character[], character> => character[];
type `str_sort` <character[], logical, logical, character, logical, null> => character[];
type `str_squish` <character> => character;
type `str_starts` <character[], character, logical> => logical[];
type `str_subset` <^character[], character, logical> => character[];
type `str_to_lower` <character, character> => character;
type `str_to_sentence` <character, character> => character;
type `str_to_title` <character, character> => character;
type `str_to_upper` <character, character> => character;
type `str_transform_all` <character[], character, any => any> => character[];
type `str_trunc` <character[], double, character[], character> => character[];
type `str_view` <character[], character, null | logical> => struct<`x`:struct<`html`:character>, `width`:null, `height`:null, `sizingPolicy`:struct<`defaultWidth`:null, `defaultHeight`:double, `padding`:null, `viewer`:struct<`defaultWidth`:null, `defaultHeight`:null, `padding`:null, `fill`:logical, `suppress`:logical, `paneHeight`:null>, `browser`:struct<`defaultWidth`:null, `defaultHeight`:null, `padding`:null, `fill`:logical, `external`:logical>, `knitr`:struct<`defaultWidth`:null, `defaultHeight`:character, `figure`:logical>>, `dependencies`:null, `elementId`:null, `preRenderHook`:null, `jsHooks`:tuple<>>;
type `str_view_all` <character[], character, null> => struct<`x`:struct<`html`:character>, `width`:null, `height`:null, `sizingPolicy`:struct<`defaultWidth`:null, `defaultHeight`:double, `padding`:null, `viewer`:struct<`defaultWidth`:null, `defaultHeight`:null, `padding`:null, `fill`:logical, `suppress`:logical, `paneHeight`:null>, `browser`:struct<`defaultWidth`:null, `defaultHeight`:null, `padding`:null, `fill`:logical, `external`:logical>, `knitr`:struct<`defaultWidth`:null, `defaultHeight`:character, `figure`:logical>>, `dependencies`:null, `elementId`:null, `preRenderHook`:null, `jsHooks`:tuple<>>;
type `str_view_widget` <character[]> => struct<`x`:struct<`html`:character>, `width`:null, `height`:null, `sizingPolicy`:struct<`defaultWidth`:null, `defaultHeight`:double, `padding`:null, `viewer`:struct<`defaultWidth`:null, `defaultHeight`:null, `padding`:null, `fill`:logical, `suppress`:logical, `paneHeight`:null>, `browser`:struct<`defaultWidth`:null, `defaultHeight`:null, `padding`:null, `fill`:logical, `external`:logical>, `knitr`:struct<`defaultWidth`:null, `defaultHeight`:character, `figure`:logical>>, `dependencies`:null, `elementId`:null, `preRenderHook`:null, `jsHooks`:tuple<>>;
type `str_which` <^character[], character, logical> => integer[];
type `str_wrap` <character, double, double, double> => character;
type `type.boundary` <character[]> => character;
type `type.coll` <character> => character;
type `type.regex` <character> => character;
type `word` <character[], double | integer[], double | integer[], character> => character[];
