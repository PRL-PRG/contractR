type `filter` <character[]> => logical[];
type `-.rle` <struct<`lengths`:integer[], `values`:double[]>, ??? | struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `!.rle` <struct<`lengths`:integer[], `values`:logical[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `!=.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `.check_lengths` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => null;
type `.Deprecate_method` <character, character> => ? character;
type `.Deprecate_once` <character> => ? character;
type `.recurse_summation` <symbol | language, double> => tuple<symbol>;
type `.run_mul` <integer, integer> => integer[];
type `[.wmatrix` <^double[], integer[] | ???, ??? | integer, ???, logical> => ^double[];
type `[<-.wmatrix` <^double[], double, ???, ???, integer[]> => ^double[];
type `*.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `/.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `&.rle` <struct<`lengths`:integer[], `values`:logical[]>, struct<`lengths`:integer[], `values`:logical[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `%/%.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `%%.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `^.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `+.rle` <struct<`lengths`:integer[], `values`:double[]>, ??? | struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `<.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `<=.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `==.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `>.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `>=.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `|.rle` <struct<`lengths`:integer[], `values`:logical[]>, struct<`lengths`:integer[], `values`:logical[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `all.rle` <struct<`lengths`:integer[], `values`:logical[]>, logical> => logical;
type `any.rle` <struct<`lengths`:integer[], `values`:logical[]>, logical> => logical;
type `append_rhs.formula` <language, language | tuple<symbol>, logical> => language;
type `as.linwmatrix.logwmatrix` <^double[], ???> => ^double[];
type `as.linwmatrix.matrix` <^double[], null, ???> => ^double[];
type `as.logwmatrix.linwmatrix` <^double[], ???> => ^double[];
type `as.logwmatrix.matrix` <^double[], null, ???> => ^double[];
type `as.rle.rle` <struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `binop.rle` <struct<`lengths`:integer[], `values`:double[]>, struct<`lengths`:integer[], `values`:double[]>, any => any> => struct<`lengths`:integer[], `values`:double[]>;
type `c.rle` <struct<`lengths`:integer[], `values`:logical[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `colMeans.mcmc.list` <struct<`line1`:^double[], `line2`:^double[]>, ???> => double[];
type `compact.rle` <struct<`lengths`:integer[], `values`:double[]>> => struct<`lengths`:integer[], `values`:double[]>;
type `compress_rows.linwmatrix` <^double[], ???> => ^double[];
type `compress_rows.logwmatrix` <^double[], ???> => ^double[];
type `compress.data.frame` <struct<`V1`:integer[], `V2`:integer[], `V3`:integer[]>> => struct<`rows`:struct<`V1`:integer[], `V2`:integer[], `V3`:integer[]>, `frequencies`:double[], `ordering`:integer[], `rownames`:character[]>;
type `control.remap` <struct<`a.x`:double, `a.y`:double>, character, character> => struct<`a.x`:double, `a.y`:double, `b.x`:double, `b.y`:double>;
type `decompress.data.frame` <struct<`rows`:struct<`V1`:integer[], `V2`:integer[], `V3`:integer[]>, `frequencies`:double[], `ordering`:integer[], `rownames`:character[]>> => struct<`V1`:integer[], `V2`:integer[], `V3`:integer[]>;
type `despace` <character> => character;
type `eval_lhs.formula` <language> => double;
type `EVL` <language> => double;
type `filter_rhs.formula` <language, any => any, character | ???> => language;
type `forkTimeout` <language, double, language, null> => ? logical;
type `FUN` <double[], logical> => ^double[];
type `innermsg` <character> => null;
type `is.na.rle` <struct<`lengths`:integer[], `values`:^double[]>> => struct<`lengths`:integer[], `values`:logical[]>;
type `lapply.mcmc.list` <struct<`line1`:^double[], `line2`:^double[]>, any => any, ???> => struct<`line1`:^double[], `line2`:^double[]>;
type `length.rle` <struct<`lengths`:integer[], `values`:double[]>> => double;
type `list_rhs.formula` <language> => tuple<symbol, symbol>;
type `log_mean_exp` <double[], logical> => double;
type `log_sum_exp` <double[], logical> => double;
type `lweighted.mean` <^double[], double[]> => double[];
type `lweighted.var` <^double[], double[]> => ^double[];
type `mean.rle` <struct<`lengths`:integer[], `values`:double[]>, logical, ???> => double;
type `message_print` <integer[], null> => null;
type `msg` <character> => null;
type `msg2s` <character> => null;
type `msg3` <character> => null;
type `NVL` <? language | symbol> => ? double[] | symbol;
type `NVL<-` <? double, double> => double;
type `NVL2` <? double, character, character> => character;
type `NVL3` <? double, character | language, character> => character | double;
type `once` <symbol, double, double> => any => any;
type `order.data.frame` <struct<`V1`:integer[], `V2`:integer[], `V3`:integer[]>, logical, logical> => integer[];
type `order.default` <integer[], logical, logical> => integer[];
type `order.matrix` <^double[], logical, logical> => integer[];
type `persistEvalQ` <language, double, language, environment, environment, logical> => double;
type `rep.rle` <struct<`lengths`:integer[], `values`:double[]>, integer[], character, logical> => struct<`lengths`:integer[], `values`:double[]>;
type `rowweights.logwmatrix` <^double[], ???> => double[];
type `rowweights<-.matrix` <^double[], ???, double[]> => ^double[];
type `set.control.class` <character, struct<`a.x`:double, `a.y`:double>> => struct<`a.x`:double, `a.y`:double>;
type `sort.data.frame` <struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, logical, ???> => struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>;
type `sum.rle` <struct<`lengths`:integer[], `values`:double[]>, logical> => double;
type `sweep_cols.matrix` <^double[], double[], logical> => ^double[];
type `sweep.mcmc.list` <struct<`line1`:^double[], `line2`:^double[]>, integer[], character, logical, ???> => struct<`line1`:^double[], `line2`:^double[]>;
type `ult` <character[] | integer[] | language, double> => character | integer | language;
type `ult<-` <double[] | language, double, double | language> => double[] | language;
type `unwhich` <integer[], double> => logical[];
type `vector.namesmatch` <struct<`c`:double, `b`:double, `a`:double>, character[], null> => struct<`a`:double, `c`:double, `b`:double>;
