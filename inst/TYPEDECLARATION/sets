type `.apply_connector_to_list_of_gsets_and_support` <tuple<tuple<double>, tuple<double>> | tuple<list<double>, list<double>, list<double>> | tuple<list<tuple<double>>, tuple<tuple<double>>> | tuple<tuple<character>, tuple<character>>, list<character> | tuple<double, double> | list<double> | list<tuple<double>> | tuple<character>, any => any, any => any, logical> => double[] | tuple<double[]>;
type `.as.character` <list<character | double> | list<double> | tuple<tuple<character>, tuple<integer>, tuple<double>, tuple<double>> | list<tuple<double>> | tuple<character> | tuple<double> | tuple<tuple<double>> | character[] | tuple<any => any, character> | list<character> | list<tuple<character, character>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>>, null> => character[];
type `.as.gset.atomic` <character[] | double[], any => any> => tuple<character, character, character, character> | tuple<double>;
type `.as.list.cset` <tuple<character, character, character, character, character> | tuple<character, double> | tuple<double, double> | list<double>, null> => tuple<character, character, character, character, character> | tuple<character, double> | tuple<double, double> | list<double>;
type `.as.list.default` <tuple<> | tuple<any => any, character, double> | tuple<character> | list<character> | ^character[] | list<character | double> | tuple<double> | list<double> | ^double[] | tuple<tuple<character>, tuple<integer>, tuple<double>, tuple<double>> | list<tuple<character, character>> | tuple<tuple<character, double>, tuple<character, double, double>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<tuple<tuple<double, double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>>, null> => tuple<> | tuple<any => any, character, double> | tuple<character> | list<character> | list<null | character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<character>, tuple<integer>, tuple<double>, tuple<double>> | list<tuple<character, character>> | tuple<tuple<character, double>, tuple<character, double, double>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<tuple<tuple<double, double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>>;
type `.bounds` <logical, logical> => character;
type `.canonicalize_interval` <null, logical>=> null;
type `.canonicalize_memberships` <double[] | tuple<double[]> | tuple<tuple<double>>> => double[] | tuple<tuple<double>>;
type `.cartesian_product` <tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<double[], double[]>> => tuple<list<character>, list<character>> | tuple<list<double>, list<double>>;
type `.check_matchfun` <tuple<tuple<character, double>, tuple<character, double, double>> | tuple<tuple<integer, double, double>, tuple<character, double, double>> | tuple<tuple<double, double>, tuple<character, integer, double, double>>> => any => any;
type `.check_orderfun` <tuple<tuple<character, double>, tuple<character, double, double>> | tuple<tuple<double, double>, tuple<character, integer, double, double>> | tuple<tuple<integer, double, double>, tuple<character, double, double>>> => any => any;
type `.create_hash` <tuple<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<character>, tuple<integer>, tuple<double>, tuple<double>> | tuple<tuple<double>> | list<tuple<double>>> => environment;
type `.domain_is_numeric` <list<double>> => logical;
type `.duplicated_by_matchfun` <tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | list<double>, any => any> => logical[];
type `.empty_interval` < > => tuple<>;
type `.exact_match` <integer, tuple<character, integer, double, double>> => null;
type `.expand` <null | list<double> | integer[]> => list<double>;
type `.expand_membership` <double | tuple<double>, logical, double, logical> => double[];
type `.format_or_class` <character | double | integer[] | tuple<> | tuple<character, double> | tuple<double> | list<integer> | tuple<tuple<tuple<double, double>>> | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>, double, null | symbol> => character;
type `.format_set_or_tuple` <tuple<> | tuple<character> | tuple<double> | list<integer>, character, character, symbol | null> => character;
type `.get_bound` <tuple<character, character, character> | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | list<double> | tuple<integer>> => double;
type `.get_memberships` <list<double> | tuple<character> | tuple<double> | double[] | tuple<> | list<character | double> | list<tuple<double>> | tuple<tuple<double>>> => double[] | tuple<tuple<double>, tuple<double>, tuple<double, double>> | tuple<tuple<double>, tuple<double, double>> | tuple<tuple<double, double>>;
type `.get_support` <tuple<character> | list<double> | tuple<double> | list<character | double> | tuple<tuple<double>> | list<tuple<double>>> => character[] | double[] | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<integer, double> | tuple<tuple<double>> | list<tuple<double>>;
type `.get_universe` <tuple<character, character, character> | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | list<double> | tuple<integer>> => tuple<character, character, character> | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | list<double>;
type `.gset_complement` <tuple<character, character, character> | tuple<character, double> | tuple<integer>, tuple<character, character, character> | tuple<character, integer, double, double, double> | tuple<integer, integer, integer, integer, integer>, double> => tuple<character, character, character> | tuple<double, double>;
type `.help` <tuple<tuple<double>, tuple<double>, tuple<double>> | tuple<> | tuple<double> | list<double> | list<tuple<double>>, tuple<tuple<double>, tuple<double>, tuple<double>> | tuple<> | tuple<double> | tuple<character, integer, double, double, double> | list<double> | list<tuple<double>>> => logical;
type `.I.` <double[], double[]> => double[];
type `.insert` <double[], double, double> => double[];
type `.interval_ops` <tuple<tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>>, symbol | any => any> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `.list_order` <character[] | tuple<any => any, character, double> | list<character> | list<character | double> | list<double> | list<tuple<character, character>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>> | tuple<character> | tuple<double> | tuple<tuple<double>>, logical, null> => integer[];
type `.list_sort` <tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>>, logical, null> => tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>;
type `.list_unique` <tuple<> | tuple<any => any, character, double> | tuple<character> | character[] | list<character> | list<character | double> | tuple<double> | list<double> | integer[] | list<tuple<character, character>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>>> => tuple<> | tuple<any => any, character, double> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | list<tuple<character, character>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>, `food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>> | struct<`X`:list<integer>, ``:character, ``:tuple<tuple<tuple<double, double>>>>;
type `.lookup_elements` <tuple<character, character, character, character>, character[], any => any> => integer[];
type `.make_cset_from_gset_and_orderfun_and_matchfun` <tuple<character, character, character, character> | tuple<character, character, double> | tuple<character, double> | tuple<double, double> | list<double>, null | integer[] | any => any, null | any => any> => tuple<character, character, character, character> | tuple<character, character, double> | tuple<character, double> | tuple<double, double> | list<double>;
type `.make_element_from_support_and_memberships` <integer, integer> => tuple<integer>;
type `.make_gset_by_support_and_memberships` <tuple<character> | list<character> | tuple<double> | list<double> | list<tuple<character, character>>, null | tuple<tuple<double, double>> | double[] | tuple<tuple<double>, tuple<double, double>> | tuple<tuple<double>, tuple<double>, tuple<double, double>>, null | tuple<character, character, character> | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | double[] | list<double>, null | symbol | double> => tuple<character> | list<character> | tuple<double> | list<double> | list<tuple<character, character>>;
type `.make_gset_from_list` <list<tuple<> | tuple<double>>> => list<tuple<> | tuple<double>>;
type `.make_gset_from_list_of_gsets_and_support_and_connector` <tuple<tuple<character>, tuple<character>> | tuple<tuple<double>, tuple<double>> | tuple<list<double>, list<double>, list<double>> | tuple<list<tuple<double>>, tuple<tuple<double>>>, tuple<character> | list<character> | tuple<double, double> | list<double> | list<tuple<double>>, any => any, any => any, logical> => tuple<> | tuple<character> | list<character> | tuple<double, double> | list<double> | list<tuple<double>>;
type `.make_gset_from_support_and_memberships` <tuple<character> | ^character[] | list<character> | ^double[] | tuple<double, double> | list<double> | list<tuple<character, character>>, tuple<double[]> | double[] | tuple<tuple<double>>, null | tuple<character, character, character> | double[] | list<double> | tuple<integer, integer, integer, integer, integer>, null | double> => tuple<character> | list<character> | tuple<double> | list<double> | list<tuple<character, character>>;
type `.make_interval_from_list_and_domain` <tuple<>, null | character> => tuple<>;
type `.make_list_of_elements_from_cset` <tuple<character, double, double>> => tuple<tuple<character>, tuple<double>, tuple<double>>;
type `.make_matchfun_from_equalityfun` <any => any> => any => any;
type `.make_set_from_list` <tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | list<tuple<character, character>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>> => tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | list<tuple<character, character>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>;
type `.make_set_of_tuples_from_list_of_lists` <tuple<list<character>, list<character>>> => list<tuple<character, character>>;
type `.make_set_with_order` <tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | list<tuple<character, character>> | tuple<tuple<double>, tuple<double>> | list<tuple<double>>, integer[]> => struct<`set`:tuple<character>, `order`:integer> | struct<`set`:tuple<character, any => any, double>, `order`:integer[]> | struct<`set`:tuple<character, character>, `order`:integer[]> | struct<`set`:list<character>, `order`:integer[]> | struct<`set`:list<character | double>, `order`:integer[]> | struct<`set`:tuple<character, double>, `order`:integer[]> | struct<`set`:tuple<double>, `order`:integer> | struct<`set`:tuple<double, double>, `order`:integer[]> | struct<`set`:list<double>, `order`:integer[]> | struct<`set`:list<tuple<character, character>>, `order`:integer[]> | struct<`set`:tuple<tuple<double>, tuple<double>>, `order`:integer[]> | struct<`set`:list<tuple<double>>, `order`:integer[]>;
type `.make_tuple_from_list` <tuple<character, character> | tuple<double, double> | list<integer> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>> => tuple<character, character> | tuple<double, double> | list<integer> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>;
type `.match` <double[], double[]> => integer[];
type `.matchfun` <tuple<character, double> | tuple<double, double> | list<double> | tuple<integer>> => null | any => any;
type `.maximal_domain` <> => character;
type `.memberships_for_support` <tuple<integer> | list<double>, tuple<integer, integer, integer, integer, integer> | double, any => any> => double[];
type `.minimal_domain` <tuple<tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>>> => character;
type `.multiplicities` <double[] | tuple<tuple<double, double, double>, tuple<double, double>, tuple<double, double>> | tuple<tuple<double, double>, tuple<double, double, double>, tuple<double, double>>> => double[];
type `.N.` <double[]> => double[];
type `.not_contained` <struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>, struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>> => logical;
type `.orderfun` <tuple<character, character, character, character, character> | tuple<character, double> | tuple<double, double> | list<double> | tuple<integer>> => null | any => any;
type `.S.` <double[], double[]> => double[];
type `.set` <null | character | double | tuple<double> | tuple<tuple<double>, tuple<double>> | struct<`antecedent`:language, `consequent`:language> | list<integer> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>> => tuple<> | tuple<character> | tuple<double> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>;
type `.set_bound` <tuple<character, character, character, character>, double> => tuple<character, character, character, character>;
type `.set_complement_using_matchfun` <tuple<> | tuple<double> | list<double> | tuple<character, double>, tuple<> | tuple<double> | list<double> | tuple<character, integer, double, double>, any => any> => tuple<> | tuple<character, integer> | tuple<double>;
type `.set_intersection` <tuple<tuple<character>, tuple<character>> | tuple<tuple<double, double>, tuple<character, integer, double, double>> | tuple<tuple<integer, double, double>, tuple<character, double, double>>, any => any> => tuple<> | tuple<character> | tuple<double, double>;
type `.set_memberships` <list<double>, double[]> => list<double>;
type `.set_universe` <tuple<character, character, character, character>, tuple<character, character, character, character, character>> => tuple<character, character, character, character>;
type `.simplify_interval` <null, logical>=> null;
type `.sort_interval` <>=> null;
type `.stop_if_memberships_are_invalid` <double[] | tuple<double[], double[], double[], double> | tuple<double[], double[], tuple<double, double>> | tuple<tuple<double>>, null | character> => null;
type `.structure` <any => any | tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | list<tuple<> | tuple<double>> | list<tuple<character, character>> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<list<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`antecedent`:language, `consequent`:language> | struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>> | struct<`name`:character, `T`:any => any, `S`:any => any, `N`:any => any, `I`:any => any, `params`:null, `meta`:struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>> | struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>, null | character[] | tuple<tuple<double, double>> | double[] | tuple<tuple<double>, tuple<double, double>> | tuple<tuple<double>, tuple<double>, tuple<double, double>> | any => any> => any => any | tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | list<tuple<> | tuple<double>> | list<tuple<character, character>> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<list<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`antecedent`:language, `consequent`:language> | struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>> | struct<`name`:character, `T`:any => any, `S`:any => any, `N`:any => any, `I`:any => any, `params`:null, `meta`:struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>> | struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>;
type `.T.` <double[], double[]> => double[];
type `[.gset` <tuple<character, character, character, character>, character[]> => tuple<character, character>;
type `[[` < > => struct<`name`:character, `T`:any => any, `S`:any => any, `N`:any => any, `I`:any => any, `params`:null, `meta`:struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>>;
type `[[.interval` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>, struct<`l`:double, `r`:double, `rc`:logical, `lc`:logical>>, integer>=> null;
type `%..%` <double, double> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `%e%` <integer, tuple<character, double, double>> => logical;
type `%is%` <list<double>, double> => double;
type `$` <double[], double[]> => double[];
type `as.character.cset` <tuple<character, character, character, character, character>, null> => character[];
type `as.cset.character` <character[]> => tuple<character, character, character, character>;
type `as.cset.ordered` <integer[]> => tuple<integer, integer>;
type `as.gset.character` <character[]> => tuple<character, character, character, character>;
type `as.gset.integer` <integer[]> => tuple<integer, integer, integer>;
type `as.gset.numeric` <double[]> => tuple<double>;
type `as.gset.ordered` <integer[]> => tuple<integer, integer>;
type `as.interval.interval` <tuple<>> => tuple<>;
type `as.interval.list` <tuple<> | tuple<double>> => tuple<> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `as.interval.NULL` <null> => tuple<>;
type `as.interval.set` <tuple<> | tuple<double>> => tuple<> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `as.list.cset` <tuple<character, character, character, character, character> | list<double>, null> => tuple<character, character, character, character, character> | list<double>;
type `as.list.gset` <tuple<character> | tuple<double> | list<double> | list<tuple<> | tuple<double>>, null> => tuple<character> | tuple<double> | list<double> | list<tuple<> | tuple<double>>;
type `as.list.set` <tuple<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, null> => tuple<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>;
type `as.list.tuple` <tuple<double, double> | list<integer> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<list<double>> | struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>, null> => tuple<double, double> | list<integer> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<list<double>> | struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>;
type `as.set` <character[] | tuple<character, character, character, character, character> | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | double[] | tuple<double, double> | list<double> | list<tuple<character, character>> | tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>> => tuple<character, character, character> | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | list<double> | tuple<integer> | list<tuple<character, character>> | tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>;
type `as.tuple.integer` <integer[]> => list<integer>;
type `as.tuple.list` <tuple<character, character> | tuple<list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>> => tuple<character, character> | tuple<list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>;
type `binary_closure` <^logical[], character[]> => ^logical[];
type `binary_reduction` <^logical[], character> => ^logical[];
type `c.interval` <>=> null;
type `c.set` <tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>> => list<tuple<double>>;
type `canonicalize_set_and_mapping` <tuple<character> | tuple<any => any, character, double> | character[] | list<character> | tuple<double> | double[] | list<double> | list<tuple<character, character>>, tuple<tuple<double, double>> | ^integer[] | tuple<character, character, character> | double[] | tuple<tuple<double>, tuple<double, double>> | tuple<tuple<double>, tuple<double>, tuple<double, double>>, null | double> => struct<`set`:tuple<character>, `mapping`:double, `order`:integer> | struct<`set`:tuple<character>, `mapping`:tuple<tuple<double, double>>, `order`:integer> | struct<`set`:tuple<character, character>, `mapping`:double[], `order`:integer[]> | struct<`set`:tuple<character, character>, `mapping`:tuple<tuple<double>, tuple<double, double>>, `order`:integer[]> | struct<`set`:tuple<character, character>, `mapping`:tuple<tuple<double, double>, tuple<double>>, `order`:integer[]> | struct<`set`:tuple<character, character, character>, `mapping`:tuple<tuple<double>, tuple<double>, tuple<double, double>>, `order`:integer[]> | struct<`set`:list<character>, `mapping`:double[], `order`:integer[]> | struct<`set`:tuple<double>, `mapping`:double, `order`:integer> | struct<`set`:tuple<double>, `mapping`:tuple<tuple<double, double>>, `order`:integer> | struct<`set`:tuple<double, double>, `mapping`:double[], `order`:integer[]> | struct<`set`:tuple<double, double>, `mapping`:tuple<tuple<double, double>, tuple<double>>, `order`:integer[]> | struct<`set`:list<double>, `mapping`:double[], `order`:integer[]> | struct<`set`:list<tuple<character, character>>, `mapping`:double[], `order`:integer[]>;
type `charfun` <double[]> => double[];
type `charfun_generator` <symbol, double> => any => any;
type `closure.set` <tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>, character[], null> => tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>;
type `colfun` <integer> => character[];
type `cset` <tuple<character, character, character, character> | character[] | tuple<character, character, double, double, double> | list<character | double> | tuple<character, double> | tuple<double, double> | double[] | list<double>, null | integer[] | any => any, null | any => any> => tuple<character, character, character, character> | tuple<character, character, double> | tuple<character, double> | tuple<double, double> | list<double>;
type `cset_bound` <tuple<character, double> | tuple<integer>> => integer;
type `cset_cardinality` <list<double> | tuple<character, double, double> | list<tuple<double>>, character[], logical | symbol> => double;
type `cset_cartesian` <tuple<character, character, character, character, character>> => list<tuple<character, character>>;
type `cset_charfun` <double | list<double>> => double | any => any;
type `cset_combn` <tuple<double, double, double>, integer> => tuple<tuple<double>, tuple<double>, tuple<double>> | tuple<tuple<double, double, double>>;
type `cset_complement` <tuple<character, double> | tuple<integer>, null | tuple<character, double, double>> => tuple<double, double>;
type `cset_contains_element` <tuple<character, double, double>, integer> => logical;
type `cset_is_empty` <tuple<character, double, double> | list<double>, logical> => logical;
type `cset_is_equal` <tuple<tuple<double>, tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>, tuple<double>>, logical> => logical;
type `cset_is_fuzzy_multiset` <list<double>> => logical;
type `cset_is_set_or_fuzzy_set` <list<double>, logical> => logical;
type `cset_is_set_or_multiset` <list<double>, logical> => logical;
type `cset_is_subset` <tuple<integer, integer, integer>, tuple<double, double, double>, logical> => logical;
type `cset_matchfun` <tuple<character, double> | tuple<double, double> | list<double>> => any => any;
type `cset_memberships` <list<double>, null> => double[];
type `cset_orderfun` <tuple<character, character, character, character, character> | tuple<character, double> | tuple<double, double> | list<double>> => any => any;
type `cset_power` <tuple<double, double, double>> => list<tuple<> | tuple<double>>;
type `cset_universe` <tuple<character, double> | tuple<integer>> => tuple<character, integer, double, double, double> | tuple<integer, integer, integer, integer, integer>;
type `cut.gset` <tuple<character, character, character, character>, double, character[], logical, null> => tuple<character, character, character>;
type `e` <integer, integer> => tuple<integer>;
type `equalityfun` <double, double> => logical;
type `ex` <tuple<character, character, character, character> | list<double> | tuple<double>> => double[];
type `f` <double[], double[]> => double[] | tuple<>;
type `F` <double[]> => double[];
type `filter` <character[]> => logical[];
type `format.cset` <tuple<character, character, character, character, character> | tuple<character, double>, null> => character;
type `format.set` <tuple<> | tuple<character> | tuple<double>, symbol | null> => character;
type `format.tuple` <tuple<double, double> | list<integer>, null> => character;
type `fun` <symbol, symbol> => struct<`name`:character, `T`:any => any, `S`:any => any, `N`:any => any, `I`:any => any, `params`:null, `meta`:struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>>;
type `FUN` <list<double> | tuple<> | tuple<double> | tuple<character> | double[] | character | struct<`antecedent`:language, `consequent`:language> | list<tuple<double>> | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical> | tuple<tuple<double>> | symbol | struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>, null | double | character[] | list<character> | tuple<double, double> | list<double> | list<tuple<double>> | tuple<character>, null | null | character[] | any => any | double, null | double, double> => null | double[] | list<double> | character | tuple<> | tuple<double> | tuple<character> | list<tuple<double>> | language | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical> | any => any | tuple<tuple<double>> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `fuzzy_inference` <struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>, struct<`service`:double, `food`:double>> => list<double>;
type `fuzzy_logic` <character | null, null> => struct<`name`:character, `T`:any => any, `S`:any => any, `N`:any => any, `I`:any => any, `params`:null, `meta`:struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>>;
type `fuzzy_logic_family` <character, any => any, any => any, any => any, any => any, null, struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>> => struct<`name`:character, `T`:any => any, `S`:any => any, `N`:any => any, `I`:any => any, `params`:null, `meta`:struct<`is_de_Morgan_triple`:logical, `N_is_standard`:logical, `T_is_continuous`:logical, `T_is_Archimedean`:logical>>;
type `fuzzy_normal` <double | symbol, double | symbol, logical | symbol, double, double | symbol> => any => any;
type `fuzzy_normal_gset` <null, double, logical, double, double, integer[]> => list<integer>;
type `fuzzy_partition` <double[], any => any, null, double> => struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>;
type `fuzzy_poisson` <double> => any => any;
type `fuzzy_rule` <language, language> => struct<`antecedent`:language, `consequent`:language>;
type `fuzzy_system` <struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>> => struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>;
type `fuzzy_trapezoid` <double[], double[], logical> => any => any;
type `fuzzy_tuple` <any => any, double[], null | double, null, null | character[]> => tuple<list<double>, list<double>, list<double>> | struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>;
type `fuzzy_variable` <any => any> => struct<`rancid`:list<double>, `delicious`:list<double>>;
type `gset` <null | tuple<character, character> | character[] | double[] | tuple<double, double>, null | double[] | tuple<double[], double[], tuple<double, double>> | tuple<double[], double[], double[], double> | tuple<tuple<double>>, null | any => any, null, null | tuple<character, integer, double, double, double> | double[] | list<double>, null | integer> => tuple<character, character> | tuple<double> | list<double>;
type `gset_bound` <tuple<character, character, character> | tuple<integer>> => double;
type `gset_cardinality` <tuple<character> | list<double> | tuple<> | list<tuple<double>>, character[], logical | symbol> => double;
type `gset_cartesian` <tuple<character, character, character, character, character>> => list<tuple<character, character>>;
type `gset_combn` <tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>, integer> => tuple<tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>>> | list<tuple<tuple<double>, tuple<double>>>;
type `gset_complement` <tuple<character, character, character> | tuple<integer>, null | tuple<character, character, character, character>> => tuple<character, character> | tuple<integer, integer, integer, integer, integer>;
type `gset_defuzzify` <list<double>, character> => double;
type `gset_difference` <tuple<character, character, character, character, character> | list<tuple<double>>> => tuple<character, character, character> | list<tuple<double>>;
type `gset_height` <list<double>, logical> => double;
type `gset_intersection` <tuple<character>> => tuple<> | tuple<character>;
type `gset_is_crisp` <double[] | tuple<character, character, character> | tuple<double> | list<double>, logical> => logical;
type `gset_is_empty` <tuple<character>, logical> => logical;
type `gset_is_equal` <tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>, tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>, logical> => logical;
type `gset_is_fuzzy_multiset` <tuple<character> | tuple<double> | list<double>> => logical;
type `gset_is_fuzzy_set` <tuple<character, character, character> | tuple<integer>, logical> => logical;
type `gset_is_multiset` <tuple<character, character, character, character, character> | list<double>, logical> => logical;
type `gset_is_set` <double | tuple<> | tuple<character> | tuple<double> | list<double> | list<tuple<double>>, logical> => logical;
type `gset_is_set_or_fuzzy_set` <list<double>, logical> => logical;
type `gset_memberships` <tuple<character, character, character, character> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>>, null | character[]> => double[] | tuple<double[], double[]>;
type `gset_peak` <list<double>, logical> => tuple<double> | list<double>;
type `gset_similarity` <tuple<character>, tuple<character>, character> => double;
type `gset_sum` <tuple<character, character, character, character, character>> => list<character>;
type `gset_support` <tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>> => tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>;
type `gset_union` <tuple<character>> => tuple<character> | list<character>;
type `gset_universe` <tuple<character, character, character> | tuple<integer>> => tuple<character, character, character> | tuple<integer, integer, integer, integer, integer>;
type `integers` <null | double, null | double> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `integers2reals` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, double, double> => tuple<struct<`l`:integer, `r`:integer, `lc`:logical, `rc`:logical>>;
type `interval` <double, double, character[], null | character> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `interval_complement` <null, null> => tuple<>;
type `interval_difference` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `interval_division` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `interval_domain` <> => character;
type `interval_intersection` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `interval_is_bounded` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_degenerate` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_empty` <tuple<>> => logical;
type `interval_is_equal` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_half_bounded` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_left_bounded` <> => logical;
type `interval_is_left_closed` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_proper_subinterval` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_right_bounded` <> => logical;
type `interval_is_right_closed` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_right_unbounded` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_subinterval` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_is_uncountable` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => logical;
type `interval_product` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `interval_sum` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `interval_union` <>=> null;
type `is_element` <double | tuple<integer>> => logical;
type `is.charfun_generator` <any => any | list<double>> => logical;
type `is.cset` <double | tuple<> | tuple<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>> => logical;
type `is.gset` <integer | tuple<character, double, double>> => logical;
type `is.interval` <double[] | tuple<character, integer, double, double, double> | list<double>> => logical;
type `is.set` <tuple<character, double, double>> => logical;
type `is.tuple` <integer | tuple<character, character, character, character> | tuple<double> | list<double> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>>> => logical;
type `LABEL.character` <character, null, logical, null> => character;
type `LABEL.integer` <integer[], null, null | symbol> => character;
type `LABEL.list` <tuple<tuple<tuple<double, double>>> | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>, null, null | symbol> => character;
type `LABEL.numeric` <double, null, null | symbol> => character;
type `LABEL.set` <tuple<> | tuple<character, double> | tuple<double>, null | double, symbol | null> => character;
type `LABEL.tuple` <tuple<double, double> | list<integer>, null | double, null> => character;
type `LABELS` <integer[] | list<integer> | list<tuple<> | tuple<double>> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<``:double, ``:character, `X`:character, ``:integer[]> | struct<`x1`:tuple<character, character>, `x2`:tuple<character, character>, `x3`:tuple<character, character>, `x4`:tuple<character, character>, `x5`:tuple<character, character>, `x6`:tuple<character, character>, `x7`:tuple<character, character>, `x8`:tuple<character, character>, `x9`:tuple<character, character, character>, `x10`:tuple<character, character, character>, `x11`:tuple<character, character, character>, `x12`:tuple<character, character, character>, `x13`:tuple<character, character, character>, `x14`:tuple<character>, `x15`:tuple<character, character>, `x16`:tuple<character>, `x17`:tuple<character, character>, `x18`:tuple<character, character>, `x19`:tuple<character>, `x20`:tuple<character, character>, `x21`:tuple<character, character>, `x22`:tuple<character, character>, `x23`:tuple<character, character>, `x24`:tuple<character, character>, `x25`:tuple<character, character, character>, `x26`:tuple<character, character, character>, `x27`:tuple<character, character>, `x28`:tuple<character, character>, `x29`:tuple<character, character>, `x30`:tuple<character, character>> | tuple<character> | tuple<double> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, null, character, logical, null | double, symbol | null> => character[];
type `length.cset` <list<double>> => integer;
type `length.gset` <tuple<double>> => integer;
type `length.interval` <tuple<>> => integer;
type `length.set` <^character[] | ^double[] | tuple<> | tuple<character> | list<character> | list<character | double> | tuple<double> | list<double> | tuple<tuple<character>, tuple<integer>, tuple<double>, tuple<double>> | list<tuple<character, character>> | tuple<tuple<double>> | list<tuple<double>> | tuple<tuple<tuple<double, double>>> | struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical> | tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>> => integer;
type `lines.gset` <list<double>, character, character | double, logical, list<double>, character | null> => list<double>;
type `lines.tuple` <tuple<list<double>>, character[] | double, symbol, character> => tuple<list<double>>;
type `make_set_with_order.character` <character[]> => struct<`set`:tuple<character, character, character>, `order`:integer[]>;
type `make_set_with_order.gset` <tuple<character, character, character, character, character>> => struct<`set`:tuple<character, character, character, character, character>, `order`:integer[]>;
type `make_set_with_order.integer` <integer[]> => struct<`set`:tuple<integer>, `order`:integer> | struct<`set`:tuple<integer, integer, integer>, `order`:integer[]> | struct<`set`:list<integer>, `order`:integer[]>;
type `make_set_with_order.list` <tuple<character> | tuple<any => any, character, double> | list<character | double> | tuple<double> | list<double> | list<tuple<character, character>> | tuple<tuple<double>, tuple<double>> | list<tuple<double>>> => struct<`set`:tuple<character>, `order`:integer> | struct<`set`:tuple<character, any => any, double>, `order`:integer[]> | struct<`set`:tuple<character, character>, `order`:integer[]> | struct<`set`:list<character | double>, `order`:integer[]> | struct<`set`:tuple<character, double>, `order`:integer[]> | struct<`set`:tuple<double>, `order`:integer> | struct<`set`:tuple<double, double>, `order`:integer[]> | struct<`set`:list<double>, `order`:integer[]> | struct<`set`:list<tuple<character, character>>, `order`:integer[]> | struct<`set`:tuple<tuple<double>, tuple<double>>, `order`:integer[]> | struct<`set`:list<tuple<double>>, `order`:integer[]>;
type `make_set_with_order.numeric` <double[]> => struct<`set`:tuple<double>, `order`:integer> | struct<`set`:tuple<double, double>, `order`:integer[]> | struct<`set`:list<double>, `order`:integer[]>;
type `make_set_with_order.ordered` <integer[]> => struct<`set`:tuple<integer, integer>, `order`:integer[]>;
type `make_set_with_order.set` <tuple<character> | list<character> | tuple<double, double> | list<double> | list<tuple<double>>> => struct<`set`:tuple<character>, `order`:integer> | struct<`set`:tuple<character, character>, `order`:integer[]> | struct<`set`:list<character>, `order`:integer[]> | struct<`set`:tuple<character, integer, double, double, double>, `order`:integer[]> | struct<`set`:tuple<double, double>, `order`:integer[]> | struct<`set`:list<double>, `order`:integer[]> | struct<`set`:list<tuple<double>>, `order`:integer[]>;
type `matchfun` <any => any | list<character> | list<double> | list<tuple<double>> | tuple<> | list<character | double> | double | tuple<character> | tuple<double> | tuple<tuple<integer>>, tuple<character> | character[] | tuple<double> | double[] | tuple<tuple<double>> | tuple<> | list<character | double> | list<double> | list<tuple<double>> | tuple<tuple<character>, tuple<integer>, tuple<double>, tuple<double>>> => null | any => any | ^integer[];
type `max.interval` <> => double;
type `mean.gset` <list<double> | tuple<integer, integer, integer>, null, logical> => double;
type `mean.interval` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `mean.set` <tuple<double> | list<double>, null> => double;
type `median.gset` <tuple<integer, integer, integer>, logical, null> => double;
type `min.interval` <> => double;
type `N` <integer[]> => double[];
type `naturals` <null, null> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `naturals0` <null, null> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `Ops_gset` <tuple<character, character, character, character, character> | tuple<tuple<double>, tuple<double>, tuple<double>>, tuple<character, character, character, character> | tuple<tuple<double>, tuple<double>, tuple<double>>, character, symbol> => list<tuple<character, character>> | logical;
type `Ops_set` <tuple<tuple<double>, tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>, tuple<double>>, character, symbol> => logical;
type `Ops.cset` <double | tuple<character, character, character, character, character> | tuple<integer, integer, integer> | tuple<tuple<double>, tuple<double>, tuple<double>>, tuple<double, double, double> | tuple<character, character, character, character> | tuple<tuple<double>, tuple<double>, tuple<double>>> => list<tuple<> | tuple<double>> | list<tuple<character, character>> | logical;
type `Ops.interval` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>> | integer> => tuple<> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>> | logical;
type `pair` <double> => tuple<double, double>;
type `plot.fuzzy_system` <struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>, any => any, null> => struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>;
type `plot.fuzzy_variable` <struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>, double, character> => struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>>;
type `plot.tuple` <struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>> | tuple<list<double>>, character, null | double, character, character, character[] | double, logical, character | null> => struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>> | struct<`rancid`:list<double>, `delicious`:list<double>> | tuple<list<double>>;
type `print.cset` <tuple<character, character, character, character, character> | tuple<character, double>, null> => tuple<character, character, character, character, character> | tuple<character, double>;
type `print.fuzzy_rule` <struct<`antecedent`:language, `consequent`:language>, null> => struct<`antecedent`:language, `consequent`:language>;
type `print.fuzzy_system` <struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>, null> => struct<`variables`:struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>, `rules`:tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>>>;
type `print.gset` <tuple<character, character, character, character, character> | tuple<character, double>, null> => tuple<character, character, character, character, character> | tuple<character, double>;
type `print.set` <tuple<character>, null> => tuple<character>;
type `range.interval` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => double[];
type `reals` <null | double, null | double, character[]> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `reals2integers` <tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>> => tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>;
type `reduction.set` <tuple<tuple<>, tuple<double>, tuple<double>, tuple<double>> | list<tuple<double>>, character[] | tuple<double[]> | logical, null> => tuple<tuple<double>, tuple<double>, tuple<double>>;
type `rep.gset` <tuple<character, character, character, character>, double> => tuple<character, character, character, character>;
type `set` <null | character | double | tuple<double> | struct<`antecedent`:language, `consequent`:language> | list<integer> | struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>> => tuple<> | tuple<character> | tuple<double> | tuple<tuple<character, double>, tuple<double, double>, list<integer>> | tuple<tuple<double>> | tuple<struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>, struct<`antecedent`:language, `consequent`:language>> | struct<``:character, ``:tuple<tuple<tuple<double, double>>>, `X`:list<integer>> | struct<`food`:struct<`rancid`:list<double>, `delicious`:list<double>>, `tip`:struct<`cheap`:list<double>, `average`:list<double>, `generous`:list<double>>, `service`:struct<`poor`:list<double>, `good`:list<double>, `excellent`:list<double>>>;
type `set_cardinality` <tuple<> | tuple<character> | list<character | double> | tuple<double> | list<double> | list<tuple<double>>> => integer;
type `set_complement` <tuple<> | tuple<double> | list<double> | tuple<character, double>, tuple<> | tuple<double> | list<double> | tuple<character, integer, double, double>> => tuple<> | tuple<character, integer> | tuple<double>;
type `set_contains_element` <tuple<character, integer, double, double>, integer> => logical;
type `set_intersection` <tuple<character, integer, double, double, double>> => tuple<double, double>;
type `set_is_empty` <tuple<> | tuple<character> | list<character | double> | tuple<double> | list<double> | list<tuple<double>>> => logical;
type `set_is_equal` <tuple<tuple<double>, tuple<double>, tuple<double>>, tuple<tuple<double>, tuple<double>, tuple<double>>> => logical;
type `set_is_subset` <tuple<double, double> | list<double> | tuple<integer>, tuple<character, integer, double, double, double> | list<double> | tuple<double, double, double>> => logical;
type `set_outer` <tuple<double, double> | struct<`x1`:tuple<character, character>, `x2`:tuple<character, character>, `x3`:tuple<character, character>, `x4`:tuple<character, character>, `x5`:tuple<character, character>, `x6`:tuple<character, character>, `x7`:tuple<character, character>, `x8`:tuple<character, character>, `x9`:tuple<character, character, character>, `x10`:tuple<character, character, character>, `x11`:tuple<character, character, character>, `x12`:tuple<character, character, character>, `x13`:tuple<character, character, character>, `x14`:tuple<character>, `x15`:tuple<character, character>, `x16`:tuple<character>, `x17`:tuple<character, character>, `x18`:tuple<character, character>, `x19`:tuple<character>, `x20`:tuple<character, character>, `x21`:tuple<character, character>, `x22`:tuple<character, character>, `x23`:tuple<character, character>, `x24`:tuple<character, character>, `x25`:tuple<character, character, character>, `x26`:tuple<character, character, character>, `x27`:tuple<character, character>, `x28`:tuple<character, character>, `x29`:tuple<character, character>, `x30`:tuple<character, character>> | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>> | list<tuple<> | tuple<double>>, tuple<double, double, double> | any => any | tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>, null | character | any => any, null, logical, logical> => ^double[] | list<tuple<double>> | tuple<tuple<struct<`l`:double, `r`:double, `lc`:logical, `rc`:logical>>>;
type `set_union` <tuple<character, integer, double, double, double>> => list<character | double>;
type `sets_options` <character, null | character | any => any | null | double[]> => null | character | any => any | double[];
type `transform_rule` <language> => language;
type `triple` <double> => tuple<double, double, double>;
type `tuple` <double | tuple<character, character, character, character, character> | list<double>> => tuple<double, double> | tuple<tuple<character, character, character, character, character>, tuple<character, character, character, character>> | tuple<list<double>>;
type `tuple_outer` <integer[] | tuple<double, double>, integer[] | tuple<double, double, double>, character, null, logical, logical> => ^double[];
