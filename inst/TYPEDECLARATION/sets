type `[[` <any, any, any, double, any> => class<`function`>;
type `%..%` <double | null, double | null> => class<`interval`>;
type `.apply_connector_to_list_of_gsets_and_support` <list<any>, class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | integer[] | double, class<`function`>, class<`function`>, logical> => (double[] | list<double[]>);
type `.as.character` <list<any>> => character[] | <character[] | list<any>, ...> => character[];
type `as.character.cset` <class<`cset`>, ...> => character[];
type `as.cset` <class<`factor`, `ordered`> | character[]> => (class<`cset`> | class<`cset`, `gset`>);
type `as.cset.character` <character[]> => (class<`cset`> | class<`cset`, `gset`>);
type `as.cset.ordered` <class<`factor`, `ordered`>> => class<`cset`>;
type `as.gset` <character[] | class<`cset`, `gset`> | class<`factor`, `ordered`> | class<`cset`, `gset`, `set`> | double[] | list<class<`matrix`>>> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.as.gset.atomic` <character[] | class<`factor`, `ordered`> | double[], class<`function`>> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `as.gset.character` <character[]> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `as.gset.integer` <integer[]> => class<`cset`, `gset`, `set`>;
type `as.gset.list` <list<class<`matrix`>>> => class<`cset`, `gset`>;
type `as.gset.numeric` <double[]> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `as.gset.ordered` <class<`factor`, `ordered`>> => class<`cset`, `gset`>;
type `as.interval` <class<`interval`> | class<`cset`, `gset`, `set`> | double | null | list<any>> => class<`interval`>;
type `as.interval.interval` <class<`interval`>> => class<`interval`>;
type `as.interval.list` <list<any>> => class<`interval`>;
type `as.interval.NULL` <null> => class<`interval`>;
type `as.interval.numeric` <double> => class<`interval`>;
type `as.interval.set` <class<`cset`, `gset`, `set`>> => class<`interval`>;
type `.as.list` <class<`cset`, `gset`, `set`> | class<`cset`> | class<`cset`, `gset`> | ^character[] | class<`factor`, `ordered`> | class<`tuple`> | ^double[] | class<`table`> | list<any>, ...> => list<any>;
type `.as.list.cset` <class<`cset`>, ...> => list<character | character | double | double>;
type `as.list.cset` <class<`cset`>, ...> => list<character | double>;
type `.as.list.default` <^character[] | class<`factor`, `ordered`> | class<`tuple`> | ^double[] | class<`table`> | list<any>, ...> => list<any>;
type `as.list.gset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, ...> => list<any>;
type `as.list.set` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, ...> => list<any>;
type `as.list.tuple` <class<`tuple`> | class<`fuzzy_variable`, `tuple`>, ...> => list<class<`charfun_generator`> | class<`cset`, `gset`> | double>;
type `as.set` <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | double[] | list<any>> => class<`cset`, `gset`, `set`>;
type `as.tuple` <integer[] | list<class<`cset`, `gset`> | character | integer>> => class<`tuple`>;
type `as.tuple.integer` <integer[]> => class<`tuple`>;
type `as.tuple.list` <list<character | class<`cset`, `gset`> | integer>> => class<`tuple`>;
type `binary_closure` <class<`matrix`>, character[]> => class<`matrix`>;
type `binary_reduction` <class<`matrix`>, character> => class<`matrix`>;
type `.bounds` <logical, logical> => character;
type `.canonicalize_interval` <list<list<double>>, logical> => list<list<double>>;
type `.canonicalize_memberships` <class<`table`> | double[] | list<any>> => (class<`table`> | double[] | list<any>);
type `canonicalize_set_and_mapping` <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double[] | list<any>, class<`matrix`> | class<`table`> | double[] | list<character | class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, double | null> => list<any>;
type `.cartesian_product` <list<double[] | class<`cset`, `gset`, `set`> | list<character>>> => list<list<character | double>>;
type `charfun_generator` <any, double> => class<`charfun_generator`>;
type `.check_matchfun` <list<any>> => class<`function`>;
type `.check_orderfun` <list<any>> => class<`function`>;
type `c.interval` <...> => class<`interval`>;
type `closure` <class<`cset`, `gset`, `set`>, any, ...> => class<`cset`, `gset`, `set`>;
type `closure.set` <class<`cset`, `gset`, `set`>, character[], ...> => class<`cset`, `gset`, `set`>;
type `.create_hash` <list<any>> => (environment | null);
type `cset` <class<`cset`, `gset`> | character[] | class<`cset`, `gset`, `set`> | double[], integer[] | class<`function`> | null, null | class<`function`>> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `c.set` <...> => class<`cset`, `gset`, `set`>;
type `cset_bound` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`>> => double;
type `cset_cardinality` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`>, character[], any> => double;
type `cset_cartesian` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `cset_charfun` <double> => double | <class<`cset`>> => class<`cset_charfun`>;
type `cset_combn` <class<`cset`, `gset`, `set`>, integer> => class<`cset`, `gset`, `set`>;
type `cset_complement` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`> | null> => (class<`cset`> | class<`cset`, `gset`>);
type `cset_contains_element` <class<`cset`>, integer> => logical;
type `cset_difference` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `cset_intersection` <...> => (class<`cset`> | class<`cset`, `gset`>);
type `cset_is_empty` <class<`cset`> | class<`cset`, `gset`>, logical> => logical;
type `cset_is_equal` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `cset_is_fuzzy_multiset` <class<`cset`, `gset`>> => logical;
type `cset_is_multiset` <class<`cset`, `gset`>, logical> => logical;
type `cset_is_proper_subset` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `cset_is_set_or_fuzzy_set` <class<`cset`, `gset`>, logical> => logical;
type `cset_is_set_or_multiset` <class<`cset`, `gset`>, logical> => logical;
type `cset_is_subset` <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`> | class<`cset`, `gset`, `set`>, logical> => logical;
type `cset_matchfun` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer> => class<`function`>;
type `cset_memberships` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`tuple`>, null | character[]> => (double[] | class<`table`> | list<class<`cset`, `gset`, `set`> | double[]>);
type `cset_orderfun` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer> => class<`function`>;
type `cset_power` <class<`cset`, `gset`, `set`>> => class<`cset`, `gset`>;
type `cset_sum` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `cset_union` <...> => (class<`cset`> | class<`cset`, `gset`>);
type `cset_universe` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `c.tuple` <...> => class<`tuple`>;
type `cut.gset` <class<`cset`, `gset`>, double, character[], logical, ...> => class<`cset`, `gset`, `set`>;
type `%D%` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `.distfunL1` <class<`cset`, `gset`>, class<`cset`, `gset`>> => double;
type `.distfunL2` <class<`cset`, `gset`>, class<`cset`, `gset`>> => double;
type `.domain_is_numeric` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical;
type `.duplicated_by_matchfun` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`function`>> => logical[];
type `e` <character | integer, double> => class<`element`>;
type `%e%` <integer[] | class<`tuple`>, class<`cset`, `gset`, `set`> | class<`cset`>> => logical[];
type `.empty_interval` < > => class<`interval`>;
type `ex` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`> | class<`element`> | double[] | list<character | double>> => (class<`table`> | double[] | class<`cset`, `gset`, `set`> | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`, `set`> | class<`cset`, `gset`>>);
type `.exact_match` <double[] | class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | character | list<any>, class<`cset`, `gset`, `set`> | double[] | class<`cset`> | class<`cset`, `gset`> | character[] | list<any>> => (null | ^integer[]);
type `.expand` <class<`cset`, `gset`, `set`> | integer[] | null> => class<`cset`, `gset`, `set`>;
type `.expand_membership` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double, logical, double, logical> => double[];
type `f` <class<`interval`>> => logical | <double[], double[]> => double[] | <class<`interval`>> => logical | <class<`interval`>> => logical | <class<`interval`>> => logical;
type `format.cset` <class<`cset`>, ...> => character;
type `format.element` <class<`element`>, ...> => character;
type `format.gset` <class<`cset`, `gset`>, ...> => character;
type `.format_or_class` <character | class<`cset`, `gset`, `set`> | class<`tuple`> | double | integer[] | list<double | list<list<double>>>, double, ...> => character;
type `format.set` <class<`cset`, `gset`, `set`>, ...> => character;
type `.format_set_or_tuple` <class<`cset`, `gset`, `set`> | class<`tuple`> | list<character | character | double | class<`element`>>, character, character, ...> => character;
type `format.tuple` <class<`tuple`>, ...> => character;
type `FUN` <any, any, any, double, any> => class<`function`> | <character[] | class<`cset`, `gset`> | class<`factor`, `ordered`> | class<`cset`, `gset`, `set`> | double[] | list<class<`matrix`>>> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>) | <class<`interval`> | class<`cset`, `gset`, `set`> | double | null | list<any>> => class<`interval`> | <class<`cset`, `gset`, `set`> | class<`cset`> | class<`cset`, `gset`> | ^character[] | class<`factor`, `ordered`> | class<`tuple`> | ^double[] | class<`table`> | list<any>, ...> => list<any> | <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | double[] | list<any>> => class<`cset`, `gset`, `set`> | <integer[] | list<class<`cset`, `gset`> | character | integer>> => class<`tuple`> | <class<`cset`, `gset`> | character[] | class<`cset`, `gset`, `set`> | double[], integer[] | class<`function`> | null, null | class<`function`>> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>) | <class<`cset`, `gset`>> => logical | <class<`cset`, `gset`>, logical> => logical | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`tuple`>, null | character[]> => (double[] | class<`table`> | list<class<`cset`, `gset`, `set`> | double[]>) | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`> | <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`> | class<`element`> | double[] | list<character | double>> => (class<`table`> | double[] | class<`cset`, `gset`, `set`> | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`, `set`> | class<`cset`, `gset`>>) | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double, logical, double, logical> => double[] | <class<`interval`>> => logical | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, logical> => logical | <double[]> => double[] | <class<`interval`>> => character | <class<`cset`, `gset`, `set`>> => logical[] | <double> => class<`cset`, `gset`> | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double | list<character | integer>, logical> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double[] | list<character>, logical> => logical | <class<`cset`, `gset`>, character> => double | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`>> => logical | <class<`cset`, `gset`> | list<character>, logical> => logical | <logical[]> => class<`cset`, `gset`, `set`> | <character | class<`cset`, `gset`, `set`> | class<`element`> | class<`function`> | class<`tuple`> | double | integer[] | class<`matrix`> | list<double | list<list<double>>>, any, ...> => character | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`> | <double[]> => double | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => double | <character | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`element`> | class<`function`> | class<`matrix`> | class<`tuple`> | double | list<double>> => (integer | null) | <class<`cset`, `gset`>> => double[] | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer> => logical | <class<`fuzzy_rule`>> => class<`cset`, `gset`> | <class<`interval`>> => logical | <integer> => class<`cset`, `gset`, `set`> | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>) | <class<`cset`, `gset`, `set`>> => double | <list<double>> => any | <integer> => double[] | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`> | double> => logical | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer | list<character>> => logical | <class<`tuple`> | double> => (class<`tuple`> | list<double>) | <double> => logical | <character[] | list<any>, any, ...> => integer[] | <double | null, any, character[], null | character> => class<`interval`> | <class<`cset`, `gset`, `set`>> => class<`cset`, `gset`> | <integer> => double | <class<`fuzzy_rule`>> => class<`call`> | <double> => class<`cset`, `gset`> | <integer> => list<double> | <class<`interval`>> => integer | <double[]> => double[] | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double | class<`cset`> | list<character>, character[], any> => double | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer | class<`cset`>, class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer[] | double, class<`function`>> => (double[] | list<any>) | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | integer[]> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical[] | <double[] | list<any>> => double[] | <list<double>> => double | <class<`interval`>, any, double> => any | <double> => class<`interval`> | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical | <class<`interval`> | integer> => class<`interval`> | <any, double, double, logical> => class<`function`> | <class<`fuzzy_variable`, `tuple`>> => character | <logical[]> => logical[];
type `fuzzy_inference` <class<`fuzzy_system`>, list<double>, character[]> => class<`cset`, `gset`>;
type `fuzzy_logic` <any, ...> => class<`fuzzy_logic_family`>;
type `fuzzy_logic_family` <character, class<`function`>, class<`function`>, class<`function`>, class<`function`>, null, list<logical>> => class<`fuzzy_logic_family`>;
type `fuzzy_normal` <any, any, any, double, any> => class<`function`>;
type `fuzzy_normal_gset` <null, double, logical, double, double, integer[] | null> => class<`cset`, `gset`>;
type `fuzzy_partition` <double[], class<`charfun_generator`>, null, ...> => class<`fuzzy_variable`, `tuple`>;
type `fuzzy_pi3` <any, any, any, double, any> => class<`function`>;
type `fuzzy_pi3_gset` <null, double, double, double, null, logical> => class<`cset`, `gset`>;
type `fuzzy_rule` <any, any> => class<`fuzzy_rule`>;
type `fuzzy_system` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => class<`fuzzy_system`>;
type `fuzzy_trapezoid` <double[], double[], any> => class<`function`>;
type `fuzzy_trapezoid_gset` <double[], double[], null, logical> => class<`cset`, `gset`>;
type `fuzzy_tuple` <class<`charfun_generator`>, double[], ..., null, null | character[]> => class<`tuple`>;
type `fuzzy_two_normals` <null, double[], logical[], double, any> => class<`function`>;
type `fuzzy_two_normals_gset` <null, double[], logical[], double, double, null> => class<`cset`, `gset`>;
type `fuzzy_variable` <...> => class<`fuzzy_variable`, `tuple`>;
type `.get_bound` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`>> => double;
type `.get_memberships` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`> | class<`element`> | double[] | list<character | double>> => (class<`table`> | double[] | class<`cset`, `gset`, `set`> | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`, `set`> | class<`cset`, `gset`>>);
type `.get_support` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | integer> => (character[] | double[] | list<any>);
type `.get_universe` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `gset` <character[] | class<`cset`, `gset`, `set`> | double[] | null | list<character | integer | class<`matrix`> | integer>, double[] | class<`table`> | null | list<any>, null | class<`function`>, null | list<class<`element`>>, null | character[] | class<`cset`, `gset`, `set`> | double[], null | double> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `[.gset` <class<`cset`, `gset`>, character[]> => class<`cset`, `gset`>;
type `[[<-.gset` <class<`cset`, `gset`>, class<`matrix`>, integer> => class<`cset`, `gset`>;
type `gset_bound` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`>> => double;
type `gset_cardinality` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double | class<`cset`> | list<character>, character[], any> => double;
type `gset_cartesian` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_combn` <class<`cset`, `gset`, `set`>, integer> => class<`cset`, `gset`, `set`>;
type `.gset_complement` <class<`cset`, `gset`> | class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, double> => class<`cset`, `gset`>;
type `gset_complement` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`> | null> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_concentrate` <class<`cset`, `gset`>> => class<`cset`, `gset`>;
type `gset_defuzzify` <class<`cset`, `gset`>, character> => double;
type `gset_difference` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_dilate` <class<`cset`, `gset`>> => class<`cset`, `gset`>;
type `gset_dissimilarity` <class<`cset`, `gset`>, class<`cset`, `gset`>, character> => double;
type `gset_height` <class<`cset`, `gset`>, logical> => double;
type `gset_intersection` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_is_crisp` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double[] | list<character>, logical> => logical;
type `gset_is_empty` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, logical> => logical;
type `gset_is_equal` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `gset_is_fuzzy_multiset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer | list<character>> => logical;
type `gset_is_fuzzy_set` <class<`cset`, `gset`> | list<character>, logical> => logical;
type `gset_is_multiset` <class<`cset`, `gset`>, any> => logical;
type `gset_is_proper_subset` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `gset_is_set` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double | list<character | integer>, logical> => logical;
type `gset_is_set_or_fuzzy_set` <class<`cset`, `gset`>, any> => logical;
type `gset_is_subset` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `gset_mean` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, character[]> => class<`cset`, `gset`>;
type `gset_memberships` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`tuple`>, null | character[]> => (double[] | class<`table`> | list<class<`cset`, `gset`, `set`> | double[]>);
type `gset_normalize` <class<`cset`, `gset`>, double> => class<`cset`, `gset`>;
type `gset_peak` <class<`cset`, `gset`>, logical> => class<`cset`, `gset`, `set`>;
type `gset_product` <...> => class<`cset`, `gset`>;
type `gset_similarity` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, character> => double;
type `gset_sum` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_support` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `gset_transform_memberships` <class<`cset`, `gset`>, class<`function`>, ...> => class<`cset`, `gset`>;
type `gset_union` <...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_universe` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `.I.` <double[], double[]> => double[];
type `integers` <double | null, double | null> => class<`interval`>;
type `integers2reals` <class<`interval`>, any, double> => any;
type `interval` <double | null, any, character[], null | character> => class<`interval`>;
type `[[.interval` <class<`interval`>, integer> => class<`interval`>;
type `interval_complement` <class<`interval`>, class<`interval`> | null> => any;
type `interval_difference` <...> => class<`interval`>;
type `interval_division` <...> => class<`interval`>;
type `interval_domain` <class<`interval`>> => character;
type `interval_intersection` <...> => class<`interval`>;
type `interval_is_bounded` <class<`interval`>> => logical;
type `interval_is_degenerate` <class<`interval`>> => logical;
type `interval_is_empty` <class<`interval`>> => logical;
type `interval_is_equal` <class<`interval`>, class<`interval`>> => logical;
type `interval_is_half_bounded` <class<`interval`>> => logical;
type `interval_is_left_bounded` <class<`interval`>> => logical;
type `interval_is_left_closed` <class<`interval`>> => logical;
type `interval_is_proper_subinterval` <class<`interval`>, class<`interval`>> => logical;
type `interval_is_right_bounded` <class<`interval`>> => logical;
type `interval_is_right_closed` <class<`interval`>> => logical;
type `interval_is_right_unbounded` <class<`interval`>> => logical;
type `interval_is_subinterval` <class<`interval`>, class<`interval`>> => logical;
type `interval_is_uncountable` <class<`interval`>> => logical;
type `.interval_ops` <list<class<`interval`> | class<`interval`> | integer>, any> => class<`interval`>;
type `interval_product` <...> => class<`interval`>;
type `interval_sum` <...> => class<`interval`>;
type `interval_union` <...> => class<`interval`>;
type `%is%` <class<`cset`, `gset`>, double> => double;
type `is.charfun_generator` <class<`charfun_generator`> | class<`cset`, `gset`> | class<`function`>> => logical;
type `is.cset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`> | double> => logical;
type `is_element` <character | class<`element`> | double | integer[]> => logical;
type `is.gset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | integer[]> => logical;
type `is.interval` <character[] | class<`cset`, `gset`, `set`> | double[]> => logical;
type `is.set` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`>> => logical;
type `is.tuple` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`element`> | class<`tuple`> | double | integer[]> => logical;
type `LABEL` <character | class<`cset`, `gset`, `set`> | class<`element`> | class<`function`> | class<`tuple`> | double | integer[] | class<`matrix`> | list<double | list<list<double>>>, any, ...> => character;
type `LABEL.character` <character, null, logical, ...> => character;
type `LABEL.default` <class<`function`>, any, ...> => character;
type `LABEL.element` <class<`element`>, any, ...> => character;
type `LABEL.integer` <integer[] | double, null, ...> => character;
type `LABEL.list` <list<double | list<list<double>>>, null, ...> => character;
type `LABEL.matrix` <class<`matrix`>, null, ...> => character;
type `LABEL.numeric` <integer[] | double, null, ...> => character;
type `LABELS` <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`tuple`> | integer[] | list<any>, null, character, logical, null | double, ...> => character[];
type `LABEL.set` <class<`cset`, `gset`, `set`> | class<`tuple`>, double | null, ...> => character;
type `LABEL.tuple` <class<`cset`, `gset`, `set`> | class<`tuple`>, double | null, ...> => character;
type `length.cset` <class<`cset`> | class<`cset`, `gset`> | ^character[] | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | class<`table`> | class<`tuple`> | ^double[] | list<any>> => integer;
type `length.gset` <class<`cset`> | class<`cset`, `gset`> | ^character[] | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | class<`table`> | class<`tuple`> | ^double[] | list<any>> => integer;
type `length.interval` <class<`interval`>> => integer;
type `length.set` <class<`cset`> | class<`cset`, `gset`> | ^character[] | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | class<`table`> | class<`tuple`> | ^double[] | list<any>> => integer;
type `lengths.set` <class<`cset`, `gset`, `set`>, logical> => integer[];
type `lines.gset` <class<`cset`, `gset`>, character, double | character, logical, class<`cset`, `gset`, `set`> | null, ...> => class<`cset`, `gset`>;
type `lines.tuple` <class<`tuple`>, character[] | double | integer[], any, ...> => class<`tuple`>;
type `.list_order` <character[] | list<any>, any, ...> => integer[];
type `.list_sort` <list<any>, logical, ...> => list<any>;
type `.list_unique` <character[] | class<`factor`, `ordered`> | list<any>> => list<any>;
type `.lookup_elements` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, character[] | double[] | list<any>, class<`function`>> => integer[];
type `.make_cset_from_gset_and_orderfun_and_matchfun` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, integer[] | class<`function`> | null, null | class<`function`>> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_element_from_support_and_memberships` <character | class<`matrix`> | double, double | class<`cset`, `gset`, `set`>> => class<`element`>;
type `.make_gset_by_support_and_memberships` <class<`cset`, `gset`, `set`> | list<any>, class<`table`> | double[] | null | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, null | character[] | class<`cset`, `gset`, `set`> | double[], any> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_gset_from_list` <list<class<`cset`, `gset`, `set`>>> => class<`cset`, `gset`>;
type `.make_gset_from_list_of_gsets_and_support_and_connector` <list<any>, class<`cset`, `gset`, `set`> | class<`cset`, `gset`>, class<`function`>, class<`function`>, logical> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_gset_from_support_and_memberships` <^character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | ^double[] | list<any>, double[] | class<`table`> | null | list<any>, null | class<`cset`, `gset`, `set`> | double[] | character[], any> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_interval_from_list_and_domain` <list<any>, character | null> => class<`interval`>;
type `.make_list_of_elements_from_cset` <class<`cset`> | class<`cset`, `gset`>> => list<class<`element`>>;
type `.make_matchfun_from_equalityfun` <class<`function`>> => class<`function`>;
type `.make_set_from_list` <class<`cset`, `gset`, `set`> | list<any>> => class<`cset`, `gset`, `set`>;
type `.make_set_of_tuples_from_list_of_lists` <list<list<character | integer>>> => class<`cset`, `gset`, `set`>;
type `.make_set_with_order` <class<`cset`, `gset`, `set`>, integer[]> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order` <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | double[] | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.character` <character[] | class<`factor`, `ordered`> | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.gset` <class<`cset`, `gset`>> => list<class<`cset`, `gset`, `set`> | integer[]>;
type `make_set_with_order.integer` <double[]> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.list` <character[] | class<`factor`, `ordered`> | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.numeric` <double[]> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.ordered` <character[] | class<`factor`, `ordered`> | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.set` <class<`cset`, `gset`, `set`>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `.make_tuple_from_list` <list<any>> => class<`tuple`>;
type `.match` <double[] | class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | character | list<any>, class<`cset`, `gset`, `set`> | double[] | class<`cset`> | class<`cset`, `gset`> | character[] | list<any>> => (null | ^integer[]);
type `matchfun` <double[] | class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | character | list<any>, class<`cset`, `gset`, `set`> | double[] | class<`cset`> | class<`cset`, `gset`> | character[] | list<any>> => (null | ^integer[]) | <class<`function`>> => class<`function`>;
type `.matchfun` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer> => (class<`function`> | null);
type `.maximal_domain` <list<class<`interval`>>> => character;
type `max.interval` <...> => double;
type `mean.gset` <class<`cset`, `gset`>, ..., logical> => double;
type `mean.interval` <...> => class<`interval`>;
type `mean.set` <class<`cset`, `gset`, `set`>, ...> => double;
type `median.gset` <class<`cset`, `gset`>, logical, ...> => double;
type `median.set` <class<`cset`, `gset`, `set`>, logical, ...> => double;
type `.memberships_for_support` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer | class<`cset`>, class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer[] | double, class<`function`>> => (double[] | list<any>);
type `.minimal_domain` <list<class<`interval`>>> => character;
type `min.interval` <...> => double;
type `.multiplicities` <double[] | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`>>> => double[];
type `.N.` <double[]> => double[];
type `naturals` <null, null> => class<`interval`>;
type `naturals0` <null, null> => class<`interval`>;
type `Ops.cset` <class<`cset`> | double | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, any> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | logical);
type `Ops_gset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, any, character, any> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | logical);
type `Ops.interval` <class<`interval`>, any> => (class<`interval`> | logical);
type `Ops_set` <class<`cset`, `gset`, `set`>, any, character, any> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | logical);
type `Ops.tuple` <class<`tuple`>, class<`tuple`>> => class<`tuple`>;
type `.orderfun` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | integer> => (class<`function`> | null);
type `pair` <...> => class<`tuple`>;
type `plot.charfun_generator` <class<`charfun_generator`>, null, ...> => class<`tuple`>;
type `plot.fuzzy_system` <class<`fuzzy_system`>, class<`function`>, ...> => class<`fuzzy_system`>;
type `plot.fuzzy_variable` <class<`fuzzy_variable`, `tuple`>, double, ...> => class<`fuzzy_variable`, `tuple`>;
type `plot.gset` <class<`cset`, `gset`>, null, null, character, character, ...> => (class<`cset`, `gset`> | class<`tuple`>);
type `plot.tuple` <class<`fuzzy_variable`, `tuple`> | class<`tuple`>, character, null, character, character, character[] | double | integer[], logical, ...> => (class<`fuzzy_variable`, `tuple`> | class<`tuple`>);
type `print.cset` <class<`cset`>, ...> => class<`cset`>;
type `print.fuzzy_rule` <class<`fuzzy_rule`>, ...> => class<`fuzzy_rule`>;
type `print.fuzzy_system` <class<`fuzzy_system`>, ...> => class<`fuzzy_system`>;
type `print.gset` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, ...> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `print.set` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, ...> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `range.interval` <...> => double[];
type `reals` <double | null, double | null, character[]> => class<`interval`>;
type `reals2integers` <class<`interval`>> => class<`interval`>;
type `reduction` <class<`cset`, `gset`, `set`>, any, ...> => class<`cset`, `gset`, `set`>;
type `reduction.set` <class<`cset`, `gset`, `set`>, character[], ...> => class<`cset`, `gset`, `set`>;
type `rep.gset` <class<`cset`, `gset`>, ...> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `rep.tuple` <class<`tuple`>, ...> => class<`tuple`>;
type `.S.` <double[], double[]> => double[];
type `set` <...> => class<`cset`, `gset`, `set`>;
type `.set` <...> => class<`cset`, `gset`, `set`>;
type `[<-.set` <class<`cset`, `gset`, `set`>, double[], character[]> => class<`cset`, `gset`, `set`>;
type `[.set` <class<`cset`, `gset`, `set`>, list<character | double>> => class<`cset`, `gset`, `set`>;
type `[[<-.set` <class<`cset`, `gset`, `set`>, class<`function`> | list<double>, character> => class<`cset`, `gset`, `set`>;
type `[[.set` <class<`cset`, `gset`, `set`>, character> => double;
type `.set_bound` <class<`cset`, `gset`>, double> => class<`cset`, `gset`>;
type `set_cardinality` <class<`cset`> | class<`cset`, `gset`> | ^character[] | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | class<`table`> | class<`tuple`> | ^double[] | list<any>> => integer;
type `set_cartesian` <...> => class<`cset`, `gset`, `set`>;
type `set_combn` <class<`cset`, `gset`, `set`>, double> => class<`cset`, `gset`, `set`>;
type `set_complement` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`> | class<`cset`>> => class<`cset`, `gset`, `set`>;
type `.set_complement_using_matchfun` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`> | class<`cset`>, class<`function`>> => class<`cset`, `gset`, `set`>;
type `set_contains_element` <class<`cset`, `gset`, `set`>, integer[] | class<`tuple`>> => logical[];
type `set_dissimilarity` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, character[]> => double;
type `.set_intersection` <list<any>, any> => class<`cset`, `gset`, `set`>;
type `set_intersection` <...> => class<`cset`, `gset`, `set`>;
type `set_is_empty` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical;
type `set_is_equal` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => logical;
type `set_is_proper_subset` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => logical;
type `set_is_subset` <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`> | class<`cset`, `gset`, `set`>> => logical;
type `.set_memberships` <class<`cset`, `gset`>, double[] | list<class<`cset`, `gset`>>> => class<`cset`, `gset`>;
type `set_outer` <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`tuple`> | integer[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | list<double>>, class<`function`> | class<`cset`, `gset`, `set`> | class<`tuple`> | integer[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | list<double>>, class<`function`> | character, ..., logical, logical> => class<`matrix`>;
type `set_similarity` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, character> => double;
type `sets_options` <any, any> => (character | class<`function`> | double[] | null | list<logical | character>);
type `set_symdiff` <...> => class<`cset`, `gset`, `set`>;
type `set_union` <...> => class<`cset`, `gset`, `set`>;
type `.set_universe` <class<`cset`, `gset`>, class<`cset`, `gset`, `set`>> => class<`cset`, `gset`>;
type `.simplify_interval` <list<list<double>>, logical> => list<list<double>>;
type `.sort_interval` <list<list<double>>> => list<list<double>>;
type `.stop_if_memberships_are_invalid` <class<`table`> | double[] | list<any>, null | character> => null;
type `.structure` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`function`> | class<`tuple`> | list<any>, ...> => (class<`cset`> | class<`cset_charfun`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`element`> | class<`fuzzy_logic_family`> | class<`fuzzy_rule`> | class<`fuzzy_system`> | class<`fuzzy_variable`, `tuple`> | class<`interval`> | class<`tuple`> | list<character | double>);
type `Summary.set` <..., logical> => (double | integer[]);
type `Summary.tuple` <..., logical> => double;
type `.T.` <double[], double[]> => double[];
type `triple` <...> => class<`tuple`>;
type `tuple` <...> => class<`tuple`>;
type `tuple_is_ntuple` <class<`tuple`>, double> => logical;
type `tuple_is_triple` <class<`tuple`>> => logical;
type `tuple_outer` <character[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`tuple`> | integer[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | list<double>>, class<`function`> | class<`cset`, `gset`, `set`> | class<`tuple`> | integer[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | list<double>>, class<`function`> | character, ..., logical, logical> => class<`matrix`>;
type `x` <any, any, any, double, any> => class<`function`>;
