type `[[` < > => class<`fuzzy_logic_family`>;
type `$` <double[], double[]> => double[];
type `.apply_connector_to_list_of_gsets_and_support` <list<any>, class<`cset`, `gset`, `set`>, class<`function`>, class<`function`>, logical> => (double[] | list<double[]>);
type `.as.character` <list<any>> => character[] | <character[] | list<any>, ...> => character[];
type `as.character.cset` <class<`cset`>, ...> => character[];
type `as.cset` <class<`factor`, `ordered`> | character[]> => (class<`cset`> | class<`cset`, `gset`>);
type `as.cset.character` <character[]> => (class<`cset`> | class<`cset`, `gset`>);
type `as.cset.ordered` <class<`factor`, `ordered`>> => class<`cset`>;
type `as.gset` <character[] | class<`cset`, `gset`> | class<`factor`, `ordered`> | class<`cset`, `gset`, `set`> | double[]> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.as.gset.atomic` <character[] | class<`factor`, `ordered`> | double[], class<`function`>> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `as.gset.character` <character[]> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `as.gset.integer` <integer[]> => class<`cset`, `gset`, `set`>;
type `as.gset.numeric` <double[]> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `as.gset.ordered` <class<`factor`, `ordered`>> => class<`cset`, `gset`>;
type `.as.list` <class<`cset`, `gset`, `set`> | class<`cset`> | ^character[] | class<`factor`, `ordered`> | class<`cset`, `gset`> | ^double[] | list<any>, ...> => list<any>;
type `.as.list.cset` <class<`cset`>, ...> => list<character | character | double | double>;
type `as.list.cset` <class<`cset`>, ...> => list<character>;
type `.as.list.default` <^character[] | class<`factor`, `ordered`> | ^double[] | list<any>, ...> => list<any>;
type `as.list.gset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, ...> => list<any>;
type `as.list.set` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, ...> => list<any>;
type `as.set` <class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | double[] | list<any>> => class<`cset`, `gset`, `set`>;
type `binary_closure` <class<`matrix`>, character[]> => class<`matrix`>;
type `binary_reduction` <class<`matrix`>, character> => class<`matrix`>;
type `.canonicalize_memberships` <double[] | list<class<`cset`, `gset`> | double[] | class<`cset`, `gset`, `set`>>> => (double[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>);
type `canonicalize_set_and_mapping` <class<`cset`, `gset`, `set`> | double | list<any>, class<`matrix`> | double[] | list<character | class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, double | null> => list<any>;
type `.check_matchfun` <list<class<`cset`>>> => class<`function`>;
type `.check_orderfun` <list<class<`cset`>>> => class<`function`>;
type `closure` <class<`cset`, `gset`, `set`>, any, ...> => class<`cset`, `gset`, `set`>;
type `closure.set` <class<`cset`, `gset`, `set`>, character[], ...> => class<`cset`, `gset`, `set`>;
type `.create_hash` <list<any>> => environment;
type `cset` <class<`cset`, `gset`> | character[] | class<`cset`, `gset`, `set`> | double[], integer[] | class<`function`> | null, null | class<`function`>> => class<`cset`>;
type `c.set` <...> => class<`cset`, `gset`, `set`>;
type `cset_bound` <class<`cset`>> => integer;
type `cset_cardinality` <class<`cset`> | class<`cset`, `gset`, `set`>, character[], any> => integer;
type `cset_complement` <class<`cset`>, class<`cset`>> => class<`cset`>;
type `cset_contains_element` <class<`cset`>, integer> => logical;
type `cset_intersection` <...> => class<`cset`>;
type `cset_is_empty` <class<`cset`>, logical> => logical;
type `cset_is_equal` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `cset_is_subset` <class<`cset`>, class<`cset`>, logical> => logical;
type `cset_matchfun` <class<`cset`>> => class<`function`>;
type `cset_orderfun` <class<`cset`>> => class<`function`>;
type `cset_union` <...> => class<`cset`>;
type `cset_universe` <class<`cset`>> => class<`cset`, `gset`, `set`>;
type `.duplicated_by_matchfun` <class<`cset`, `gset`, `set`>, class<`function`>> => logical[];
type `e` <integer, integer> => class<`element`>;
type `%e%` <integer, class<`cset`> | class<`cset`, `gset`, `set`>> => logical;
type `ex` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`> | double | list<character | double>> => (double[] | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>);
type `.exact_match` <integer | class<`cset`> | class<`cset`, `gset`, `set`> | list<class<`element`>>, class<`cset`, `gset`, `set`> | class<`cset`> | double[] | list<any>> => (null | ^integer[]);
type `.expand_membership` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double, logical, double, logical> => double[];
type `f` <double[], double[]> => double[] | <double[], double[]> => double[];
type `filter` <character[]> => logical[];
type `format.cset` <class<`cset`>, ...> => character;
type `.format_or_class` <character | double, integer, ...> => character;
type `format.set` <class<`cset`, `gset`, `set`>, ...> => character;
type `.format_set_or_tuple` <class<`cset`, `gset`, `set`> | list<character | character | double>, character, character, ...> => character;
type `fun` <any, any> => class<`fuzzy_logic_family`>;
type `FUN` <character[] | class<`cset`, `gset`> | class<`factor`, `ordered`> | class<`cset`, `gset`, `set`> | double[]> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>) | <class<`cset`, `gset`, `set`> | class<`cset`> | ^character[] | class<`factor`, `ordered`> | class<`cset`, `gset`> | ^double[] | list<any>, ...> => list<any> | <class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | double[] | list<any>> => class<`cset`, `gset`, `set`> | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`> | double | list<character | double>> => (double[] | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>) | <class<`cset`>, logical> => logical | <class<`cset`, `gset`, `set`>> => logical[] | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double, logical> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`>> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, null> => (double | integer[]) | <logical[]> => class<`cset`, `gset`, `set`> | <character | double, null, ...> => character | <double[]> => double | <character | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`element`> | double> => (integer | null) | <class<`cset`>> => logical | <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>) | <integer> => double[] | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`>> => logical | <class<`cset`>> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical | <double> => logical | <character[] | list<any>, logical, ...> => integer[] | <class<`cset`, `gset`, `set`>> => class<`cset`, `gset`> | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double | class<`cset`>, character[], any> => double | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, class<`function`>> => (double[] | list<any>) | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | integer> => logical | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical[] | <double[] | list<any>> => double[] | <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical | <logical[]> => logical[];
type `fuzzy_logic` <any, ...> => class<`fuzzy_logic_family`>;
type `fuzzy_logic_family` <character, class<`function`>, class<`function`>, class<`function`>, class<`function`>, null, list<logical>> => class<`fuzzy_logic_family`>;
type `.get_bound` <class<`cset`> | class<`cset`, `gset`, `set`>> => integer;
type `.get_memberships` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`> | double | list<character | double>> => (double[] | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>);
type `.get_support` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => (double[] | list<any>);
type `.get_universe` <class<`cset`> | class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `gset` <double | class<`cset`, `gset`, `set`>, double | null | integer[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, null, null, null | class<`cset`, `gset`, `set`>, null | integer> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `gset_cardinality` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double | class<`cset`>, character[], any> => double;
type `gset_combn` <class<`cset`, `gset`, `set`>, integer> => class<`cset`, `gset`, `set`>;
type `.gset_complement` <class<`cset`>, class<`cset`, `gset`, `set`>, integer> => class<`cset`, `gset`>;
type `gset_difference` <...> => class<`cset`, `gset`, `set`>;
type `gset_is_crisp` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, logical> => logical;
type `gset_is_equal` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, logical> => logical;
type `gset_is_fuzzy_multiset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>> => logical;
type `gset_is_set` <class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | double, logical> => logical;
type `gset_support` <class<`cset`, `gset`, `set`>> => class<`cset`, `gset`, `set`>;
type `.help` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => logical | <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => logical | <class<`cset`>, class<`cset`>> => logical | <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`> | class<`cset`, `gset`, `set`>> => logical | <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => logical;
type `is.cset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | class<`element`>> => logical;
type `is_element` <class<`element`> | integer> => logical;
type `is.gset` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`> | integer> => logical;
type `is.interval` <class<`cset`, `gset`, `set`>> => logical;
type `is.set` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`cset`>> => logical;
type `is.tuple` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`element`> | integer> => logical;
type `LABEL.character` <character, null, logical, ...> => character;
type `LABEL.integer` <double, null, ...> => character;
type `LABEL.numeric` <double, null, ...> => character;
type `LABELS` <list<character | character | double>, null, character, logical, null, ...> => character[];
type `length.gset` <class<`cset`, `gset`> | ^character[] | class<`cset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | ^double[] | list<any>> => integer;
type `length.set` <class<`cset`, `gset`> | ^character[] | class<`cset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | ^double[] | list<any>> => integer;
type `.list_order` <character[] | list<any>, logical, ...> => integer[];
type `.list_sort` <list<any>, logical, ...> => list<any>;
type `.list_unique` <class<`factor`, `ordered`> | list<any>> => list<any>;
type `.make_cset_from_gset_and_orderfun_and_matchfun` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`>, integer[] | class<`function`> | null, null | class<`function`>> => class<`cset`>;
type `.make_element_from_support_and_memberships` <character | double, integer> => class<`element`>;
type `.make_gset_by_support_and_memberships` <class<`cset`, `gset`, `set`> | list<character | double | double>, double[] | null | list<class<`cset`, `gset`, `set`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, null | class<`cset`, `gset`, `set`>, null | integer> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_gset_from_list_of_gsets_and_support_and_connector` <list<any>, class<`cset`, `gset`, `set`>, class<`function`>, class<`function`>, logical> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_gset_from_support_and_memberships` <^character[] | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | ^double[], double[] | null | list<double[] | class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, null | class<`cset`, `gset`, `set`>, any> => (class<`cset`, `gset`> | class<`cset`, `gset`, `set`>);
type `.make_list_of_elements_from_cset` <class<`cset`>> => list<class<`element`>>;
type `.make_matchfun_from_equalityfun` <class<`function`>> => class<`function`>;
type `.make_set_from_list` <list<any>> => class<`cset`, `gset`, `set`>;
type `.make_set_with_order` <class<`cset`, `gset`, `set`>, integer[]> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order` <class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | double[] | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.integer` <double[]> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.list` <class<`factor`, `ordered`> | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.numeric` <double[]> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.ordered` <class<`factor`, `ordered`> | list<any>> => list<class<`cset`, `gset`, `set`> | integer[] | class<`cset`, `gset`, `set`> | integer>;
type `make_set_with_order.set` <class<`cset`, `gset`, `set`>> => list<class<`cset`, `gset`, `set`> | integer[]>;
type `matchfun` <integer | class<`cset`> | class<`cset`, `gset`, `set`> | list<class<`element`>>, class<`cset`, `gset`, `set`> | class<`cset`> | double[] | list<any>> => (null | ^integer[]) | <class<`function`>> => class<`function`>;
type `.matchfun` <class<`cset`>> => class<`function`>;
type `.multiplicities` <integer[]> => integer[];
type `Ops.cset` <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`> | class<`cset`, `gset`, `set`>> => logical;
type `Ops_gset` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, character, any> => logical;
type `Ops_set` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>, character, any> => logical;
type `.orderfun` <class<`cset`>> => (class<`function`> | null);
type `print.cset` <class<`cset`>, ...> => class<`cset`>;
type `print.gset` <class<`cset`> | class<`cset`, `gset`, `set`>, ...> => (class<`cset`> | class<`cset`, `gset`, `set`>);
type `print.set` <class<`cset`> | class<`cset`, `gset`, `set`>, ...> => (class<`cset`> | class<`cset`, `gset`, `set`>);
type `reduction` <class<`cset`, `gset`, `set`>, any, ...> => class<`cset`, `gset`, `set`>;
type `reduction.set` <class<`cset`, `gset`, `set`>, character[], ...> => class<`cset`, `gset`, `set`>;
type `set` <...> => class<`cset`, `gset`, `set`>;
type `.set` <...> => class<`cset`, `gset`, `set`>;
type `set_cardinality` <class<`cset`, `gset`> | ^character[] | class<`cset`> | class<`cset`, `gset`, `set`> | class<`factor`, `ordered`> | ^double[] | list<any>> => integer;
type `set_complement` <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`> | class<`cset`>> => class<`cset`, `gset`, `set`>;
type `.set_complement_using_matchfun` <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`> | class<`cset`>, class<`function`>> => class<`cset`, `gset`, `set`>;
type `set_contains_element` <class<`cset`, `gset`, `set`>, integer> => logical;
type `.set_intersection` <list<class<`cset`> | class<`cset`, `gset`, `set`>>, class<`function`>> => class<`cset`, `gset`, `set`>;
type `set_intersection` <...> => class<`cset`, `gset`, `set`>;
type `set_is_empty` <class<`cset`> | class<`cset`, `gset`, `set`>> => logical;
type `set_is_equal` <class<`cset`, `gset`, `set`>, class<`cset`, `gset`, `set`>> => logical;
type `set_is_subset` <class<`cset`> | class<`cset`, `gset`, `set`>, class<`cset`> | class<`cset`, `gset`, `set`>> => logical;
type `sets_options` <character, any> => (class<`function`> | logical | null);
type `set_union` <...> => class<`cset`, `gset`, `set`>;
type `.stop_if_memberships_are_invalid` <double | integer[] | list<class<`cset`, `gset`> | class<`cset`, `gset`, `set`>>, null> => null;
type `.structure` <class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | list<any>, ...> => (class<`cset`> | class<`cset`, `gset`> | class<`cset`, `gset`, `set`> | class<`element`> | class<`fuzzy_logic_family`> | list<character>);
