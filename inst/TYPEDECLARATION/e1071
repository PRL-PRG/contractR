type `$` <double[]> => double[];
type `allShortestPaths` <class<`matrix`>> => list<class<`matrix`>>;
type `bclust` <class<`data.frame`>, double, double, double, character, character, character, double, logical, logical, logical, logical> => class<`bclust`>;
type `bincombinations` <double> => class<`matrix`>;
type `bootstrap.lca` <class<`lca`>, double, double, logical> => class<`bootstrap.lca`>;
type `boxplot.bclust` <class<`bclust`>, integer, logical, any, logical, integer[], ...> => null;
type `centers.bclust` <class<`bclust`>, double> => class<`matrix`>;
type `classAgreement` <class<`table`>, logical> => list<double> | <class<`table`>> => double;
type `CLUSFUN` <class<`matrix`> | class<`data.frame`>, double, double, logical, character, character, double, null, double, list<any>> => class<`fclust`>;
type `clusters.bclust` <class<`bclust`>, double, null> => integer[];
type `cmeans` <class<`matrix`> | class<`data.frame`>, double, double, logical, character, character, double, null, double, list<any>> => class<`fclust`>;
type `coef.svm` <class<`svm`, `svm.formula`>, ...> => double[];
type `color.palette` <double> => character[];
type `compareMatchedClasses` <double[], double[], character, double, double, logical> => list<class<`matrix`>>;
type `convexcoeff` <double[], double[]> => double[];
type `countpattern` <class<`matrix`>, logical> => (integer[] | list<double[]>);
type `cshell` <class<`matrix`>, double, double, logical, character, character, double, null> => class<`cshell`, `fclust`>;
type `dsigmoid` <double[]> => double[];
type `element` <class<`matrix`> | class<`array`>, double[]> => double;
type `eval` <double> => double[] | <double> => double[] | <double> => double[];
type `extractPath` <list<class<`matrix`>>, double, double> => double[];
type `fclustIndex` <class<`fclust`>, class<`matrix`>, character> => double[];
type `filter` <character[]> => logical[];
type `fn` <double[], class<`matrix`>, class<`matrix`>, double, integer> => double;
type `fukuyama.sugeno` <class<`fclust`>> => class<`matrix`>;
type `FUN` <double[] | class<`factor`>> => (class<`matrix`> | class<`table`>) | <integer> => double[] | <integer> => class<`table`> | <integer> => integer[] | <double> => double | <integer> => (class<`table`> | double[]) | <integer[]> => integer[] | <^integer[]> => double[];
type `gath.geva` <class<`fclust`>, class<`matrix`>> => list<double>;
type `hamming.distance` <class<`matrix`> | double[], any> => (class<`matrix`> | integer);
type `hamming.window` <double> => double[];
type `hanning.window` <double> => double[];
type `hclust.bclust` <class<`bclust`>, any, double, character, character, logical, logical, double> => class<`bclust`>;
type `hsv_palette` <double> => character[] | <any, double, double, double> => class<`function`>;
type `impute` <class<`matrix`>, character[]> => class<`matrix`>;
type `interpolate` <double[], class<`matrix`>, list<double[]>, character> => double;
type `knn.wrapper` <class<`data.frame`>, class<`factor`>, integer, double, ...> => list<class<`data.frame`> | class<`factor`> | double>;
type `kurtosis` <double[], logical, double> => double;
type `lca` <class<`matrix`> | integer[], double, double, logical, logical> => class<`lca`>;
type `lines.probplot` <class<`probplot`>, double[] | null, null | double, logical, ...> => null;
type `matchClasses` <class<`table`>, character, any, double, logical> => integer[];
type `matchControls` <any, any, any, character, null, logical, logical> => list<character[] | class<`factor`>>;
type `moment` <double[], double, logical, logical, logical> => double;
type `naiveBayes` <class<`data.frame`> | class<`formula`>, ...> => class<`naiveBayes`>;
type `naiveBayes.default` <class<`data.frame`>, class<`factor`>, any, ...> => class<`naiveBayes`>;
type `naiveBayes.formula` <class<`formula`>, class<`data.frame`> | class<`table`>, double, ..., any, any> => class<`naiveBayes`>;
type `partition.coefficient` <class<`fclust`>> => double;
type `partition.entropy` <class<`fclust`>> => double;
type `path` <double, double> => null;
type `permutations` <double> => class<`matrix`>;
type `plot.bclust` <class<`bclust`>, double, character, ...> => integer;
type `plot.stft` <class<`stft`>, character[], ...> => null;
type `plot.svm` <class<`svm`, `svm.formula`>, class<`data.frame`>, class<`formula`> | null, logical, double, list<any>, character[], character | double, character | double, ...> => null;
type `plot.tune` <class<`tune`>, character[], double, character, null, null, null, logical, null | class<`function`>, null | class<`function`>, null, any> => (class<`matrix`> | null);
type `predict.func` <list<class<`data.frame`> | class<`factor`> | double>, ...> => class<`factor`>;
type `predict.lca` <class<`lca`>, class<`matrix`>, ...> => integer[];
type `predict.naiveBayes` <class<`naiveBayes`>, class<`data.frame`>, character[], double, double, ...> => (class<`factor`> | class<`matrix`>);
type `predict.svm` <class<`svm`> | class<`svm`, `svm.formula`>, class<`data.frame`> | class<`matrix`> | double[], logical, logical, ..., class<`function`>> => (class<`factor`> | double[]);
type `print.fclust` <class<`cshell`, `fclust`> | class<`fclust`>, ...> => (class<`cshell`, `fclust`> | class<`fclust`>);
type `print.lca` <class<`lca`>, ...> => class<`matrix`>;
type `print.svm` <class<`svm`>, ...> => null;
type `probplot` <double[], character | class<`function`>, null, logical, null, character, ...> => class<`probplot`>;
type `proportion.exponent` <class<`fclust`>> => double;
type `QFUN` <double[]> => double[];
type `rbridge` <double, double> => class<`ts`>;
type `rdiscrete` <double, double[], character[] | integer[], ...> => (character[] | integer[]);
type `resp` <class<`formula`>, class<`data.frame`>> => (class<`factor`> | double[]);
type `rpart.wrapper` <class<`formula`>, double, double, double, double, double, double, double, double, double, ...> => class<`rpart`>;
type `rwiener` <double, double> => class<`ts`>;
type `separation.index` <class<`fclust`>, class<`matrix`>> => class<`matrix`>;
type `sigmoid` <double[]> => double[];
type `skewness` <double[], logical, double> => double;
type `stft` <double[], double, double, double, character> => class<`stft`>;
type `summary.lca` <class<`lca`>, ...> => class<`summary.lca`>;
type `summary.svm` <class<`svm`>, ...> => class<`summary.svm`>;
type `summary.tune` <class<`tune`>, ...> => class<`summary.tune`>;
type `svm` <class<`data.frame`> | double[] | class<`formula`>, ...> => (class<`svm`> | class<`svm`, `svm.formula`>);
type `svm.default` <class<`matrix`> | class<`data.frame`> | double[], class<`factor`> | double[] | null, logical[], null, character, double, double, double, double, double, class<`table`> | null, double> => class<`svm`>;
type `svm.formula` <class<`formula`>, any, ..., any, class<`function`>, logical> => class<`svm`, `svm.formula`>;
type `tune` <character | class<`function`>, class<`data.frame`> | class<`formula`>, class<`factor`> | null, any, null, null, null | list<double[]>, class<`function`>, class<`tune.control`>, ...> => class<`tune`>;
type `tune.control` <logical, double, class<`function`>, character[], class<`function`>, class<`function`>, double, double, double, double, logical, logical> => class<`tune.control`>;
type `tune.knn` <class<`data.frame`>, class<`factor`>, integer[], null, ...> => class<`tune`>;
type `tune.rpart` <class<`formula`>, class<`data.frame`>, class<`function`>, double[], null, null, null, null, null, null, null, null> => class<`tune`>;
type `tune.svm` <class<`formula`>, null, class<`data.frame`>, null, double[], null, double[], null, null, null, ...> => class<`tune`>;
type `which.is.min` <double[]> => integer;
type `write.svm` <class<`svm`, `svm.formula`>, character, character, character> => null;
type `x` <double[]> => double[] | <double[]> => double[] | <double[]> => double[];
type `xie.beni` <class<`fclust`>> => class<`matrix`>;
