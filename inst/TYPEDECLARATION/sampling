type `.as_int` <double> => double;
type `algofastflightcube` <^double[], double[]> => double[];
type `balancedcluster` <^double[], double, double[], double, logical, double> => ^double[];
type `balancedstratification` <^double[], double[], double[], logical, double> => double[];
type `balancedtwostage` <^double[], double, double, double, double[], logical, double> => ^double[];
type `basicsplit` <double[]> => double[];
type `calib` <^double[], double[], double[], double[], character, double[] | language, logical, double> => null | double[];
type `calibev` <double[], ^double[], double[], ^double[], double[], double[], double[], logical, double> => struct<`calest`:double, `evar`:double>;
type `checkcalibration` <^double[], double[], double[], double[], double> => struct<`message`:character, `result`:logical, `value`:double> | struct<`message`:null, `result`:logical, `value`:double>;
type `cleanstrata` <double[]> => integer[];
type `cluster` <struct<`REG`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `CT`:integer[], `ID_unit`:integer[], `Prob_ 2 _stage`:double[], `Prob`:double[]>, character, double, character, symbol | null | double[], logical> => struct<`COM`:integer[], `ID_unit`:integer[], `Prob`:double[]>;
type `disjunctive` <double[]> => ^double[];
type `fastflightcube` <^double[], double[], double, logical> => double[];
type `filter` <character[]> => logical[];
type `gencalib` <^double[], ^double[], double[], double[], double[], character, double[] | language, logical, double, double> => double[];
type `getdata` <struct<`CT`:integer[], `REG`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[]> | integer[], struct<`REG`:integer[], `ID_unit`:integer[], `Prob`:double[]> | double[] | struct<`1`:struct<`ID_unit`:integer[], `Prob_ 1 _stage`:double[]>, `2`:struct<`ID_unit`:integer[], `Prob_ 2 _stage`:double[], `Prob`:double[]>>> => struct<`CT`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `REG`:integer[], `ID_unit`:integer[], `Prob`:double[]> | tuple<struct<`CT`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `REG`:integer[], `ID_unit`:integer[], `Prob_ 1 _stage`:double[]>, struct<`REG`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `CT`:integer[], `ID_unit`:integer[], `Prob_ 2 _stage`:double[], `Prob`:double[]>> | tuple<struct<`state`:integer[], `region`:integer[], `income`:double[], `ID_unit`:integer[], `Prob_ 1 _stage`:double[]>, struct<`state`:integer[], `region`:integer[], `income`:double[], `ID_unit`:integer[], `Prob_ 2 _stage`:double[], `Prob`:double[]>>;
type `Hajekestimator` <double[], double[], null | integer, character> => ^double[];
type `HTestimator` <double[], double[]> => ^double[];
type `HTstrata` <integer[], double[], integer[], logical> => ^double[];
type `inclusionprobabilities` <double[], double> => double[];
type `inclusionprobastrata` <double[], double[]> => double[];
type `is.a.sample` <double[], double> => logical;
type `jump` <^double[], double[]> => double[];
type `landingcube` <^double[], double[], double[], logical> => double[];
type `mstage` <struct<`state`:integer[], `region`:integer[], `income`:double[]>, character[] | tuple<character, character>, null | tuple<character, character>, struct<`size1`:integer[], `size2`:double[], `size3`:double[]> | tuple<double[], double[]>, tuple<character, character> | character[], null | tuple<double[], list<double[]>>, logical> => struct<`1`:struct<`ID_unit`:integer[], `Prob_ 1 _stage`:double[]>, `2`:struct<`ID_unit`:integer[], `Prob_ 2 _stage`:double[], `Prob`:double[]>>;
type `postest` <struct<`CT`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `REG`:integer[], `ID_unit`:integer[], `Prob`:double[], `poststratum`:double[]>, double[], double[], ^double[], logical> => double;
type `poststrata` <struct<`CT`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `REG`:integer[], `ID_unit`:integer[], `Prob`:double[]>, character[]> => struct<`data`:struct<`CT`:integer[], `COM`:integer[], `Nom`:integer[], `HApoly`:integer[], `Surfacesbois`:integer[], `Surfacescult`:integer[], `Alp`:integer[], `Airbat`:integer[], `Airind`:integer[], `P00BMTOT`:integer[], `P00BWTOT`:integer[], `Pop020`:integer[], `Pop2040`:integer[], `Pop4065`:integer[], `Pop65P`:integer[], `H00PTOT`:integer[], `H00P01`:integer[], `H00P02`:integer[], `H00P03`:integer[], `H00P04`:integer[], `POPTOT`:integer[], `REG`:integer[], `ID_unit`:integer[], `Prob`:double[], `poststratum`:double[]>, `npost`:integer> | struct<`data`:struct<`ID_unit`:integer[], `Commune`:integer[], `INS`:integer[], `Province`:integer[], `Arrondiss`:integer[], `Men04`:integer[], `Women04`:integer[], `Tot04`:integer[], `Men03`:integer[], `Women03`:integer[], `Tot03`:integer[], `Diffmen`:integer[], `Diffwom`:integer[], `DiffTOT`:integer[], `TaxableIncome`:double[], `Totaltaxation`:integer[], `averageincome`:integer[], `medianincome`:integer[], `poststratum`:double[]>, `npost`:integer> | struct<`data`:struct<`state`:integer[], `region`:double[], `income`:double[], `poststratum`:double[]>, `npost`:integer>;
type `ratioest` <double[], double[], double, double[]> => double;
type `ratioest_strata` <double[], double[], double[], double[], integer[], logical> => double;
type `reduc` <^double[]> => ^double[];
type `regest` <language, integer[] | double, double[] | language, ^double[], double, double[]> => struct<`call`:language, `formula`:language, `x`:^double[], `y`:double[], `weights`:double[], `regest`:double, `coefficients`:double[], `std_error`:double[], `t_value`:double[], `p_value`:double[], `cov_matrix`:^double[]>;
type `regest_strata` <language, double[], double[], double[], ^double[], double[], logical> => double;
type `rhg` <struct<`ID_unit`:integer[], `status`:double[], `classincome`:double[]>, character[]> => struct<`ID_unit`:integer[], `status`:double[], `classincome`:double[], `rhgroup`:double[], `prob_resp`:double[]>;
type `rhg_strata` <struct<`income`:double[], `region`:double[], `state`:integer[], `ID_unit`:integer[], `Prob`:double[], `Stratum`:integer[], `status`:double[], `classincome`:double[]>, character[]> => struct<`income`:double[], `region`:double[], `state`:integer[], `Prob`:double[], `Stratum`:integer[], `ID_unit`:integer[], `status`:double[], `classincome`:double[], `rhgroup`:double[], `prob_resp`:double[]>;
type `rmodel` <language, language, struct<`income`:double[], `region`:double[], `state`:integer[], `ID_unit`:integer[], `Prob`:double[], `Stratum`:integer[], `status`:double[]>> => struct<`income`:double[], `region`:double[], `state`:integer[], `ID_unit`:integer[], `Prob`:double[], `Stratum`:integer[], `status`:double[], `prob_resp`:double[]>;
type `samplecube` <^double[], double[], double, logical, double> => double[];
type `srswor` <double, double> => double[];
type `srswor1` <double, double> => double[];
type `srswr` <double, double> => integer[];
type `str` <double[], double, integer> => double[];
type `strata` <struct<`state`:integer[], `region`:integer[], `income`:double[]>, null | character[], double[], character, symbol | null | double[], logical> => struct<`ID_unit`:integer[], `Prob`:double[]>;
type `UPbrewer` <double[], double> => double[];
type `UPmaxentropy` <double[]> => double[];
type `UPmaxentropypi2` <double[]> => ^double[];
type `UPMEpik2frompikw` <double[], double[]> => ^double[];
type `UPMEpikfromq` <^double[]> => double[];
type `UPMEpiktildefrompik` <double[], double> => double[];
type `UPMEqfromw` <double[], double> => ^double[];
type `UPMEsfromq` <^double[]> => double[];
type `UPmidzuno` <double[], double> => double[];
type `UPmidzunopi2` <double[]> => ^double[];
type `UPminimalsupport` <double[]> => double[];
type `UPmultinomial` <double[]> => integer[];
type `UPopips` <double[], character> => integer[];
type `UPpivotal` <double[], double> => double[];
type `UPpoisson` <double[]> => double[];
type `UPrandompivotal` <double[], double> => double[];
type `UPrandomsystematic` <double[], double> => double[];
type `UPsampford` <double[], double, double> => double[];
type `UPsampfordpi2` <double[]> => ^double[];
type `UPsystematic` <double[], double> => double[];
type `UPsystematicpi2` <double[]> => ^double[];
type `UPtille` <double[], double> => double[];
type `UPtillepi2` <double[], double> => ^double[];
type `varest` <double[], null | ^double[], double[], null | double[]> => double;
type `vartaylor_ratio` <integer[], integer[], ^double[]> => struct<`ratio`:double, `estvar`:double>;
type `writesample` <double, double> => ^double[];
