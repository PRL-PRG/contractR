type `.as_int` <double> => double;
type `balancedcluster` <class<`matrix`>, double, double[], double, logical, double> => class<`matrix`>;
type `balancedstratification` <class<`matrix`>, double[], double[], logical, double> => double[];
type `balancedtwostage` <class<`matrix`>, double, double, double, double[], logical, double> => class<`matrix`>;
type `calib` <class<`matrix`>, double[], double[], double[], character, any, logical, double> => double[];
type `calibev` <double[], class<`matrix`>, double[], class<`matrix`>, double[], double[], double[], logical, double> => list<double>;
type `checkcalibration` <class<`matrix`> | double[], double[], double[], double[], double> => list<character | double>;
type `cleanstrata` <double[]> => integer[];
type `cluster` <class<`data.frame`>, character, double, character, any, logical> => class<`data.frame`>;
type `disjunctive` <double[]> => class<`matrix`>;
type `fastflightcube` <class<`matrix`>, double[], double, logical> => double[];
type `gencalib` <class<`matrix`> | double[], class<`matrix`> | double[], double[], double[], double[], character, any, logical, double, double> => double[];
type `getdata` <class<`data.frame`> | class<`factor`>, class<`data.frame`> | double[] | list<class<`data.frame`>>> => (class<`data.frame`> | list<class<`data.frame`>>);
type `Hajekestimator` <double[], double[], integer | null, character> => class<`matrix`>;
type `Hajekstrata` <integer[], double[], integer[], class<`table`>, character, logical> => class<`matrix`>;
type `HTestimator` <double[], double[]> => class<`matrix`>;
type `HTstrata` <integer[], double[], integer[], logical> => class<`matrix`>;
type `inclusionprobabilities` <double[], double> => double[];
type `inclusionprobastrata` <double[], double[]> => double[];
type `landingcube` <class<`matrix`>, double[], double[], logical> => double[];
type `mstage` <class<`data.frame`>, character[] | list<character>, any, list<class<`table`> | double[] | double[]>, character[] | list<character>, any, logical> => list<class<`data.frame`>>;
type `postest` <class<`data.frame`>, double[], double[], double[] | class<`matrix`>, logical> => double;
type `poststrata` <class<`data.frame`>, character[]> => list<class<`data.frame`> | integer>;
type `ratioest` <double[], double[], double, double[]> => double;
type `ratioest_strata` <double[], double[], double[], double[], integer[], logical> => double;
type `regest` <class<`formula`>, double | integer[], any, class<`matrix`>, double, double[]> => class<`regest`>;
type `regest_strata` <any, double[], double[], double[], class<`matrix`>, double[], logical> => double;
type `rhg` <class<`data.frame`>, character[]> => class<`data.frame`>;
type `rhg_strata` <class<`data.frame`>, character[]> => class<`data.frame`>;
type `rmodel` <any, any, class<`data.frame`>> => class<`data.frame`>;
type `samplecube` <class<`matrix`>, double[], double, logical, double> => double[];
type `srswor` <double, double> => double[];
type `srswor1` <double, double> => double[];
type `srswr` <double, double> => integer[];
type `strata` <class<`data.frame`>, null | character[], double[] | class<`table`>, character, any, logical> => class<`data.frame`>;
type `UPbrewer` <double[], double> => double[];
type `UPmaxentropy` <double[]> => double[];
type `UPmaxentropypi2` <double[]> => class<`matrix`>;
type `UPMEpik2frompikw` <double[], double[]> => class<`matrix`>;
type `UPMEpikfromq` <class<`matrix`>> => double[];
type `UPMEpiktildefrompik` <double[], double> => double[];
type `UPMEqfromw` <double[], double> => class<`matrix`>;
type `UPMEsfromq` <class<`matrix`>> => double[];
type `UPmidzuno` <double[], double> => double[];
type `UPmidzunopi2` <double[]> => class<`matrix`>;
type `UPminimalsupport` <double[]> => double[];
type `UPmultinomial` <double[]> => integer[];
type `UPopips` <double[], character> => integer[];
type `UPpivotal` <double[], double> => double[];
type `UPpoisson` <double[]> => double[];
type `UPrandompivotal` <double[], double> => double[];
type `UPrandomsystematic` <double[], double> => double[];
type `UPsampford` <double[], double, double> => double[];
type `UPsampfordpi2` <double[]> => class<`matrix`>;
type `UPsystematic` <double[], double> => double[];
type `UPsystematicpi2` <double[]> => class<`matrix`>;
type `UPtille` <double[], double> => double[];
type `UPtillepi2` <double[], double> => class<`matrix`>;
type `varest` <double[], class<`matrix`> | null, double[], double[] | null> => double;
type `varHT` <double[], class<`matrix`>, double> => double;
type `vartaylor_ratio` <integer[], integer[], class<`matrix`>> => list<double>;
type `writesample` <double, double> => (class<`matrix`> | double);
