type `:::` <double> => null;
type `.findDone` <environment, null | struct<>> => struct<`job.id`:integer[]>;
type `.findErrors` <environment, null | struct<>> => struct<`job.id`:integer[]>;
type `.findNotDone` <environment, null | struct<>> => struct<`job.id`:integer[]>;
type `.findNotSubmitted` <environment, null | struct<>> => struct<`job.id`:integer[]>;
type `.findOnSystem` <environment, null, character[], struct<`batch.id`:character[], `status`:character[]>> => struct<`job.id`:integer[]>;
type `.findStarted` <environment, null, struct<`batch.id`:character[], `status`:character[]>> => struct<`job.id`:integer[]>;
type `.findSubmitted` <environment, null> => struct<`job.id`:integer[]>;
type `.findTerminated` <environment, struct<`job.id`:integer[], `terminated`:logical[], `on.sys`:logical[], `expire.counter`:integer[]>> => struct<`job.id`:integer[]>;
type `.subset2` <character | integer[] | double, environment, integer, tuple<double> | tuple<integer[]> | struct<`.id`:integer> | struct<``:integer, `fn`:character> | struct<`a`:integer, `b`:integer> | struct<`i`:integer> | struct<`x`:character, `y`:integer> | struct<`x`:double> | struct<`n`:double> | struct<`ratio`:double> | tuple<>, integer | tuple<> | struct<`kernel`:character, `epsilon`:double> | struct<`method`:character> | struct<`ntree`:double> | struct<`x`:integer, `y`:character>, tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double> | integer, integer, tuple<>, character, character> => null | tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double> | double | struct<`kernel`:character, `epsilon`:double> | struct<`method`:character> | struct<`ntree`:double> | struct<`x`:integer, `y`:character>;
type `$` <environment | symbol | double | character, environment | language | null | struct<`started`:double, `done`:double, `error`:null, `mem.used`:null> | struct<`started`:double, `done`:double, `error`:character, `mem.used`:null> | struct<`started`:double, `done`:double, `error`:null, `mem.used`:double>, integer, integer, tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double>> => null | struct<`job.id`:integer[], `started`:double[], `done`:double[], `error`:^character[], `mem.used`:^double[], `written`:logical[]> | struct<`status`:integer, `batch.id`:character, `log.file`:null, `msg`:character> | tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double>;
type `addAlgorithm` <character, any => any, environment> => struct<`fun`:any => any, `name`:character>;
type `addExperiments` <null | character | struct<> | struct<`iris`:struct<`ratio`:double[]>> | struct<`p1`:struct<`n`:double[], `mean`:integer[], `sd`:integer[]>> | struct<`prob1`:struct<>, `prob2`:struct<`x`:integer[]>> | struct<`rnorm`:struct<`n`:double[], `mean`:integer[], `sd`:integer[]>, `rexp`:struct<`n`:double[], `lambda`:integer[]>>, null | struct<`nrow`:struct<`x`:integer[], `y`:character[]>> | struct<`ncol`:struct<`x`:integer[], `y`:character[]>> | struct<`svm`:struct<`kernel`:character[], `epsilon`:double[]>, `forest`:struct<`ntree`:double[]>> | struct<`algo`:struct<`i`:integer[]>> | struct<`average`:struct<`method`:character[]>, `deviation`:struct<>>, character | double, character, environment> => struct<`job.id`:integer[]>;
type `addJobTags` <struct<`job.id`:integer[]> | integer[] | double, character, environment> => struct<`job.id`:integer[]>;
type `addProblem` <character, null | struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]> | double[], any => any, null | double, logical, environment> => struct<`name`:character, `seed`:integer, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:double[], `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:null, `fun`:any => any>;
type `addResources` <environment, tuple<tuple<>> | tuple<struct<`foo`:character>> | tuple<struct<`measure.memory`:logical>> | tuple<struct<`memory`:double, `walltime`:double>>> => integer;
type `ai` <struct<`resource.id`:integer, `resource.hash`:character, `resources`:tuple<tuple<>>>, character> => struct<`resource.id`:integer, `resource.hash`:character, `resources`:tuple<tuple<>>>;
type `ajoin` <struct<`job.id`:integer[], `job.pars`:list<struct<`x`:integer>>>, struct<`job.id`:integer[], `extra.col`:character[]>, null> => struct<`job.id`:integer[], `job.pars`:tuple<struct<`x`:integer>, struct<`x`:integer>>>;
type `allIds` <environment> => struct<`job.id`:integer[]>;
type `assertRegistry` <environment, null | character, logical, logical, logical> => logical;
type `batchExport` <tuple<> | struct<`y`:double, `z`:double>, character[], environment> => struct<`name`:character[], `uri`:character[]>;
type `batchMap` <any => any, double[] | null | list<integer[]>, tuple<> | struct<`.id`:integer[]> | struct<>, tuple<> | struct<`y`:double> | struct<`.fn`:character[], `.fun`:any => any> | struct<`z`:double> | struct<`.fun`:any => any, `.init`:double>, environment> => struct<`job.id`:integer[]>;
type `batchMapResults` <any => any, integer[], null, environment, environment> => struct<`job.id`:integer[]>;
type `batchReduce` <any => any, integer[], double, integer[], tuple<>, environment> => struct<`job.id`:integer[]>;
type `binpack` <double[], double> => integer[];
type `btlapply` <double[], any => any, null, tuple<>, null, null, environment> => tuple<double, double, double> | list<double>;
type `btmapply` <any => any, integer[], struct<`z`:double>, logical, logical, tuple<>, null, null, environment> => double[];
type `calculateHash` <struct<`problem`:character[], `algorithm`:character[], `prob.pars`:tuple<tuple<>, tuple<>, tuple<>>, `algo.pars`:tuple<struct<`i`:integer>, struct<`i`:integer>, struct<`i`:integer>>>> => character[];
type `catf` <character, character> => null;
type `chintersect` <null | character[], character[]> => null | character[];
type `chsetdiff` <character[], character[]> => character[];
type `convertDesigns` <character, struct<`algo`:struct<`i`:integer[]>> | struct<`average`:struct<`method`:character[]>, `deviation`:struct<>> | struct<`iris`:struct<`ratio`:double[]>> | struct<`ncol`:struct<`x`:integer[], `y`:character[]>> | struct<`nrow`:struct<`x`:integer[], `y`:character[]>> | struct<`p1`:struct<`n`:double[], `mean`:integer[], `sd`:integer[]>> | struct<`prob1`:struct<>, `prob2`:struct<`x`:integer[]>> | struct<`rnorm`:struct<`n`:double[], `mean`:integer[], `sd`:integer[]>, `rexp`:struct<`n`:double[], `lambda`:integer[]>> | struct<`svm`:struct<`kernel`:character[], `epsilon`:double[]>, `forest`:struct<`ntree`:double[]>>, character[]> => struct<`algo`:struct<`i`:integer[]>> | struct<`average`:struct<`method`:character[]>, `deviation`:struct<>> | struct<`iris`:struct<`ratio`:double[]>> | struct<`ncol`:struct<`x`:integer[], `y`:character[]>> | struct<`nrow`:struct<`x`:integer[], `y`:character[]>> | struct<`p1`:struct<`n`:double[], `mean`:integer[], `sd`:integer[]>> | struct<`prob1`:struct<>, `prob2`:struct<`x`:integer[]>> | struct<`rnorm`:struct<`n`:double[], `mean`:integer[], `sd`:integer[]>, `rexp`:struct<`n`:double[], `lambda`:integer[]>> | struct<`svm`:struct<`kernel`:character[], `epsilon`:double[]>, `forest`:struct<`ntree`:double[]>>;
type `convertIds` <environment, struct<`job.id`:integer[]> | integer[] | double, null | language, character[], logical> => struct<`job.id`:integer[]>;
type `count` <^character[] | ^double[]> => integer;
type `dir` <environment, character> => character;
type `doJobCollection.JobCollection` <environment, null | character> => character;
type `estimateRuntimes` <struct<`job.id`:integer[], `problem`:character[], `algorithm`:character[], `x`:integer[], `y`:character[]>, null, environment> => struct<`runtimes`:struct<`job.id`:integer[], `type`:integer[], `runtime`:double[]>, `model`:struct<`predictions`:double[], `num.trees`:double, `num.independent.variables`:double, `mtry`:double, `min.node.size`:double, `prediction.error`:double, `forest`:struct<`dependent.varID`:double, `num.trees`:double, `child.nodeIDs`:list<tuple<double[], double[]>>, `split.varIDs`:list<double[]>, `split.values`:list<double[]>, `is.ordered`:logical[], `independent.variable.names`:character[], `treetype`:character>, `splitrule`:character, `treetype`:character, `r.squared`:double, `call`:language, `importance.mode`:character, `num.samples`:integer, `replace`:logical>>;
type `execJob.Experiment` <environment> => null | double | ^integer[];
type `execJob.Job` <environment> => null | character | double[] | struct<`sqrt`:double> | struct<`square`:double> | struct<`sum`:integer, `prod`:integer>;
type `extractLog` <struct<`job.id`:^integer[], `lines`:character[]>, struct<`job.id`:integer>> => character[];
type `f` <double, integer> => double;
type `file_mtime` <character> => double;
type `file_remove` <character[]> => null;
type `filter` <character[]> => logical[];
type `findDone` <null, environment> => struct<`job.id`:integer[]>;
type `findErrors` <null | integer[], environment> => struct<`job.id`:integer[]>;
type `findExperiments` <null, null, null, null | character, null, null | language, language | null, null, environment> => struct<`job.id`:integer[]>;
type `findJobs` <language, null, environment> => struct<`job.id`:integer[]>;
type `findNotDone` <null, environment> => struct<`job.id`:integer[]>;
type `findNotSubmitted` <null, environment> => struct<`job.id`:integer[]>;
type `findSubmitted` <null, environment> => struct<`job.id`:integer[]>;
type `findTagged` <character, null, environment> => struct<`job.id`:integer[]>;
type `fun` <symbol, character> => logical;
type `FUN` <struct<`i`:integer> | struct<`n`:double, `mean`:integer, `sd`:integer> | struct<`ntree`:double> | struct<`x`:integer> | integer | tuple<> | struct<`.id`:integer> | struct<`a`:double> | struct<`kernel`:character, `epsilon`:double> | struct<`mce`:double> | struct<`method`:character> | struct<`n`:double, `lambda`:integer> | struct<`n`:double, `p`:double> | struct<`ratio`:double> | struct<`res`:double> | struct<`sqrt`:double> | struct<`square`:double>> => logical | struct<> | tuple<> | struct<`.id`:integer> | struct<`a`:double> | struct<`kernel`:character, `epsilon`:double> | struct<`mce`:double> | struct<`method`:character> | struct<`n`:double, `lambda`:integer> | struct<`n`:double, `mean`:integer, `sd`:integer> | struct<`n`:double, `p`:double> | struct<`ntree`:double> | struct<`ratio`:double> | struct<`res`:double> | struct<`sqrt`:double> | struct<`square`:double> | struct<`x`:integer, `y`:character>;
type `getAlgorithmURI` <environment, character> => character;
type `getBatchIds` <environment, character> => struct<`batch.id`:character[], `status`:character[]>;
type `getDefaultRegistry` < > => environment;
type `getErrorMessages` <null | struct<`job.id`:integer[]>, logical, environment> => struct<`job.id`:integer[], `terminated`:logical[], `error`:logical[], `message`:^character[]>;
type `getExternalDirs` <environment, struct<`job.id`:integer[], `job.hash`:character[]>> => character[];
type `getJob.ExperimentCollection` <environment, integer, environment> => environment;
type `getJob.JobCollection` <environment, integer, environment> => environment;
type `getJobFiles` <environment, character> => character;
type `getJobNames` <null, environment> => struct<`job.id`:integer[], `job.name`:character[]>;
type `getJobPars.ExperimentRegistry` <null | struct<>, environment> => struct<`job.id`:integer[], `problem`:character[], `prob.pars`:tuple<tuple<>, tuple<>>, `algorithm`:character[], `algo.pars`:tuple<tuple<>, tuple<>>>;
type `getJobPars.Registry` <null, environment> => struct<`job.id`:integer[], `job.pars`:tuple<struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>>>;
type `getJobResources` <null, environment> => struct<`job.id`:integer[], `resources`:tuple<tuple<>, tuple<>, tuple<>>>;
type `getJobStatus` <null | struct<>, environment> => struct<`job.id`:integer[], `submitted`:double[], `started`:double[], `done`:double[], `error`:^character[], `mem.used`:double[], `batch.id`:character[], `log.file`:^character[], `job.hash`:character[], `job.name`:^character[], `time.queued`:double[], `time.running`:double[]>;
type `getJobTable` <null, environment> => struct<`job.id`:integer[], `submitted`:double[], `started`:double[], `done`:double[], `error`:^character[], `mem.used`:^double[], `batch.id`:character[], `log.file`:^character[], `job.hash`:character[], `job.name`:^character[], `time.queued`:double[], `time.running`:double[], `job.pars`:tuple<struct<`x`:double>, struct<`x`:double>, struct<`x`:double>>, `resources`:tuple<tuple<>, tuple<>, tuple<>>, `tags`:^character[]>;
type `getJobTags` <null, environment> => struct<`job.id`:integer[], `tags`:^character[]>;
type `getLog` <struct<`job.id`:integer> | double, environment> => character[];
type `getLogFiles` <environment, struct<`job.id`:integer[], `job.hash`:character[]>> => character[];
type `getProblemCacheDir` <environment, character> => character;
type `getProblemURI` <environment, character> => character;
type `getResultFiles` <environment, struct<`job.id`:integer[]> | integer> => character[];
type `getSeed` <integer, integer> => integer;
type `getStatus` <null, environment> => struct<`defined`:integer, `submitted`:integer, `started`:integer, `done`:integer, `error`:integer, `queued`:integer, `running`:integer, `expired`:integer, `system`:integer>;
type `getUsedJobTags` <struct<`job.id`:integer[]>, environment> => character[];
type `grepLogs` <null, character, logical, logical, environment> => struct<`job.id`:integer[], `matches`:character[]>;
type `ijoin` <struct<`job.id`:integer[], `.id`:integer[], `sqrt`:double[]>, struct<`job.id`:integer[], `square`:double[]>, null | character> => struct<`job.id`:integer[], `.id`:integer[], `sqrt`:double[], `square`:double[]>;
type `increment` <integer[], integer> => integer[];
type `info` <character> => null;
type `insert` <tuple<>, tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`walltime`:double, `memory`:double>> => tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double>;
type `is.error` <null | character | struct<> | double[] | ^integer[] | struct<`sqrt`:double> | struct<`square`:double> | struct<`sum`:integer, `prod`:integer>> => logical;
type `list2dt` <struct<`.id`:integer[]> | tuple<double[]> | struct<``:integer[], `fn`:character> | tuple<list<integer[]>> | struct<`a`:integer[], `b`:integer[]> | struct<`i`:double> | struct<`i`:integer[]> | struct<`n`:double[]> | struct<> | struct<`x`:double[]>> => struct<`.id`:integer[]>;
type `ljoin` <struct<`job.id`:integer[], `job.pars`:list<struct<`x`:integer>>>, struct<`job.id`:integer[], `extra.col`:character[]>, null> => struct<`job.id`:integer[], `extra.col`:^character[], `job.pars`:list<struct<`x`:integer>>>;
type `loadRegistryDependencies` <environment, logical> => logical;
type `lpt` <double[], double> => integer[];
type `makeClusterFunctions` <character, any => any, null, null, null | any => any, null, logical, logical, double, double, struct<`pre.sync`:any => any> | tuple<>> => struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:any => any, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:struct<`pre.sync`:any => any>> | struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:null, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:tuple<>>;
type `makeClusterFunctionsInteractive` <logical, logical, double> => struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:null, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:tuple<>>;
type `makeClusterFunctionsSocket` <double, double> => struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:any => any, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:struct<`pre.sync`:any => any>>;
type `makeJob.ExperimentRegistry` <struct<`job.id`:integer>, null, environment> => environment;
type `makeJob.Registry` <struct<`job.id`:integer> | double, null, environment> => environment;
type `makeJobCollection.ExperimentRegistry` <struct<`job.id`:integer, `resource.id`:integer>, tuple<>, environment> => environment;
type `makeJobCollection.Registry` <struct<`job.id`:integer[], `resource.id`:integer[]> | integer[], tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double>, environment> => environment;
type `makeProgressBar` <integer | language> => environment | struct<`tick`:any => any, `update`:any => any>;
type `makeSubmitJobResult` <integer, character, null, null> => struct<`status`:integer, `batch.id`:character, `log.file`:null, `msg`:character>;
type `mangle` <character[]> => character[];
type `mergedJobs` <environment, null | struct<`job.id`:integer[]>, character[]> => struct<`job.id`:integer[], `job.name`:^character[], `job.pars`:tuple<tuple<integer>, tuple<integer>>>;
type `messagef` <character, character> => null;
type `names2` <struct<`kernel`:character, `epsilon`:double> | struct<`n`:double, `lambda`:integer> | struct<`n`:double, `mean`:integer, `sd`:integer> | struct<`n`:double, `p`:double> | struct<`walltime`:double, `memory`:double> | struct<`x`:integer, `y`:character> | struct<`.id`:integer> | struct<`a`:double> | struct<`foo`:character> | struct<`mce`:double> | struct<`measure.memory`:logical> | struct<`method`:character> | struct<`ntree`:double> | struct<`ratio`:double> | struct<`res`:double> | struct<`sqrt`:double> | struct<`square`:double>, null> => character[];
type `now` < > => character;
type `ojoin` <struct<`job.id`:integer[], `job.pars`:list<struct<`x`:integer>>>, struct<`job.id`:integer[], `extra.col`:character[]>, null> => struct<`job.id`:integer[], `job.pars`:list<struct<`x`:integer>>, `extra.col`:^character[]>;
type `pr` <character, integer> => null;
type `print.Registry` <environment, null> => null;
type `print.RuntimeEstimate` <struct<`runtimes`:struct<`job.id`:integer[], `type`:integer[], `runtime`:double[]>, `model`:struct<`predictions`:double[], `num.trees`:double, `num.independent.variables`:double, `mtry`:double, `min.node.size`:double, `prediction.error`:double, `forest`:struct<`dependent.varID`:double, `num.trees`:double, `child.nodeIDs`:list<tuple<double[], double[]>>, `split.varIDs`:list<double[]>, `split.values`:list<double[]>, `is.ordered`:logical[], `independent.variable.names`:character[], `treetype`:character>, `splitrule`:character, `treetype`:character, `r.squared`:double, `call`:language, `importance.mode`:character, `num.samples`:integer, `replace`:logical>>, double, null> => null;
type `print.Status` <struct<`defined`:integer, `submitted`:integer, `started`:integer, `done`:integer, `error`:integer, `queued`:integer, `running`:integer, `expired`:integer, `system`:integer>, null> => null;
type `ps` <double, integer> => character;
type `read` <character> => null | any => any | struct<`.fn`:character[], `.fun`:any => any> | struct<`.fun`:any => any, `.init`:double> | struct<`fun`:any => any, `name`:character> | struct<`name`:character, `seed`:integer, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:null, `fun`:any => any> | struct<`y`:double> | struct<`z`:double>;
type `readLog` <struct<`job.id`:integer>, logical, environment> => struct<`job.id`:^integer[], `lines`:character[]>;
type `reduceResultsDataTable` <null | struct<>, null | any => any, null, null, environment> => struct<`job.id`:integer[], `result`:list<struct<`mce`:double>>>;
type `reduceResultsList` <null | struct<>, null | any => any, null, null, environment> => tuple<struct<`sum`:integer, `prod`:integer>, struct<`sum`:integer, `prod`:integer>, struct<`sum`:integer, `prod`:integer>> | tuple<double, double, double> | list<double>;
type `removeJobTags` <struct<`job.id`:integer[], `chunk`:integer[], `resource.id`:integer[]>, character, environment> => struct<`job.id`:integer[]>;
type `removeProblems` <character, environment> => logical;
type `removeRegistry` <double, environment> => character;
type `rjoin` <struct<`job.id`:integer[], `job.pars`:tuple<struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>>>, struct<`job.id`:integer[], `result`:tuple<struct<`sqrt`:double>, struct<`sqrt`:double>, struct<`sqrt`:double>, struct<`sqrt`:double>, struct<`sqrt`:double>>>, null> => struct<`job.id`:integer[], `job.pars`:tuple<struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>, struct<`.id`:integer>>, `result`:tuple<struct<`sqrt`:double>, struct<`sqrt`:double>, struct<`sqrt`:double>, struct<`sqrt`:double>, struct<`sqrt`:double>>>;
type `rnd_hash` <character> => character;
type `seq_row` <struct<`.id`:integer[]>> => integer[];
type `setClasses` <struct<`defined`:integer, `submitted`:integer, `started`:integer, `done`:integer, `error`:integer, `queued`:integer, `running`:integer, `expired`:integer, `system`:integer> | environment | struct<`fun`:any => any, `name`:character> | struct<`name`:character, `seed`:integer, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:double[], `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:null, `fun`:any => any> | struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:any => any, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:struct<`pre.sync`:any => any>> | struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:null, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:tuple<>> | struct<`status`:integer, `batch.id`:character, `log.file`:null, `msg`:character>, character[]> => struct<`defined`:integer, `submitted`:integer, `started`:integer, `done`:integer, `error`:integer, `queued`:integer, `running`:integer, `expired`:integer, `system`:integer> | environment | struct<`fun`:any => any, `name`:character> | struct<`name`:character, `seed`:integer, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:double[], `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:null, `fun`:any => any> | struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:any => any, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:struct<`pre.sync`:any => any>> | struct<`name`:character, `submitJob`:any => any, `killJob`:null, `listJobsQueued`:null, `listJobsRunning`:null, `array.var`:null, `store.job.collection`:logical, `store.job.files`:logical, `scheduler.latency`:double, `fs.latency`:double, `hooks`:tuple<>> | struct<`status`:integer, `batch.id`:character, `log.file`:null, `msg`:character>;
type `setJobNames` <struct<`job.id`:integer[]>, character[], environment> => null;
type `setKey` <struct<`job.id`:integer[], `.id`:integer[], `sqrt`:double[], `square`:double[]>, character> => struct<`job.id`:integer[], `.id`:integer[], `sqrt`:double[], `square`:double[]>;
type `setSystemConf` <environment, null> => null;
type `sjoin` <struct<`job.id`:integer[], `job.pars`:list<struct<`x`:integer>>>, struct<`job.id`:integer[], `extra.col`:character[]>, null> => struct<`job.id`:integer[], `job.pars`:tuple<struct<`x`:integer>, struct<`x`:integer>, struct<`x`:integer>, struct<`x`:integer>>>;
type `summarizeExperiments` <null, character[], environment> => struct<`problem`:character[], `algorithm`:character[], `.count`:integer[]>;
type `sweepRegistry` <environment> => logical;
type `sync` <environment> => logical;
type `testJob` <double | struct<>, logical, environment> => character | double | ^integer[];
type `unmangle` <character[]> => character[];
type `unwrap` <struct<`id`:integer[], `values`:tuple<struct<`a`:double, `b`:double>, struct<`a`:double, `b`:double>, struct<`a`:double>>>, null, null | character> => struct<`id`:integer[], `a`:double[], `b`:^double[]>;
type `ustamp` < > => double;
type `vcapply` <tuple<tuple<>> | tuple<struct<`foo`:character>> | tuple<struct<`measure.memory`:logical>> | tuple<struct<`memory`:double, `walltime`:double>>, any => any, null, logical> => character;
type `vlapply` <tuple<> | tuple<struct<`job.id`:integer, `started`:double, `done`:double, `error`:character, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>> | tuple<struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:double>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:double>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:double>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:double>> | tuple<struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:character, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>> | list<struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null> | struct<`job.id`:integer, `started`:double, `done`:double, `error`:character, `mem.used`:null>> | tuple<struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:character, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>> | tuple<struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>, struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>> | list<struct<`job.id`:integer, `started`:double, `done`:double, `error`:null, `mem.used`:null>> | tuple<struct<`i`:integer>, struct<`i`:integer>, struct<`i`:integer>> | list<struct<`n`:double, `mean`:integer, `sd`:integer>> | list<struct<`ntree`:double>> | list<struct<`x`:integer>> | character[] | struct<> | struct<`kernel`:character, `epsilon`:double> | struct<`n`:double, `lambda`:integer> | struct<`n`:double, `mean`:integer, `sd`:integer> | struct<`n`:double, `p`:double> | struct<`x`:integer, `y`:character> | struct<`.id`:integer> | struct<`a`:double> | struct<`mce`:double> | struct<`method`:character> | struct<`ntree`:double> | struct<`ratio`:double> | struct<`res`:double> | struct<`sqrt`:double> | struct<`square`:double>, any => any, language | null | character[] | logical, logical> => logical[];
type `vnapply` <struct<`1`:double[], `2`:double[], `3`:double[], `4`:double[], `5`:double[], `6`:double[], `7`:double[], `8`:double[], `9`:double[], `10`:double[]>, any => any, null, logical> => double[];
type `waitForResults` <symbol> => logical;
type `worker` <struct<`sum`:integer, `prod`:integer> | ^integer[] | double[] | struct<`sqrt`:double> | struct<`square`:double>, language, null> => struct<`sum`:integer, `prod`:integer> | double | struct<`mce`:double> | struct<`res`:double> | struct<`sqrt`:double> | struct<`square`:double>;
type `writeRDS` <null | any => any | character | struct<> | double[] | environment | ^integer[] | struct<`.fn`:character[], `.fun`:any => any> | struct<`.fun`:any => any, `.init`:double> | struct<`fun`:any => any, `name`:character> | struct<`name`:character, `seed`:integer, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]>, `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:double[], `fun`:any => any> | struct<`name`:character, `seed`:null, `cache`:logical, `data`:null, `fun`:any => any> | struct<`sqrt`:double> | struct<`square`:double> | struct<`sum`:integer, `prod`:integer> | struct<`y`:double> | struct<`z`:double>, character> => logical;
