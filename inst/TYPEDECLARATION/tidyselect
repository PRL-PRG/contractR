type `::` <character[], ..., character[], character[], logical> => any;
type `[[` <class<`condition`, `error`, `rlang_error`, `vctrs_error_subscript`, `vctrs_error_subscript_oob`>> => any;
type `all_of` <character[]> => character[];
type `any_of` <character[], ..., character[]> => integer;
type `are_empty_name` <character[]> => logical[];
type `as_indices_impl` <character[] | integer[], any, logical> => any;
type `as_indices_sel_impl` <character[] | integer[], any, logical, any> => any;
type `call_expand_dots` <class<`call`>, any> => class<`call`>;
type `call_kind` <class<`call`>> => character;
type `c_arg_kind` <class<`formula`, `quosure`> | class<`name`>> => character;
type `check_match` <character[]> => null;
type `check_missing` <integer[]> => null;
type `check_negative` <integer[]> => null;
type `chr_as_locations` <character[], character[]> => any;
type `combine_names` <integer, class<`name`>, class<`function`>, logical> => integer;
type `contains` <character, logical, character[]> => integer[];
type `ends_with` <character, logical, character[]> => integer[];
type `eval_and` <class<`call`>, environment, environment> => integer;
type `eval_bang` <class<`call`>, environment, environment> => integer[];
type `eval_c` <class<`call`>, environment, any> => any;
type `eval_colon` <class<`call`>, environment, any> => integer[];
type `eval_context` <class<`call`>, environment> => (character[] | integer[]);
type `eval_or` <class<`call`>, environment, environment> => integer[];
type `eval_rename` <class<`call`> | class<`name`>, class<`data.frame`>, environment, ..., logical, null> => any;
type `eval_select` <class<`call`>, class<`data.frame`>, environment, ..., null, null, logical, null> => integer[];
type `eval_select_impl` <null | class<`data.frame`>, character[], class<`call`> | class<`formula`, `quosure`>, character[] | null, character[] | null, logical, class<`function`> | null, logical | null, character> => (integer[] | list<any>);
type `eval_slash` <class<`call`>, environment, environment> => integer;
type `eval_sym` <class<`name`>, environment, any, logical> => integer;
type `everything` <character[]> => integer[];
type `expr_kind` <class<`call`> | class<`name`> | integer[]> => character;
type `.f` <character, character[], ...> => integer[] | <character, character[]> => integer[] | <character, character[], integer[]> => integer[] | <integer> => integer;
type `filter` <character[]> => logical[];
type `flat_map_int` <character[], class<`function`>, ...> => integer[];
type `.fn` <..., any, any, character[]> => logical;
type `fun` <...> => null;
type `instrument_base_errors` <any> => any;
type `is_character` <character[], null> => logical;
type `is_data_dups` <integer> => logical;
type `isNamespaceLoaded` <character> => logical;
type `is_negated` <class<`formula`, `quosure`> | class<`name`>> => logical;
type `is_negated_colon` <class<`call`> | class<`formula`, `quosure`> | class<`name`>> => logical;
type `last_col` <double, character[]> => integer;
type `local_data` <class<`data.frame`> | null, environment> => null;
type `local_vars` <character[], environment> => (character[] | null);
type `loc_validate` <integer[], character[]> => integer[];
type `matches` <character, logical, logical, character[]> => integer[];
type `match_vars` <character[], character[]> => integer[];
type `maybe_hotpatch_dplyr` <...> => logical;
type `named` <integer[]> => integer[];
type `node_compact_missing` <class<`call`>> => class<`call`>;
type `node_poke_tail` <class<`list`, `quosures`>, null> => class<`list`, `quosures`>;
type `node_tail` <class<`list`, `quosures`>> => class<`list`, `quosures`>;
type `one_of` <..., character[]> => integer[];
type `peek_vars` <..., character | null> => character[];
type `poke_data` <class<`data.frame`> | null> => (null | class<`data.frame`>);
type `poke_vars` <character[] | null> => (character[] | null);
type `propagate_names` <class<`data.frame`>, any> => class<`data.frame`>;
type `pull_as_location2` <double, integer, any> => integer;
type `quo_get_expr2` <class<`call`> | class<`formula`, `quosure`> | class<`name`>, any> => (class<`call`> | class<`name`>);
type `reduce_sels` <pairlist | class<`list`, `quosures`>, environment, any, class<`call`> | integer[]> => any;
type `rename_impl` <class<`data.frame`>, character[], class<`formula`, `quosure`>, logical, null> => any;
type `scoped_vars` <character[], environment> => (character[] | null);
type `sel_complement` <integer[], character[]> => integer[];
type `sel_diff` <integer[], integer[], character[]> => integer[];
type `sel_intersect` <integer[], integer[]> => integer;
type `sel_op` <class<`data.frame`> | integer[], class<`data.frame`> | integer[]> => (class<`data.frame`> | integer[]);
type `sel_operation` <integer[], integer[], class<`function`>> => integer[];
type `sel_union` <integer[], integer[]> => integer[];
type `sel_unique` <integer[]> => integer[];
type `set_diff` <integer[], integer[]> => integer[];
type `set_intersect` <character[] | integer[], ^character[] | integer[]> => (character | integer);
type `set_union` <class<`data.frame`> | integer[], class<`data.frame`> | integer[]> => (class<`data.frame`> | integer[]);
type `starts_with` <character[], logical, character[]> => integer[];
type `subscript_action` <character> => character;
type `unnegate` <class<`formula`, `quosure`>> => class<`formula`, `quosure`>;
type `validate_type` <character> => character;
type `vars_pull` <character[], any> => character;
type `vars_select` <character[], ..., character[], character[], logical> => any;
type `vars_select_eval` <any, class<`call`> | class<`formula`, `quosure`>, logical, null | class<`data.frame`>, class<`function`> | null, logical | null, any> => any;
type `vars_validate` <character[]> => character[];
type `vec_is_coercible` <character[], character[], ..., character, character> => logical;
type `walk_data_tree` <class<`call`> | class<`formula`, `quosure`> | class<`name`> | integer[], environment, any, logical> => any;
type `walk_operand` <class<`call`>, environment, environment> => integer[];
type `which_vars` <character, character[]> => integer[];
type `with_subscript_errors` <any, any> => any;
type `with_vars` <character[], integer[]> => integer[];
