type `_fseq` <character[] | struct<> | struct<`0`:struct<`cyl`:integer[], `gear`:integer[], `am`:character[]>, `1`:struct<`cyl`:integer[], `gear`:integer[], `am`:character[]>> | struct<`female`:struct<`eye_color`:integer[], `skin_color`:integer[], `gender`:character[]>, `male`:struct<`eye_color`:integer[], `skin_color`:integer[], `gender`:character[]>> | struct<`female`:struct<`eye_color`:character[], `skin_color`:character[], `gender`:character[]>, `male`:struct<`eye_color`:character[], `skin_color`:character[], `gender`:character[]>> | struct<``:language>> => character[] | struct<> | struct<`0`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>, `1`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>> | struct<`mpg`:language, `hp`:language> | struct<`p.value`:double, `alternative`:character, `method`:character, `data.name`:character> | struct<`statistic`:double, `parameter`:integer, `p.value`:double, `method`:character, `data.name`:character, `observed`:^double[], `expected`:^double[], `residuals`:^double[], `stdres`:^double[]> | struct<`wt`:language>;
type `.f` <struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]> | character[] | double[], character | double | language | symbol, character | language | struct<> | symbol, logical | symbol, character | logical> => struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]> | character | double;
type `[[` <struct<`x4`:double[], `x6`:double[], `x8`:double[]> | ^double[] | struct<`0`:struct<`cyl`:integer[], `gear`:integer[], `am`:character[]>, `1`:struct<`cyl`:integer[], `gear`:integer[], `am`:character[]>> | struct<`female`:struct<`eye_color`:character[], `skin_color`:character[], `gender`:character[]>, `male`:struct<`eye_color`:character[], `skin_color`:character[], `gender`:character[]>> | struct<`female`:struct<`eye_color`:integer[], `skin_color`:integer[], `gender`:character[]>, `male`:struct<`eye_color`:integer[], `skin_color`:integer[], `gender`:character[]>> | struct<`0`:struct<`cyl`:integer[], `3`:double[], `4`:double[], `5`:double[]>, `1`:struct<`cyl`:integer[], `3`:double[], `4`:double[], `5`:double[]>> | struct<`female`:struct<`eye_color`:integer[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>, `male`:struct<`eye_color`:integer[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>> | struct<``:language> | ^character[]> => struct<`Total`:double[]> | ^double[] | struct<`statistic`:double, `parameter`:integer, `p.value`:double, `method`:character, `data.name`:character, `observed`:^double[], `expected`:^double[], `residuals`:^double[], `stdres`:^double[]> | struct<`p.value`:double, `alternative`:character, `method`:character, `data.name`:character> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>> | struct<`female`:struct<`eye_color`:integer[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>, `male`:struct<`eye_color`:integer[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>> | struct<`0`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>, `1`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>> | struct<`mpg`:language, `hp`:language> | struct<`wt`:language> | ^character[];
type `adorn_ns` <struct<`cyl`:double[], `0`:double[], `1`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:character[], `light`:character[]>, `male`:struct<`eye_color`:character[], `dark`:character[], `fair`:character[], `light`:character[], `pale`:character[], `tan`:character[], `white`:character[]>>, character, struct<`cyl`:double[], `0`:double[], `1`:double[]> | language> => struct<`cyl`:double[], `0`:character[], `1`:character[]> | struct<`female`:struct<`eye_color`:character[], `fair`:character[], `light`:character[]>, `male`:struct<`eye_color`:character[], `dark`:character[], `fair`:character[], `light`:character[], `pale`:character[], `tan`:character[], `white`:character[]>>;
type `adorn_pct_formatting` <struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>, double, character, logical> => struct<`am`:double[], `4`:character[], `6`:character[], `8`:character[]> | struct<`female`:struct<`eye_color`:character[], `fair`:character[], `light`:character[]>, `male`:struct<`eye_color`:character[], `dark`:character[], `fair`:character[], `light`:character[], `pale`:character[], `tan`:character[], `white`:character[]>>;
type `adorn_percentages` <struct<`am`:character[], `4`:double[], `6`:double[], `8`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>, character, logical> => struct<`am`:character[], `4`:double[], `6`:double[], `8`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>;
type `adorn_rounding` <struct<`4`:double[], `6`:double[], `8`:double[]>, double, character, logical> => struct<`4`:double[], `6`:double[], `8`:double[]>;
type `adorn_title` <struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:character[], `light`:character[]>, `male`:struct<`eye_color`:character[], `dark`:character[], `fair`:character[], `light`:character[], `pale`:character[], `tan`:character[], `white`:character[]>>, character, ??? | character, ??? | character> => struct<``:character[], `cyl`:character[], ``:character[], ``:character[]> | struct<`female`:struct<``:character[], `skin_color`:character[], ``:character[]>, `male`:struct<``:character[], `skin_color`:character[], ``:character[], ``:character[], ``:character[], ``:character[], ``:character[]>>;
type `adorn_totals` <struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>, character[], character, logical, character> => struct<`am`:character[], `4`:double[], `6`:double[], `8`:double[]> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>;
type `as_tabyl` <struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]>, double, ? character, ? character> => struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]>;
type `check_vars_in_df` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, symbol, character[]> => null;
type `chisq.test.tabyl` <struct<`gear`:double[], `4`:double[], `6`:double[], `8`:double[]>, logical, ???> => struct<`statistic`:double, `parameter`:integer, `p.value`:double, `method`:character, `data.name`:character, `observed`:struct<`gear`:character[], `4`:double[], `6`:double[], `8`:double[]>, `expected`:struct<`gear`:character[], `4`:double[], `6`:double[], `8`:double[]>, `residuals`:struct<`gear`:character[], `4`:double[], `6`:double[], `8`:double[]>, `stdres`:struct<`gear`:character[], `4`:double[], `6`:double[], `8`:double[]>>;
type `clean_names.default` <struct<`firstName`:null, `Ã¡bc@!*`:null, `% successful (2009)`:null, `REPEAT VALUE`:null, `REPEAT VALUE`:null, ``:null>, character[]> => struct<`first_name`:null, `abc`:null, `percent_successful_2009`:null, `repeat_value`:null, `repeat_value_2`:null, `x`:null>;
type `compare_df_cols` <struct<`A`:double> | struct<`dfA`:struct<`A`:double>, `dfB`:struct<`B`:double>>, character[], character[], logical> => struct<`column_name`:character[], `..1`:character[], `..2`:character[]>;
type `compare_df_cols_df_maker.data.frame` <struct<`a`:integer[], `b`:character[], `c`:double[]>, character, symbol | logical> => struct<`column_name`:character[], `..1`:character[]>;
type `compare_df_cols_df_maker.list` <tuple<struct<`a`:integer[], `b`:character[], `c`:double[]>, struct<`a`:integer[], `b`:character[]>> | tuple<struct<`a`:integer[], `b`:integer[]>, struct<`a`:integer[], `b`:character[]>> | tuple<struct<`A`:double>, struct<`B`:double>> | struct<`dfA`:struct<`A`:double>, `dfB`:struct<`B`:double>> | struct<`listA`:struct<`dfA`:struct<`A`:double>, `dfB`:struct<`B`:double>>, ``:struct<`A`:double>> | tuple<struct<`A`:double>, struct<`A`:double>>, character[] | tuple<character[], character>, symbol | logical> => struct<`column_name`:character[], `..1`:character[], `..2`:^character[]>;
type `compare_df_cols_same` <struct<`A`:double>, character[], logical> => logical;
type `describe_class.default` <character[] | double[], symbol | logical> => character;
type `describe_class.factor` <integer[], logical> => character;
type `excel_numeric_to_date` <double, character, logical, logical, character> => double;
type `f` <struct<`column_name`:character[], `..1`:character[]>, struct<`column_name`:character[], `..2`:character[]>> => struct<`column_name`:character[], `..1`:character[], `..2`:^character[]>;
type `filter` <character[]> => logical[];
type `fisher.test.tabyl` <struct<`gear`:double[], `4`:double[], `6`:double[], `8`:double[]>, ???> => struct<`p.value`:double, `alternative`:character, `method`:character, `data.name`:character>;
type `FUN` <character[] | double[]> => struct<> | character[] | double[];
type `get_dupes` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, symbol> => struct<`mpg`:double[], `hp`:double[], `dupe_count`:integer[], `cyl`:double[], `disp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>;
type `get_level_groups` <integer[], double, integer> => struct<`top`:character, `mid`:character, `bot`:character>;
type `handle_if_special_names_used` <struct<`am`:double[], `n`:double[], `percent`:double[]>> => struct<`am`:double[], `n`:double[], `percent`:double[]>;
type `make_clean_names` <character[], character[]> => character[];
type `paste_matrices` <struct<`cyl`:double[], `0`:double[], `1`:double[]>, struct<`cyl`:character[], `0`:character[], `1`:character[]>> => struct<`cyl`:double[], `0`:character[], `1`:character[]>;
type `remove_constant` <struct<`A`:double[], `B`:integer[]>, logical> => struct<`B`:integer[]>;
type `remove_empty` <struct<`v1`:^double[], `v2`:^logical[], `v3`:^integer[]>, character[]> => struct<`v1`:double[], `v3`:integer[]>;
type `repair_fun` <character[], character[]> => character[];
type `round_half_up` <double[], double> => double[];
type `round_to_fraction` <double[], double[], character | double> => double[];
type `row_to_names` <struct<`X_1`:^integer[], `X_2`:^integer[]>, double, logical, logical> => struct<`ID`:integer[], `Value`:integer[]>;
type `tabyl_1way` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, language, logical, logical> => struct<`am`:double[], `n`:double[], `percent`:double[]>;
type `tabyl_2way` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, language, language, logical, logical> => struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]>;
type `tabyl_3way` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, language, language, language, logical, logical> => struct<`0`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>, `1`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>;
type `tabyl.data.frame` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, symbol, symbol | ???, ??? | symbol, logical, logical, ???> => struct<`am`:double[], `4`:double[], `6`:double[], `8`:double[]> | struct<`0`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>, `1`:struct<`cyl`:double[], `3`:double[], `4`:double[], `5`:double[]>> | struct<`female`:struct<`eye_color`:character[], `fair`:double[], `light`:double[]>, `male`:struct<`eye_color`:character[], `dark`:double[], `fair`:double[], `light`:double[], `pale`:double[], `tan`:double[], `white`:double[]>>;
type `tabyl.default` <integer[] | ^character[], logical, logical, ???> => struct<`new_vec`:integer[], `n`:double[], `percent`:double[]>;
type `top_levels` <integer[], double, logical> => struct<`as.factor(mtcars$hp)`:integer[], `n`:double[], `percent`:double[]>;
type `untabyl` <struct<`am`:double[], `n`:double[], `percent`:double[]>> => struct<`am`:double[], `n`:double[], `percent`:double[]>;
