type `::` <class<`matrix`>, double, double, ...> => class<`fractions`, `matrix`>;
type `addterm` <class<`aov`, `lm`> | class<`glm`, `lm`> | class<`polr`>, ...> => class<`anova`, `data.frame`>;
type `addterm.default` <class<`polr`>, character[], double, character[], double, logical, double, ...> => class<`anova`, `data.frame`>;
type `addterm.glm` <class<`glm`, `lm`>, class<`formula`>, double, character, double, logical, logical, ...> => class<`anova`, `data.frame`>;
type `addterm.lm` <class<`aov`, `lm`>, character[] | class<`aov`, `lm`>, double, character[], double, logical, ...> => class<`anova`, `data.frame`>;
type `anova.loglm` <class<`loglm`>, ..., character[]> => class<`anova.loglm`>;
type `anova.negbin` <class<`glm`, `lm`, `negbin`>, ..., character> => (class<`anova`, `data.frame`> | class<`Anova`, `data.frame`>);
type `area` <class<`function`>, double, double, ..., double, double, any, double> => double;
type `bandwidth.nrd` <double[]> => double;
type `bcv` <double[], double, double, double> => double;
type `biplot.bdr` <class<`matrix`>, class<`matrix`>, any, double[], null, null, null, null, ...> => null;
type `biplot.correspondence` <class<`correspondence`>, character[], ...> => null;
type `boxcox` <class<`formula`>, ...> => list<double[]>;
type `boxcox.default` <class<`lm`>, double[], logical, logical, double, expression, character, ...> => list<double[]>;
type `boxcox.formula` <class<`formula`>, double[], logical, any, any, any, character, ...> => list<double[]>;
type `chi` <double[], double> => double[];
type `confint.glm` <class<`glm`, `lm`>, any, double, logical, ...> => (class<`matrix`> | double[]);
type `confint.nls` <class<`nls`>, character, double, ...> => double[];
type `confint.profile.glm` <class<`profile`, `profile.glm`>, integer[], double, ...> => (class<`matrix`> | double[]);
type `confint.profile.nls` <class<`profile`, `profile.nls`>, character, double, ...> => double[];
type `contr.sdif` <double, logical, logical> => class<`matrix`>;
type `corresp` <class<`data.frame`> | class<`formula`>, ...> => class<`correspondence`>;
type `corresp.data.frame` <class<`data.frame`>, ...> => class<`correspondence`>;
type `corresp.formula` <class<`formula`>, class<`data.frame`>, ...> => class<`correspondence`>;
type `corresp.matrix` <class<`matrix`> | class<`table`>, double, ...> => class<`correspondence`>;
type `cov.rob` <class<`matrix`> | class<`data.frame`>, logical, double, character[], character, any> => list<double[] | class<`matrix`> | character>;
type `cov.trob` <class<`data.frame`>, double[], logical, logical, double, double, double> => list<class<`matrix`> | double[] | class<`call`>>;
type `cut.string` <character> => character;
type `dens` <double[], double[], ...> => double[] | <double[], double[], ...> => double[];
type `densfun` <double[], double, double, double, logical> => double[];
type `denumerate` <class<`formula`> | class<`formula`, `terms`>> => (class<`formula`> | class<`formula`, `terms`>);
type `denumerate.formula` <class<`(`> | class<`call`> | class<`name`> | double | class<`formula`> | class<`formula`, `terms`>> => (class<`(`> | class<`call`> | class<`name`> | class<`formula`> | class<`formula`, `terms`>);
type `dose.p` <class<`glm`, `lm`>, double[], double[]> => class<`glm.dose`>;
type `dropterm` <class<`aov`, `lm`> | class<`glm`, `lm`> | class<`polr`>, ...> => class<`anova`, `data.frame`>;
type `dropterm.default` <class<`polr`>, character[], double, character[], double, logical, double, ...> => class<`anova`, `data.frame`>;
type `dropterm.glm` <class<`glm`, `lm`>, any, double, character[], double, logical, logical, ...> => class<`anova`, `data.frame`>;
type `dropterm.lm` <class<`aov`, `lm`>, character[], double, character[], double, logical, ...> => class<`anova`, `data.frame`>;
type `eqscplot` <class<`matrix`>, any, double, double, any, ...> => null;
type `expand.range` <double[]> => double[];
type `extractAIC.polr` <class<`polr`>, any, double, ...> => double[];
type `f` <double, integer[], integer, double> => double | <double, integer[], double, double, integer, double> => double;
type `filter` <character[]> => logical[];
type `fitdistr` <double[], character | class<`function`>, any, ...> => class<`fitdistr`>;
type `fn` <double[]> => double | <double[], ...> => double | <double[], ...> => double;
type `fractions` <class<`matrix`>, double, double, ...> => class<`fractions`, `matrix`>;
type `fSD` <double, integer[], double, double, integer, double> => double;
type `Fstat` <class<`anova`, `data.frame`>, double, integer> => list<^double[]>;
type `FUN` <class<`glm`, `lm`, `negbin`>> => integer | <class<`factor`>> => class<`matrix`> | <class<`glm`, `lm`, `negbin`>> => double | <logical[], integer[], character[]> => integer[] | <integer> => (integer[] | null) | <class<`loglm`>> => (class<`call`> | class<`formula`>) | <class<`glm`, `lm`, `negbin`>> => double | <class<`glm`, `lm`, `negbin`>> => character | <character[]> => character | <double[]> => double[] | <class<`glm`, `lm`, `negbin`>> => character;
type `gamma.dispersion` <class<`glm`, `lm`>, ...> => double;
type `gamma.shape` <class<`glm`, `lm`>, ...> => class<`gamma.shape`>;
type `gamma.shape.glm` <class<`glm`, `lm`>, double, double, logical, ...> => class<`gamma.shape`>;
type `ginv` <class<`matrix`>, double> => class<`matrix`>;
type `glm.convert` <class<`glm`, `lm`, `negbin`>> => class<`glm`, `lm`>;
type `glmmPQL` <class<`formula`>, class<`formula`>, class<`function`>, class<`data.frame`>, any, any, any, double, logical, ...> => class<`glmmPQL`, `lme`>;
type `glm.nb` <any, any, any, any, any, null | double[], any, any, list<double>, character, logical, logical> => any;
type `gr` <double[]> => double[];
type `huber` <double[], double, double> => list<double>;
type `hubers` <double[], double, any, any, any, double> => list<double>;
type `info` <any, double, double[], double[], double[]> => double;
type `isoMDS` <class<`dist`>, class<`matrix`>, double, double, logical, double, double> => list<class<`matrix`> | double>;
type `jacobian` <double[]> => class<`matrix`>;
type `kde2d` <double[], double[], any, double, double[]> => list<double[] | class<`matrix`>>;
type `lda` <any, ...> => class<`lda`>;
type `lda.default` <class<`matrix`>, class<`factor`>, double[], double, character[], logical, double, ...> => class<`lda`>;
type `lda.formula` <class<`formula`>, any, ..., any, any> => class<`lda`>;
type `lm.ridge` <any, any, any, any, double[], logical, logical, logical, null, ...> => class<`ridgelm`>;
type `lmwork` <class<`aov`, `lm`>> => list<double[]>;
type `logit` <double[]> => double[];
type `loglik` <any, double, double[], double[], double[]> => double;
type `logLik.glmmPQL` <class<`glmmPQL`, `lme`>, ...> => class<`logLik`>;
type `loglm` <any, class<`data.frame`> | class<`table`, `xtabs`>, any, any, ...> => class<`loglm`>;
type `loglm1` <any, class<`data.frame`> | class<`table`, `xtabs`>, ...> => class<`loglm`>;
type `loglm1.data.frame` <any, class<`data.frame`>, ...> => class<`loglm`>;
type `loglm1.default` <any, class<`array`> | class<`matrix`>, class<`array`> | double[], logical, logical, logical, double, double, logical, ...> => class<`loglm`>;
type `loglm1.xtabs` <any, class<`table`, `xtabs`>, ...> => class<`loglm`>;
type `logtrans` <class<`formula`>, ...> => list<double[]>;
type `logtrans.default` <class<`aov`, `lm`>, ..., double[], logical, logical, character, character> => list<double[]>;
type `logtrans.formula` <class<`formula`>, class<`data.frame`>, ...> => list<double[]>;
type `lqs` <class<`formula`>, ...> => class<`lqs`>;
type `lqs.control` <null, character, logical> => list<null | character | logical>;
type `lqs.default` <class<`matrix`>, double[], logical, character, any, list<null | character | logical>, double, any, ...> => class<`lqs`>;
type `lqs.formula` <class<`formula`>, any, ..., character[], any, any, logical, logical, logical, null> => class<`lqs`>;
type `margs` <...> => integer;
type `mca` <class<`data.frame`>, double, logical> => class<`mca`>;
type `mvrnorm` <double, double[], class<`matrix`>, double, logical, logical> => class<`matrix`>;
type `mydeviance` <class<`aov`, `lm`> | class<`polr`>, ...> => double;
type `negative.binomial` <double, any> => class<`family`>;
type `nobs.polr` <class<`polr`>, ...> => integer;
type `Ops.fractions` <class<`fractions`, `matrix`>, double> => class<`fractions`, `matrix`>;
type `pairs.profile` <class<`profile`, `profile.glm`>, integer[], ...> => double[];
type `plot.correspondence` <class<`correspondence`>, double, ...> => null;
type `plot.mca` <class<`mca`>, logical, any, double, ...> => class<`mca`>;
type `plot.profile` <class<`profile`, `profile.glm`>, ...> => null;
type `plot.ridgelm` <class<`ridgelm`>, ...> => null;
type `polr` <any, any, any, any, ..., any, any, null, logical, logical, character[]> => class<`polr`>;
type `polr.fit` <class<`matrix`>, integer[], integer[], double[], double[], character, ...> => list<double[] | list<double[] | null>>;
type `predict.lda` <class<`lda`>, class<`data.frame`>, double[], any, character[], ...> => list<class<`factor`> | class<`matrix`>>;
type `predict.polr` <class<`polr`>, class<`data.frame`>, character, ...> => class<`matrix`>;
type `profile.glm` <class<`glm`, `lm`>, integer[], double, double, double, logical, ...> => class<`profile`, `profile.glm`>;
type `psi` <double[], double> => double[];
type `.rat` <class<`matrix`>, double, double> => list<class<`matrix`>>;
type `renumerate` <class<`formula`> | class<`formula`, `terms`>> => (class<`formula`> | class<`formula`, `terms`>);
type `renumerate.formula` <class<`call`> | class<`name`> | class<`formula`> | class<`formula`, `terms`>> => (class<`call`> | class<`name`> | class<`formula`> | class<`formula`, `terms`>);
type `rnegbin` <double, double, double> => integer[];
type `safe_pchisq` <double[], double[], ...> => double[];
type `safe_pf` <double[], double[], ...> => double[];
type `scale.simp` <class<`matrix`>, double[], integer, integer> => class<`matrix`>;
type `score` <any, double, double[], double[], double[]> => double;
type `SDh` <integer[], double, integer, double> => double;
type `select` <class<`ridgelm`>> => null;
type `select.ridgelm` <class<`ridgelm`>> => null;
type `Shepard` <class<`dist`>, class<`matrix`>, double> => list<double[]>;
type `stepAIC` <class<`aov`, `lm`> | class<`polr`>, class<`formula`> | list<class<`formula`>>, double, character[], double, null, double, logical, double, ...> => (class<`aov`, `lm`> | class<`polr`>);
type `step.results` <list<list<double | character>>, class<`aov`, `lm`> | class<`polr`>, class<`aov`, `lm`> | class<`polr`>, logical> => (class<`aov`, `lm`> | class<`polr`>);
type `studres` <class<`aov`, `lm`>> => double[];
type `summary.negbin` <class<`glm`, `lm`, `negbin`>, null, logical, ...> => class<`summary.glm`, `summary.negbin`>;
type `TDh` <integer[], double, integer, double> => double;
type `test.values` <class<`matrix`>> => null;
type `theta.ml` <double[], double[], double, double[], double, double, logical> => double;
type `update.loglm` <class<`loglm`>, class<`formula`>, ...> => class<`loglm`>;
type `width.SJ` <double[], double, any, any, character[]> => double;
