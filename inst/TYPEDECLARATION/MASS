type `addterm` <class<`aov`, `lm`> | class<`glm`, `lm`> | class<`lme`> | class<`polr`>, ...> => class<`anova`, `data.frame`>;
type `addterm.default` <class<`lme`> | class<`polr`>, character[] | class<`formula`>, double, character[], double, logical, double, ...> => class<`anova`, `data.frame`>;
type `addterm.glm` <class<`glm`, `lm`>, character[] | class<`formula`>, double, character[], double, logical, double, ...> => class<`anova`, `data.frame`>;
type `addterm.lm` <class<`aov`, `lm`>, character[] | class<`aov`, `lm`>, double, character[], double, logical, ...> => class<`anova`, `data.frame`>;
type `anova.loglm` <class<`loglm`>, ..., character[]> => class<`anova.loglm`>;
type `anova.negbin` <class<`glm`, `lm`, `negbin`>, ..., character> => (class<`anova`, `data.frame`> | class<`Anova`, `data.frame`>);
type `anova.polr` <class<`polr`>, ..., character[]> => class<`Anova`, `data.frame`>;
type `area` <class<`function`>, double, double, ..., double, double, any, double> => double;
type `bandwidth.nrd` <double[]> => double;
type `bcv` <double[], double, double, double> => double;
type `biplot.bdr` <class<`matrix`>, class<`matrix`>, any, double[], null, null, null, null, ...> => null;
type `biplot.correspondence` <class<`correspondence`>, character[], ...> => null;
type `boxcox` <class<`formula`>, ...> => list<double[]>;
type `boxcox.default` <class<`lm`>, double[], logical, logical, double, expression, character, ...> => list<double[]>;
type `boxcox.formula` <class<`formula`>, double[], logical, any, any, any, character, ...> => list<double[]>;
type `confint.glm` <class<`glm`, `lm`>, any, double, logical, ...> => (class<`matrix`> | double[]);
type `confint.nls` <class<`nls`>, character, double, ...> => double[];
type `confint.profile.glm` <class<`profile`, `profile.glm`>, integer[], double, ...> => (class<`matrix`> | double[]);
type `confint.profile.nls` <class<`profile`, `profile.nls`>, character, double, ...> => double[];
type `confint.profile.polr` <class<`profile`, `profile.polr`>, integer[], double, ...> => class<`matrix`>;
type `contr.sdif` <double, logical, logical> => class<`matrix`>;
type `corresp` <class<`data.frame`> | class<`formula`>, ...> => class<`correspondence`>;
type `corresp.data.frame` <class<`data.frame`>, ...> => class<`correspondence`>;
type `corresp.formula` <class<`formula`>, class<`data.frame`>, ...> => class<`correspondence`>;
type `corresp.matrix` <class<`matrix`> | class<`table`>, double, ...> => class<`correspondence`>;
type `cov.rob` <class<`matrix`> | class<`data.frame`>, logical, double, character[], character, any> => list<double[] | class<`matrix`> | character>;
type `cov.trob` <class<`data.frame`>, double[], logical, logical, double, double, double> => list<class<`matrix`> | double[] | class<`call`>>;
type `denumerate` <class<`formula`> | class<`formula`, `terms`>> => (class<`formula`> | class<`formula`, `terms`>);
type `denumerate.formula` <class<`(`> | class<`call`> | class<`name`> | double | class<`formula`> | class<`formula`, `terms`>> => (class<`(`> | class<`call`> | class<`name`> | class<`formula`> | class<`formula`, `terms`>);
type `dose.p` <class<`glm`, `lm`>, double[], double[]> => class<`glm.dose`>;
type `dropterm` <class<`aov`, `lm`> | class<`glm`, `lm`> | class<`glm`, `lm`, `negbin`> | class<`gls`> | class<`lm`> | class<`lme`> | class<`polr`>, ...> => class<`anova`, `data.frame`>;
type `dropterm.default` <class<`glm`, `lm`, `negbin`> | class<`gls`> | class<`lme`> | class<`polr`>, character[], double, character[], double, logical, double, ...> => class<`anova`, `data.frame`>;
type `dropterm.glm` <class<`glm`, `lm`>, any, double, character[], double, logical, double, ...> => class<`anova`, `data.frame`>;
type `dropterm.lm` <class<`aov`, `lm`> | class<`lm`>, character[], double, character[], double, logical, ...> => class<`anova`, `data.frame`>;
type `dropterm.negbin` <class<`glm`, `lm`, `negbin`>, ...> => class<`anova`, `data.frame`>;
type `eqscplot` <class<`matrix`>, any, double, double, any, ...> => null;
type `extractAIC.polr` <class<`polr`>, any, double, ...> => double[];
type `fitdistr` <double[], character | class<`function`>, any, ...> => class<`fitdistr`>;
type `fractions` <class<`matrix`>, double, double, ...> => class<`fractions`, `matrix`>;
type `gamma.dispersion` <class<`glm`, `lm`>, ...> => double;
type `gamma.shape` <class<`glm`, `lm`>, ...> => class<`gamma.shape`>;
type `gamma.shape.glm` <class<`glm`, `lm`>, double, double, logical, ...> => class<`gamma.shape`>;
type `ginv` <class<`matrix`>, double> => class<`matrix`>;
type `glm.convert` <class<`glm`, `lm`, `negbin`>> => class<`glm`, `lm`>;
type `glmmPQL` <class<`formula`>, class<`formula`>, class<`function`>, class<`data.frame`>, any, any, any, double, logical, ...> => class<`glmmPQL`, `lme`>;
type `glm.nb` <any, any, any, any, any, null | double[], any, any, list<double>, character, logical, logical, logical, null, ..., any, any> => any;
type `huber` <double[], double, double> => list<double>;
type `hubers` <double[], double, any, any, any, double> => list<double>;
type `isoMDS` <class<`dist`>, class<`matrix`>, double, double, logical, double, double> => list<class<`matrix`> | double>;
type `kde2d` <double[], double[], any, double, double[]> => list<double[] | class<`matrix`>>;
type `lda` <any, ...> => class<`lda`>;
type `lda.default` <class<`matrix`>, class<`factor`>, double[], double, character[], logical, double, ...> => class<`lda`>;
type `lda.formula` <class<`formula`>, any, ..., any, any> => class<`lda`>;
type `lda.matrix` <class<`matrix`>, class<`factor`>, ..., any, any> => class<`lda`>;
type `lm.ridge` <any, any, any, any, double[], logical, logical, logical, null, ...> => class<`ridgelm`>;
type `lmwork` <class<`aov`, `lm`>> => list<double[]>;
type `logLik.glmmPQL` <class<`glmmPQL`, `lme`>, ...> => class<`logLik`>;
type `loglm` <any, class<`data.frame`> | class<`table`, `xtabs`>, any, any, ...> => class<`loglm`>;
type `loglm1` <any, class<`data.frame`> | class<`table`, `xtabs`>, ...> => class<`loglm`>;
type `loglm1.data.frame` <any, class<`data.frame`>, ...> => class<`loglm`>;
type `loglm1.default` <any, class<`array`> | class<`matrix`>, class<`array`> | double[], logical, logical, logical, double, double, logical, ...> => class<`loglm`>;
type `loglm1.xtabs` <any, class<`table`, `xtabs`>, ...> => class<`loglm`>;
type `logtrans` <class<`formula`>, ...> => list<double[]>;
type `logtrans.default` <class<`aov`, `lm`>, ..., double[], logical, logical, character, character> => list<double[]>;
type `logtrans.formula` <class<`formula`>, class<`data.frame`>, ...> => list<double[]>;
type `lqs` <class<`formula`> | class<`matrix`>, ...> => class<`lqs`>;
type `lqs.default` <class<`matrix`>, double[], logical, character[], any, list<null | character | logical | null | integer>, double, any, ...> => class<`lqs`>;
type `lqs.formula` <class<`formula`>, any, ..., character[], any, any, logical, logical, logical, null | list<character>> => class<`lqs`>;
type `mca` <class<`data.frame`>, double, logical> => class<`mca`>;
type `model.frame.polr` <class<`polr`>, ...> => class<`data.frame`>;
type `mvrnorm` <double, double[], class<`matrix`>, double, logical, logical> => class<`matrix`>;
type `negative.binomial` <double, any> => class<`family`>;
type `nobs.polr` <class<`polr`>, ...> => integer;
type `Ops.fractions` <class<`fractions`, `matrix`>, double> => class<`fractions`, `matrix`>;
type `pairs.profile` <class<`profile`, `profile.glm`> | class<`profile`, `profile.nls`> | class<`profile`, `profile.polr`>, integer[], ...> => double[];
type `parcoord` <class<`matrix`>, double[], double, logical, ...> => null;
type `plot.correspondence` <class<`correspondence`>, double, ...> => null;
type `plot.mca` <class<`mca`>, logical, any, double, ...> => class<`mca`>;
type `plot.profile` <class<`profile`, `profile.glm`> | class<`profile`, `profile.polr`>, ...> => null;
type `plot.ridgelm` <class<`ridgelm`>, ...> => null;
type `polr` <any, any, any, any, ..., any, any, null, logical, logical, character[]> => class<`polr`>;
type `polr.fit` <class<`matrix`>, class<`factor`, `ordered`> | integer[], integer[], double[], double[], character, ...> => list<double[] | list<double[] | null> | double[] | list<double[] | null | class<`matrix`>>>;
type `predict.glmmPQL` <class<`glmmPQL`, `lme`>, class<`data.frame`>, character, double, class<`function`>, ...> => double[];
type `predict.lda` <class<`lda`>, class<`data.frame`> | class<`matrix`>, double[], any, character[], ...> => list<class<`factor`> | class<`matrix`>>;
type `predict.lqs` <class<`lqs`>, any, any, ...> => double[];
type `predict.polr` <class<`polr`>, class<`data.frame`>, character, ...> => class<`matrix`>;
type `predict.qda` <class<`qda`>, class<`matrix`>, double[], character[], ...> => list<class<`factor`> | class<`matrix`>>;
type `profile.glm` <class<`glm`, `lm`>, integer[], double, double, double, logical, ...> => class<`profile`, `profile.glm`>;
type `profile.polr` <class<`polr`>, integer[], double, double, double, logical, ...> => class<`profile`, `profile.polr`>;
type `qda` <class<`matrix`>, ...> => class<`qda`>;
type `qda.default` <class<`matrix`>, class<`factor`>, double[], character[], logical, double, ...> => class<`qda`>;
type `qda.matrix` <class<`matrix`>, class<`factor`>, ..., any, any> => class<`qda`>;
type `.rat` <class<`matrix`>, double, double> => list<class<`matrix`>>;
type `rational` <class<`matrix`>, double, double, ...> => class<`matrix`>;
type `renumerate` <class<`formula`> | class<`formula`, `terms`> | null> => any;
type `renumerate.formula` <class<`call`> | class<`name`> | class<`formula`> | class<`formula`, `terms`>> => (class<`call`> | class<`name`> | class<`formula`> | class<`formula`, `terms`>);
type `rlm` <class<`formula`> | class<`matrix`>, ...> => class<`lm`, `rlm`>;
type `rlm.default` <class<`matrix`>, double[] | class<`matrix`>, any, ..., any, character | double[], any, any, double, character[], character[], double, double, character, null> => class<`lm`, `rlm`>;
type `rlm.formula` <class<`formula`>, any, any, ..., any, any, character[], character[], logical, logical, logical, null> => class<`lm`, `rlm`>;
type `rms.curv` <class<`nls`>> => class<`rms.curv`>;
type `rnegbin` <double[], double[], double> => integer[];
type `safe_pchisq` <double[], double[], ...> => double[];
type `safe_pf` <double[], double[], ...> => double[];
type `sammon` <class<`dist`>, class<`matrix`>, double, double, logical, double, double> => list<class<`matrix`> | double | class<`call`>>;
type `select` <class<`ridgelm`>> => null;
type `select.ridgelm` <class<`ridgelm`>> => null;
type `Shepard` <class<`dist`>, class<`matrix`>, double> => list<double[]>;
type `simulate.negbin` <class<`glm`, `lm`, `negbin`>, double, null, ...> => class<`data.frame`>;
type `stepAIC` <class<`aov`, `lm`> | class<`glm`, `lm`> | class<`glm`, `lm`, `negbin`> | class<`gls`> | class<`lm`> | class<`lme`> | class<`polr`>, any, double, character[], double, null, double, logical, double, ...> => (class<`aov`, `lm`> | class<`glm`, `lm`> | class<`glm`, `lm`, `negbin`> | class<`gls`> | class<`lm`> | class<`lme`> | class<`polr`>);
type `studres` <class<`aov`, `lm`>> => double[];
type `summary.negbin` <class<`glm`, `lm`, `negbin`>, double | null, logical, ...> => class<`summary.glm`, `summary.negbin`>;
type `summary.polr` <class<`polr`>, double, logical, ...> => class<`summary.polr`>;
type `summary.rlm` <class<`lm`, `rlm`>, character[], logical, ...> => class<`summary.rlm`>;
type `theta.md` <double[], double[], double, any, double, double> => double;
type `theta.ml` <double[], double[], double, any, double, double, logical> => double;
type `theta.mm` <double[], double[], double, any, double, double> => double;
type `ucv` <double[], double, double, double> => double;
type `update.loglm` <class<`loglm`>, class<`formula`>, ...> => class<`loglm`>;
type `vcov.fitdistr` <class<`fitdistr`>, ...> => class<`matrix`>;
type `vcov.polr` <class<`polr`>, ...> => class<`matrix`>;
type `width.SJ` <double[], double, any, any, character[]> => double;
