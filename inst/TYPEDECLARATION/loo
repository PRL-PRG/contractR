type `filter` <character[]> => logical[];
type `.fr` <double, double> => character;
type `.loo_i` <integer, any => any, null, struct<`y`:integer[], `K`:double[]>, ^double[], null, logical> => struct<`pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double, `n_eff`:double>, `psis_object`:null>;
type `.warn` <character, logical> => character;
type `$.loo` <struct<`estimates`:^double[], `pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>, `psis_object`:null, `elpd_loo`:double, `p_loo`:double, `looic`:double, `se_elpd_loo`:double, `se_p_loo`:double, `se_looic`:double>, character> => ^double[];
type `adjust_k_wip` <double, integer> => double;
type `autocovariance` <double[]> => double[];
type `called_from_loo` < > => logical;
type `colLogMeanExps` <^double[]> => double[];
type `dim.psis` <struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>> => integer[];
type `do_psis` <^double[], double[], double> => struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>;
type `do_psis_i` <double[], double> => struct<`log_weights`:double[], `pareto_k`:double>;
type `enough_tail_samples` <double, double> => logical;
type `fun` <symbol> => null;
type `FUN` <^double[] | character, double | any => any, null, struct<>, ^double[], null, logical> => struct<`pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double, `n_eff`:double>, `psis_object`:null> | double[] | struct<`log_weights`:double[], `pareto_k`:double>;
type `gpdfit` <double[], logical, double, logical> => struct<`k`:double, `sigma`:double>;
type `inrange` <double[], double[]> => logical[];
type `llarray_to_matrix` <double[]> => ^double[];
type `loo_i` <double, any => any, null, struct<`y`:integer[], `K`:double[]>, ^double[], null> => struct<`pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double, `n_eff`:double>, `psis_object`:null>;
type `loo.array` <double[], null, double[], logical, double> => struct<`estimates`:^double[], `pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>, `psis_object`:null, `elpd_loo`:double, `p_loo`:double, `looic`:double, `se_elpd_loo`:double, `se_p_loo`:double, `se_looic`:double>;
type `loo.function` <any => any, null, struct<`y`:integer[], `K`:double[]>, ^double[], null, logical, symbol> => struct<`estimates`:^double[], `pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>, `psis_object`:null, `elpd_loo`:double, `p_loo`:double, `looic`:double, `se_elpd_loo`:double, `se_p_loo`:double, `se_looic`:double>;
type `loo.matrix` <^double[], null, null | double[], logical, double> => struct<`estimates`:^double[], `pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>, `psis_object`:null, `elpd_loo`:double, `p_loo`:double, `looic`:double, `se_elpd_loo`:double, `se_p_loo`:double, `se_looic`:double>;
type `lx` <double[], double[]> => double[];
type `mcse_elpd` <^double[], double[], struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>, double> => double[];
type `n_pareto` <double[], integer> => double[];
type `plot.psis` <struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>, character[], null, logical, character> => null;
type `plot.psis_loo` <struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>, character[], null, symbol, character> => null;
type `pointwise_loo_calcs` <^double[], struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>> => ^double[];
type `psis_apply` <tuple<struct<`log_weights`:double[], `pareto_k`:double>> | list<struct<`log_weights`:double[], `pareto_k`:double>> | list<struct<`pareto_k`:double, `n_eff`:double>>, character, character[], double[]> => ^double[];
type `psis_loo_object` <^double[], struct<`pareto_k`:double[], `n_eff`:double[]>, integer[], null> => struct<`estimates`:^double[], `pointwise`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>, `psis_object`:null, `elpd_loo`:double, `p_loo`:double, `looic`:double, `se_elpd_loo`:double, `se_p_loo`:double, `se_looic`:double>;
type `psis_n_eff.matrix` <^double[], double[], null> => double[];
type `psis_smooth_tail` <double[], double> => struct<`tail`:double[], `k`:double>;
type `psis.array` <double[], null, double[], double> => struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>;
type `psis.matrix` <^double[], null, null | double[], double> => struct<`log_weights`:^double[], `diagnostics`:struct<`pareto_k`:double[], `n_eff`:double[]>>;
type `qgpd` <double[], double, double> => double[];
type `relative_eff.matrix` <^double[], integer[], null, double> => double[];
type `throw_pareto_warnings` <double[], double, double> => null;
type `throw_pwaic_warnings` <double[], double> => null;
type `throw_tail_length_warnings` <double[]> => double[];
type `validate_ll` <^double[]> => ^double[];
type `waic_object` <^double[], integer[]> => struct<`estimates`:^double[], `pointwise`:^double[], `elpd_waic`:double, `p_waic`:double, `waic`:double, `se_elpd_waic`:double, `se_p_waic`:double, `se_waic`:double>;
type `waic.array` <double[], null> => struct<`estimates`:^double[], `pointwise`:^double[], `elpd_waic`:double, `p_waic`:double, `waic`:double, `se_elpd_waic`:double, `se_p_waic`:double, `se_waic`:double>;
