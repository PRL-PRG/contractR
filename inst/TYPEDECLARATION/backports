type `bp_...elt` <double> => character;
type `bp_...length` < > => integer;
type `bp_.valid_factor` <integer[]> => logical;
type `bp_anyNA` <character[], logical> => logical;
type `bp_capture.output` <language, null, logical, character, logical> => character;
type `bp_dir.exists` <character> => logical;
type `bp_endsWith` <character[], character> => logical[];
type `bp_file.info` <character, logical> => struct<`size`:double, `isdir`:logical, `mode`:integer, `mtime`:double, `ctime`:double, `atime`:double>;
type `bp_file.mode` <character> => double;
type `bp_file.size` <character> => double;
type `bp_get0` <character, environment, character, logical, null | double> => null | double;
type `bp_hasName` <struct<`a`:double, `b`:double>, character[]> => logical[];
type `bp_isFALSE` <struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]> | logical> => logical;
type `bp_isTRUE` <struct<`Sepal.Length`:double[], `Sepal.Width`:double[], `Petal.Length`:double[], `Petal.Width`:double[], `Species`:integer[]> | logical> => logical;
type `bp_lengths` <tuple<integer[], double>, logical> => integer[];
type `bp_startsWith` <character[], character> => logical[];
type `bp_strrep` <character, double> => character;
type `bp_trimws` <character[], character[]> => character[];
type `bp_URLencode` <character, logical, logical> => character;
type `bp_warningCondition` <character, null, null, null> => struct<`message`:character, `call`:null>;
type `evalVis` <language> => struct<`value`:null, `visible`:logical>;
type `filter` <character[]> => logical[];
type `FUN` <integer | character> => character;
type `isTRUE` <logical> => logical;
type `mysub` <character, character[]> => character[];
type `::` <character | symbol, null | character[], logical> => logical;
type `get_backports` <tuple<integer[]>> => character[];
type `hasName` <struct<`job.id`:integer[]> | tuple<> | struct<`foo`:character> | struct<`measure.memory`:logical> | struct<`memory`:double, `walltime`:double>, character> => logical;
type `errorCondition` <character, character, character, null> => struct<`message`:character, `call`:null, `packages`:character>;
