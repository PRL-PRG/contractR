type `.depd` <double[], double, double, double, logical> => double[];
type `.devd` <double[], double, double, double, logical> => double[];
type `.gevFit` <double | character, character, logical, null, null, ???> => ^double[];
type `.gevmleFit` <double[], null, ???> => struct<`n`:integer, `data`:double[], `par.ests`:double[], `par.ses`:double[], `varcov`:^double[], `converged`:integer, `nllh.final`:double>;
type `.gevpwmFit` <double[], null, ???> => struct<`n`:integer, `data`:double[], `par.ests`:double[], `par.ses`:^logical[], `varcov`:^logical[], `converged`:null, `nllh.final`:null, `call`:language, `selected`:character>;
type `.gpdmleFit` <double[], double, character, ???> => struct<`par.ests`:double[], `par.ses`:double[], `fit`:struct<`par`:double[], `value`:double, `counts`:^integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `varcov`:^double[]>;
type `.gpdpwmFit` <double[], double> => struct<`par.ests`:double[], `par.ses`:double[], `fit`:null, `varcov`:null>;
type `.pepd` <double[], double, double, double, logical> => double[];
type `.pevd` <double[], double, double, double, logical> => double[];
type `.qepd` <double[], double, double, double, logical> => double[];
type `.qevd` <double[], double, double, double, logical> => double[];
type `.repd` <double, double, double, double> => double[];
type `.revd` <double, double, double, double> => double[];
type `blockMaxima` <^double[], character | double, logical> => ^double[];
type `deCluster` <^double[], double, logical> => ^double[];
type `dgev` <double[], double, double, double, logical> => double[];
type `dgpd` <double[], double, double, double, logical> => double[];
type `exindexesPlot` <^double[], double, double[], logical, logical, ???> => struct<`quantiles`:double[], `thresholds`:double[], `theta1`:double[], `theta2`:double[], `theta3`:double[]>;
type `exindexPlot` <^double[], character, double, null, logical, character, logical, ???> => struct<`N`:double[], `K`:double[], `un`:double[], `theta2`:double[], `theta`:double[]>;
type `f` <double, double, double, double> => double;
type `filter` <character[]> => logical[];
type `findThreshold` <^double[], double[], logical> => double[];
type `fn` <double[], double[], double, double, double> => double;
type `fun` <symbol, symbol> => null;
type `FUN` <logical, ???> => ? struct<`x`:double[], `y`:double[]>;
type `gevFit` <double, character, null, null, ???> => ^double[];
type `gevMoments` <double, double, double> => struct<`param`:double[], `mean`:double, `var`:double>;
type `gevSim` <struct<`xi`:double, `mu`:double, `beta`:double>, double, null> => ^double[];
type `gfunc` <double, double> => double;
type `gpdFit` <double, character[], character[], null, null, ???> => ^double[];
type `gpdSim` <struct<`xi`:double, `mu`:double, `beta`:double>, double, null> => ^double[];
type `gumbelSim` <struct<`xi`:double, `mu`:double, `beta`:double>, double, null> => ^double[];
type `myrank` <double[], logical> => integer[];
type `parloglik` <double, double[], double, double, double> => double;
type `pgev` <double[], double, double, double, logical> => double[];
type `pgpd` <double[], double, double, double, logical> => double[];
type `plot.fGEVFIT` <???> => character;
type `plot.fGPDFIT` <???> => character;
type `pointProcess` <^double[], double, logical> => ^double[];
type `qgev` <double[], double, double, double, logical> => double[];
type `qgpd` <double[], double, double, double, logical> => double[];
type `rgev` <double, double, double, double> => double[];
type `rgpd` <double, double, double, double> => double[];
type `summary.fGEVFIT` <character, ???> => logical;
type `summary.fGPDFIT` <character, ???> => logical;
type `tailPlot` <double, double, double, double, logical, logical, ???> => struct<`var`:double[], `sfall`:double[]>;
type `tailRisk` <double[], ???> => struct<`Prob`:double[], `VaR`:double[], `ES`:double[]>;
