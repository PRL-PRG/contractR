type `-.tensor` <complex[] | ^double[], complex[] | ^double[]> => complex[] | ^double[];
type `[.tensor` <^complex[], double[] | ???, logical> => complex[];
type `[[.tensor` <complex[] | ^double[], language | double | integer[] | character[], logical> => ? complex[] | ^double[];
type `[[<-.tensor` <double[], character[], integer[] | double> => double[];
type `*.tensor` <^complex[], ^double[]> => ^complex[];
type `/.tensor` <complex[] | ^double[], ^double[]> => complex[] | ^double[];
type `%e%.tensor` <complex[], complex[] | ^double[]> => ^complex[];
type `%r%.tensor` <integer[], integer[]> => ^double[];
type `^.tensor` <^double[], double | character[]> => ^double[];
type `+.tensor` <^double[], ^double[]> => ^double[];
type `|.tensor` <double[], character[]> => double[];
type `$.tensor` <^integer[], character> => ^integer[];
type `add.tensor` <complex[] | ^double[], complex[] | ^double[], character, null> => complex[] | ^double[];
type `as.contravariate.character` <character[], ???> => character[];
type `as.covariate.character` <character[], ???> => character[];
type `as.tensor.default` <complex[] | ^double[], ???, null> => complex[] | ^double[];
type `as.tensor.tensor` <^complex[], ???> => ^complex[];
type `bind.tensor` <complex[] | ^integer[], double | character, complex[] | ^integer[], double> => complex[] | ^integer[];
type `contraname` <character[]> => character[] | logical[];
type `delta.tensor` <double[], character, null, null> => ^double[];
type `diag.tensor` <^double[], character, null, ? character> => double[];
type `diagmul.tensor` <^complex[], character[] | double, ^double[], character[] | double, ? character> => ^complex[];
type `dim<-.tensor` <^complex[], double[]> => ^complex[];
type `dimnames.tensor` <^complex[]> => struct<`:!1`:null> | struct<`^i`:null, `^j`:null> | struct<`^U`:null, `V`:null, `Q`:null> | struct<`<<<`:null> | struct<`a'`:character[], `b'`:character[]> | struct<`a'`:character[], `b'`:null> | struct<`a'`:null> | struct<`a*`:character[], `b*`:character[]> | struct<`a*`:null, `b*`:character[]> | struct<`a`:character[]> | struct<`A`:character[], `B`:character[]> | struct<`a`:null> | struct<`A`:null, `B`:character[]> | struct<`A1`:null, `Q`:null, `B`:character[]> | struct<`A1`:null, `Q`:null, `B`:null> | struct<`aa`:character[], `bb`:null> | struct<`aa`:null, `bb`:null> | struct<`b`:character[]> | struct<`b`:null> | struct<`B`:null, `C`:null> | struct<`c`:null> | struct<`d`:null> | struct<`e`:null> | struct<`gamma`:null, `C`:null> | struct<`i'`:null, `j'`:null, `s'`:null> | struct<`i`:null> | struct<`I`:null> | struct<`I1`:null> | struct<`j`:null> | struct<`K`:null> | struct<`l`:null, `k`:null> | struct<`lambda`:null, `lambda'`:null> | struct<`M`:null, `L`:null, `W`:null> | struct<`M`:null, `V`:null, `W`:null> | struct<`NA`:null, `B`:null> | struct<`opnormdim`:null> | struct<`s`:null> | struct<`U'`:null, `:!1`:character[]> | struct<`U'`:null, `U`:character[]> | struct<`U'`:null, `Uk`:character[]> | struct<`U'`:null, `V'`:null, `W'`:null> | struct<`U'`:null, `V`:null, `W`:null> | struct<`U`:character[], `V`:character[], `W`:character[]> | struct<`U`:null> | struct<`Uk`:character[], `Vk`:character[], `Wk`:character[]> | struct<`Uk`:null> | struct<`V`:null, `q`:null, `W`:null> | struct<`V`:null, `W`:null, `V'`:null, `W'`:null> | struct<`x`:null, `y`:null, `z`:null, `V`:character[], `W`:character[]>;
type `dimnames<-.tensor` <^complex[], ? struct<`U'`:null, `:!1`:character[]> | struct<`U'`:null, `Uk`:character[]> | tuple<character[], character[]> | struct<``:null> | struct<`M`:null, `L`:null, `W`:null> | struct<`M`:null, `V`:null, `W`:null> | struct<`U'`:null, `V'`:null, `W'`:null> | struct<`U'`:null, `V`:null, `W`:null> | struct<`b`:null> | struct<`K`:null, `V`:null, `W`:null> | struct<`U*`:null, `V*`:null, `W*`:null> | struct<`U*`:null, `V`:null, `W`:null> | struct<`U`:null, `q`:null, `W`:null> | struct<`U`:null, `V*`:null, `W*`:null> | struct<`V`:null, `q`:null, `W`:null> | list<character[]> | struct<`j`:null, `^j`:null> | struct<`lambda`:null, `a'`:null> | struct<``:character[], ``:character[]> | struct<`^i`:null, `^j`:null> | struct<`lambda`:null, `lambda'`:null> | struct<`:!1`:null> | struct<`a*`:character[], `b*`:character[], `a'`:character[], `b'`:null> | struct<`a*`:null, `b*`:character[], `<<<`:null> | struct<`a`:null> | struct<`Aa`:character[], `Bb`:character[], `aa`:character[], `bb`:null> | struct<`Aa`:null, `Bb`:null, `aa`:null, `bb`:null> | struct<`i'`:null, `j'`:null, `s'`:null> | struct<`lambda'`:null, `a'`:character[], `b'`:character[]> | struct<`s`:null> | struct<`A`:character[], `a'`:character[], `b'`:null> | struct<`c`:null> | struct<`e`:null> | struct<`Uk`:character[], `Vk`:character[], `Wk`:character[]> | struct<`a'`:character[], `b'`:null, `lambda`:null> | struct<`a'`:null, `b'`:null, `<<<`:null> | struct<`i`:null> | struct<`opnormdim`:null> | struct<`a`:character[]> | struct<`b`:character[]> | struct<`h`:null, `j`:null> | struct<`l`:null, `k`:null> | struct<`l`:null, `j`:null> | struct<`A`:character[], `B`:character[]> | struct<`A`:null, `B`:character[]> | struct<`NA`:null, `B`:null> | struct<`gamma`:null, `C`:null> | struct<`B`:null, `C`:null> | struct<`V`:character[], `W`:character[]> | struct<`A1`:null, `Q`:null, `B`:character[]> | struct<`A1`:null, `Q`:null, `B`:null> | struct<`a'`:null, `b'`:null, `c'`:null> | struct<`^U`:null, `V`:null, `Q`:null> | struct<`U`:null, `^V`:null, `W`:null> | struct<`U`:null, `VV`:null, `WW`:null>> => ^complex[];
type `drag.tensor` <^double[], ^double[], character[]> => ^double[];
type `einstein.tensor` <complex[] | ^double[], ? character, ? character> => ^complex[];
type `filter` <character[]> => logical[];
type `ftable.tensor` <^complex[], ??? | double> => ^complex[];
type `FUN` <character[] | double[] | struct<`d`:double[], `u`:^double[], `v`:^double[]>, ???> => struct<`d`:double[], `u`:^double[], `v`:^double[]> | ^complex[] | character[];
type `gsi.debug` <character> => list<integer[] | character[]> | list<character | integer[]> | tuple<character, integer[], character, double> | tuple<character, integer[], character, character[]>;
type `gsi.debugn` <character> => null;
type `gsi.debugr` <? ^complex[]> => ? ^complex[];
type `gsi.fullreorder` <integer[], ? double[], ? double[]> => double[];
type `gsi.invperm` <double> => double[];
type `gsi.matrify` <^double[], double[]> => ^double[];
type `gsi.namedlist` <character, null> => struct<`c`:null> | struct<`d`:null> | struct<`i`:null> | struct<`I`:null> | struct<`K`:null> | struct<`Q`:null> | struct<`u`:null>;
type `gsi.namednumber` <? character, double> => double;
type `gsi.rest` <integer[], double[]> => double[];
type `gsi.stdnames` <double, character, ? character[]> => character[];
type `gsi.vonbis` <double, double> => ? integer;
type `gsi.weightedndx` <integer[], double[]> => double[];
type `gsi.weights` <integer[]> => double[];
type `gsi.without` <integer[] | struct<`:!1`:null> | struct<`a`:character[]> | struct<`a`:null> | struct<`b`:null> | struct<`c`:null> | struct<`i`:null> | struct<`s`:null> | struct<`U`:null, `V`:null, `W`:null> | struct<`lambda'`:null, `a'`:character[], `b'`:character[]> | struct<`a'`:character[], `b'`:null> | struct<`lambda`:null, `a'`:null> | struct<`a'`:null, `b'`:null> | struct<`a*`:null, `b*`:character[], `<<<`:null> | struct<`A`:null, `B`:null, `C`:null> | struct<`Aa`:character[], `Bb`:character[], `aa`:character[], `bb`:null> | struct<`Aa`:null, `Bb`:null, `aa`:null, `bb`:null> | struct<`c`:character[], `b`:character[]> | struct<`d`:null, `e`:null, `f`:null> | struct<`i'`:null, `j'`:null, `s'`:null> | struct<`j`:null> | struct<`l`:null, `k`:null> | struct<`K`:null, `V`:null, `W`:null> | struct<`lambda`:null, `lambda'`:null> | struct<`M`:null, `V`:null, `W`:null> | struct<`M`:null, `L`:null, `W`:null> | struct<`^U`:null, `V`:null, `Q`:null> | struct<`U'`:null, `:!1`:character[]> | struct<`U'`:null, `V`:null, `W`:null> | struct<`U`:character[], `V`:character[], `W`:character[]> | struct<`U'`:null, `V'`:null, `W'`:null> | struct<`U`:null, `VV`:null, `WW`:null> | struct<`U`:null, `^V`:null, `W`:null> | struct<`b`:character[], `z`:character[]>, double[]> => integer[] | tuple<> | struct<`^a`:null> | struct<`^b`:null> | struct<`^c`:null> | struct<`^i`:null> | struct<`^j`:null> | struct<`a'`:character[], `b'`:character[]> | struct<`a'`:character[], `b'`:null> | struct<`a'`:null> | struct<`a*`:character[], `b*`:character[]> | struct<`a*`:null, `b*`:character[]> | struct<`a`:character[]> | struct<`a`:null> | struct<`A`:null, `C`:null> | struct<`a1`:null, `b1`:null, `I`:null> | struct<`aa`:character[], `bb`:null> | struct<`aa`:null, `bb`:null> | struct<`am`:null, `bm`:null> | struct<`b`:character[]> | struct<`b`:null> | struct<`B`:null, `C`:null> | struct<`c`:character[]> | struct<`c`:null> | struct<`d`:null> | struct<`i'`:null, `j'`:null> | struct<`i`:null> | struct<`I1`:null> | struct<`I2`:null> | struct<`j`:null> | struct<`k`:null> | struct<`K`:null> | struct<`lambda'`:null> | struct<`lambda`:null> | struct<`M`:null> | struct<`Q`:null> | struct<`s`:null> | struct<`U'`:null> | struct<`U`:character[]> | struct<`U`:null> | struct<`V'`:null, `W'`:null> | struct<`VV`:null, `WW`:null> | struct<`W`:null> | struct<`z`:character[]> | struct<`z`:null>;
type `inv.tensor` <^complex[], double | character[], character | ???, logical, double, ? character> => ^complex[];
type `is.contravariate.character` <character[], ???> => logical[];
type `is.contravariate.tensor` <double[], ???> => logical[];
type `is.covariate.character` <character[], ???> => logical[];
type `is.covariate.tensor` <^double[], ???> => logical[];
type `margin.tensor` <^double[], ? character[] | double[], ? character[]> => ^double[];
type `mark.character` <character[], character, character | integer[], ???, null> => character[];
type `mark.numeric` <double[], character, integer[] | character, ???, null> => double[];
type `mark.tensor` <complex[] | ^double[], character[], integer[] | character[], ???, ? double | integer[]> => complex[] | ^double[];
type `mean.tensor` <double[], character, ???, logical> => ^double[];
type `names<-.tensor` <^complex[], character[]> => ^complex[];
type `norm.tensor` <^double[], ? double[] | character[], ???, ? character> => double[];
type `one.tensor` <double[], ? struct<`a'`:character[], `b'`:character[]> | struct<`a'`:character[], `b'`:null> | struct<`a'`:null, `b'`:null> | struct<`a*`:character[], `b*`:character[]> | struct<`a*`:null, `b*`:character[]> | struct<`a`:null, `b`:null> | struct<`aa`:character[], `bb`:null> | struct<`aa`:null, `bb`:null> | struct<`c`:null> | struct<`d`:null> | struct<`i`:null> | struct<`j`:null> | struct<`K`:null> | struct<`s`:null> | struct<`U`:null>> => ^double[];
type `opnorm.tensor` <double[] | ^integer[], character, ???, ? character> => ? double[];
type `pos.tensor` <integer[]> => ^integer[];
type `power.tensor` <double[], character[] | double[], character[] | double[], double, ? character> => double[];
type `reorder.tensor` <^complex[], double[] | character[], ???, null> => ^complex[];
type `reorder.tidx` <integer[], double[], ???> => double[];
type `rep.tensor` <^complex[], double[], double | character, ? character, ???> => ^complex[];
type `riemann.tensor` <^double[], null, null> => ^double[];
type `slice.tensor` <^double[], character, double | integer[] | character[], logical> => ? ^double[];
type `solve.tensor` <^complex[], ^double[], character[], character[], ???, logical, double, ? character> => ^complex[];
type `svd.tensor` <^integer[] | double[], character[] | double[], ? character[] | double[], ???, character, ? character> => struct<`u`:^double[], `d`:double[], `v`:^double[]> | struct<`u`:double[], `d`:^double[], `v`:double[]>;
type `to.matrix.tensor` <double[], character[] | ???, ??? | character[], ? character> => ^double[];
type `to.tensor.default` <^complex[], double[] | struct<`U`:character[], `V`:character[], `W`:integer[]>, ? struct<`M`:null, `U`:character[]> | struct<`U'`:null, `:!1`:character[]> | struct<`U'`:null, `U`:character[]> | struct<`U'`:null, `Uk`:character[]> | struct<`b`:null> | struct<`V`:null, `W`:null, `V'`:null, `W'`:null> | tuple<character[], character[]> | struct<`^i`:null, `^j`:null> | struct<`I1`:null, `I2`:null> | struct<`lambda`:null, `lambda`:null> | struct<`:!1`:null, `:!2`:null> | struct<`a'`:character[], `b'`:character[]> | struct<`a'`:character[], `b'`:null> | struct<`a*`:character[], `b*`:character[]> | struct<`a*`:null, `b*`:character[]> | struct<`A2`:null, `A3`:character[]> | struct<`A2`:null, `A3`:null> | struct<`aa`:character[], `bb`:null> | struct<`aa`:null, `bb`:null> | struct<`I1`:null, `:!1`:null> | struct<`I2`:null, `:!1`:null> | struct<`W`:null, `Q`:null> | struct<`a`:null> | struct<`c`:null> | struct<`e`:null> | struct<`s`:null> | tuple<character[], null, character[], character[]> | struct<``:null> | struct<`V`:null, `W`:null, `VV`:null, `WW`:null> | struct<`a'`:null> | struct<`A`:null> | struct<`B`:null> | struct<`d`:null> | struct<`i`:null> | struct<`j`:null> | struct<`k`:null> | struct<`K`:null> | struct<`U`:null> | struct<`B`:character[]> | struct<`a`:character[]> | struct<`b`:character[]> | struct<`u`:null, `v`:null> | struct<`U`:character[], `V`:character[], `W`:character[]>, integer[] | double | character[], logical | character, ???> => ^complex[];
type `trace.tensor` <complex[] | ^double[], character[], character[]> => ^complex[];
type `tripledelta.tensor` <double[], character, character, null> => double[];
type `undrop.tensor` <complex[] | ^integer[], character, double> => complex[];
type `untensor` <^complex[], ? double[] | character[], ? character, double, ? character[]> => ^complex[];
type `var.tensor` <^double[], ? ^double[], ???, character, ? character, logical, character> => ^double[];
