type `bindev` <double, double, double, double, double, double, ...> => double;
type `binom.bayes` <double[], double[], double, character[], double, double, double, double, ...> => class<`data.frame`>;
type `binom.bayes.densityplot` <class<`data.frame`>, double, character, character, character, double, ...> => class<`gg`, `ggplot`>;
type `binom.cloglog` <integer[], double, double, ...> => class<`data.frame`>;
type `binom.confint` <double[], double[], double[], character, ...> => class<`data.frame`>;
type `binom.coverage` <double, double, double, character, ...> => class<`data.frame`>;
type `binom.lchoose` <double, double> => double;
type `binom.length` <double, double, double, character, ...> => class<`data.frame`>;
type `binom.logit` <integer[], double, double, ...> => class<`data.frame`>;
type `binom.lrt` <double[], double[], double[], logical, logical, logical, ...> => class<`data.frame`>;
type `binom.optim` <double, double, class<`function`>, double, double, logical, logical, double, null, ...> => list<any>;
type `binom.plot` <double[], class<`function`>, double, double, any, character, double, ...> => class<`trellis`>;
type `binom.power` <double, double, double, double, double, character, character[]> => double;
type `binom.probit` <integer[], double, double, ...> => class<`data.frame`>;
type `binom.profile` <double[], double[], double, double, double, logical, logical, ...> => class<`data.frame`>;
type `binom.sim` <double, double, double, double, character, ...> => class<`data.frame`>;
type `ci.method` <double[], double[], double[], logical, logical, logical, ...> => class<`data.frame`> | <integer[], double, double[], ...> => class<`data.frame`>;
type `cloglog.sample.size` <any, null | double, double, double, double, character[], logical, logical, double> => class<`data.frame`>;
type `compute.delta` <double, double, double, double, character, double, ...> => double;
type `compute.power` <double, double, double, double, double, character, double, ...> => double;
type `compute.sample.size` <double, double, double, double, double, logical, double, ...> => double;
type `E.pn` <double[], double[], double[], double[], double[]> => double[];
type `f` <double, double, double, double, double, double, ...> => double | <double, double, double, double, double, character, double> => double;
type `filter` <character[]> => logical[];
type `fn` <double[], double, double, double, class<`function`>, double, class<`function`>, logical, ...> => double;
type `fun` <character, character> => class<`DLLInfo`>;
type `FUN` <integer> => double[] | <integer, double[], class<`data.frame`>> => list<class<`data.frame`>> | <integer> => double[] | <class<`data.frame`>, integer[], double, double> => double | <class<`data.frame`>, double> => double[];
type `integrate.poly` <double[], double, double, double, double, character> => double;
type `ldbinom` <double, double, double, logical> => double;
type `method` <double[], double[], double[], logical, logical, logical, ...> => class<`data.frame`> | <integer[], double, double[], ...> => class<`data.frame`>;
type `pbeta2` <double[], double[], double[], double[]> => double[];
type `rbind.zero` <class<`data.frame`>, character, logical> => class<`data.frame`>;
type `var.cloglog` <double[], double[]> => double[];
type `varfun` <double[], double[]> => double[];
type `var.logit` <double[], double[]> => double[];
type `var.probit` <double[], double[]> => double[];
