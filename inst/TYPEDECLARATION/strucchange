type `AIC.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, null, ..., double> => double[];
type `boundary` <class<`efp`> | class<`Fstats`> | class<`mefp`>, ...> => class<`ts`> | <double[]> => double[];
type `boundary.efp` <class<`efp`>, double, logical, character, ...> => class<`ts`>;
type `boundary.Fstats` <class<`Fstats`>, double, logical, logical, any, ...> => class<`ts`>;
type `boundary.mefp` <class<`mefp`>, ...> => class<`ts`>;
type `breakdates` <class<`breakpoints`> | class<`confint.breakpoints`> | class<`breakpoints`, `breakpointsfull`>, logical | null, ...> => (character[] | class<`matrix`> | double[]);
type `breakdates.breakpoints` <class<`breakpoints`> | class<`breakpoints`, `breakpointsfull`>, logical | null, null, ...> => (character[] | double[]);
type `breakdates.confint.breakpoints` <class<`confint.breakpoints`>, logical, ...> => class<`matrix`>;
type `breakfactor` <class<`breakpoints`> | class<`breakpoints`, `breakpointsfull`>, null | double, null | character, ...> => class<`factor`>;
type `breakpoints` <class<`breakpoints`, `breakpointsfull`> | class<`Fstats`> | class<`formula`>, ...> => (class<`breakpoints`> | class<`breakpoints`, `breakpointsfull`>);
type `breakpoints.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, double | null, ...> => class<`breakpoints`>;
type `breakpoints.formula` <class<`formula`>, double, double | null, class<`matrix`, `mts`, `ts`> | class<`data.frame`> | list<any>, character[], ...> => class<`breakpoints`, `breakpointsfull`>;
type `breakpoints.Fstats` <class<`Fstats`>, ...> => class<`breakpoints`>;
type `catL2BB` <class<`gefp`>> => class<`efpFunctional`>;
type `coef.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, double, null, ...> => class<`matrix`>;
type `confint.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, null, double, double | null, logical, logical, class<`function`> | null, logical> => class<`confint.breakpoints`>;
type `efp` <class<`formula`>, class<`data.frame`> | class<`matrix`, `mts`, `ts`> | list<any>, character[], any, logical, logical, logical, null> => class<`efp`>;
type `efpFunctional` <list<class<`function`>>, class<`function`>, class<`function`>, class<`function`>, class<`function`> | null, character, double, double> => class<`efpFunctional`>;
type `fitted.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, double, ...> => class<`ts`>;
type `Fstats` <class<`formula`>, double[], double[] | null, class<`matrix`, `mts`, `ts`> | list<any> | class<`data.frame`>, null> => class<`Fstats`>;
type `gefp` <..., class<`function`> | null, class<`function`>, class<`function`> | null, logical, any, null | class<`formula`> | integer[], null> => class<`gefp`>;
type `lines.breakpoints` <class<`breakpoints`> | class<`breakpoints`, `breakpointsfull`>, null | double, double, ...> => null;
type `lines.confint.breakpoints` <class<`confint.breakpoints`>, double, double, double, double, null, logical, ...> => null;
type `lines.efp` <class<`efp`>, character, ...> => null;
type `logLik.breakpoints` <class<`breakpoints`>, ...> => class<`logLik`>;
type `maxMOSUM` <double> => class<`efpFunctional`>;
type `mefp` <class<`efp`> | class<`formula`>, ...> => class<`mefp`>;
type `mefp.efp` <class<`efp`>, double, character[], any, any, any, null | logical, null | class<`function`>> => class<`mefp`>;
type `mefp.formula` <class<`formula`>, character, class<`data.frame`> | class<`matrix`, `mts`, `ts`> | list<any>, double, double, character[], double, any> => class<`mefp`>;
type `monitor` <class<`mefp`>, class<`data.frame`> | null, logical> => class<`mefp`>;
type `ordL2BB` <class<`gefp`>, null, double, double[], ...> => class<`efpFunctional`>;
type `ordwmax` <class<`gefp`>, any, ...> => class<`efpFunctional`>;
type `pargmaxV` <double, double, double, double> => double;
type `plot.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, null, ...> => class<`summary.breakpointsfull`>;
type `plot.efp` <class<`efp`>, double, logical, logical, character | null, null, null, character> => null;
type `plot.Fstats` <class<`Fstats`>, logical, logical, double, logical, logical, character, null> => null;
type `plot.gefp` <class<`gefp`>, double, class<`efpFunctional`>, ...> => (class<`zoo`> | null);
type `plot.mefp` <class<`mefp`>, logical, character | null, null, character, null, ...> => null;
type `plot.summary.breakpointsfull` <class<`summary.breakpointsfull`>, character, double[], logical, character, character, character, ...> => class<`summary.breakpointsfull`>;
type `pvalue.efp` <double, character, any, character, any, any> => double;
type `pvalue.Fstats` <double, character, integer, double> => double;
type `recresid` <class<`formula`> | class<`matrix`>, ...> => double[];
type `recresid.default` <class<`matrix`>, double[], double, integer, any, double, character[], ...> => double[];
type `recresid.formula` <class<`formula`>, list<any>, ...> => double[];
type `residuals.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, double | null, ...> => class<`ts`>;
type `root.matrix` <class<`matrix`>> => class<`matrix`>;
type `sctest` <class<`efp`> | class<`formula`> | class<`Fstats`> | class<`gefp`> | class<`glm`, `lm`>, ...> => class<`htest`>;
type `sctest.default` <class<`glm`, `lm`>, integer[], character, null, class<`function`>, logical, logical, null> => class<`htest`>;
type `sctest.efp` <class<`efp`>, logical, character[], ...> => class<`htest`>;
type `sctest.formula` <class<`formula`>, character, double, logical, character[], double, double | null, double> => class<`htest`>;
type `sctest.Fstats` <class<`Fstats`>, character[], logical, ...> => class<`htest`>;
type `sctest.gefp` <class<`gefp`>, class<`efpFunctional`>, ...> => class<`htest`>;
type `solveCrossprod` <class<`matrix`>, character[]> => class<`matrix`>;
type `summary.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, null, logical, null, ...> => class<`summary.breakpointsfull`>;
type `supLM` <double, null> => class<`efpFunctional`>;
type `time.gefp` <class<`gefp`>, ...> => (class<`Date`> | double[]);
type `vcov.breakpointsfull` <class<`breakpoints`, `breakpointsfull`>, double, null, logical, logical, null | class<`function`>, logical, ...> => list<class<`matrix`>>;
