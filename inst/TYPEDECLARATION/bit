type `bit_init` < > => null;
type `clone.default` <double[], null> => double[];
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null;
type `setattr` <null | ^double[] | environment, character, null | environment | ^character[]> => null;
type `xor.default` <^integer[], ^integer[]> => ^logical[];
type `!.bit` <integer[]> => integer[];
type `!.bitwhich` <integer[]> => integer[];
type `!=.bit` <integer[], integer[] | ^logical[]> => integer[];
type `!=.bitwhich` <integer[], integer[] | ^logical[]> => integer[];
type `[.bit` <^integer[], ^double[] | null> => ^logical[];
type `[[.bit` <integer, double> => logical;
type `[[<-.bit` <integer, double, logical> => integer;
type `[<-.bit` <null | integer[], double | integer[] | null, null | ^logical[]> => null | ^integer[];
type `&.bit` <integer[], integer[] | ^logical[]> => integer[];
type `==.bit` <integer[], integer[] | ^logical[]> => integer[];
type `==.bitwhich` <integer[], integer[] | ^logical[]> => integer[];
type `|.bit` <integer[], integer[] | ^logical[]> => integer[];
type `all.bit` <integer[], null, logical> => logical;
type `all.bitwhich` <logical, logical> => logical;
type `any.bit` <integer[], null, logical> => logical;
type `any.bitwhich` <logical, logical> => logical;
type `anyDuplicated.rlepack` <struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>, logical, null> => integer;
type `as.bit.bit` <integer[], null> => integer[];
type `as.bit.logical` <^logical[], null> => integer[];
type `as.bit.ri` <integer[], null> => null | integer[];
type `as.bit.which` <double[], double, null> => integer[];
type `as.bitwhich.bit` <integer[], null, null> => integer[];
type `as.bitwhich.bitwhich` <integer[], null> => integer[];
type `as.bitwhich.logical` <^logical[], null> => integer[];
type `as.bitwhich.ri` <integer[], null> => integer[];
type `as.double.bit` <integer, null> => double[];
type `as.double.bitwhich` <integer[], null> => double[];
type `as.double.ri` <integer[], null> => double[];
type `as.integer.bit` <integer, null> => integer[];
type `as.integer.bitwhich` <integer[], null> => integer[];
type `as.integer.ri` <integer[], null> => integer[];
type `as.logical.bit` <integer[], null> => logical[];
type `as.logical.bitwhich` <integer[], null> => logical[];
type `as.logical.ri` <integer[], null> => logical[];
type `as.which.bit` <integer[], null, null> => integer[];
type `as.which.bitwhich` <integer[], null> => integer[];
type `as.which.default` <logical[], null> => integer[];
type `as.which.ri` <integer[], null> => integer[];
type `bit` <double> => integer[];
type `bit_done` < > => null;
type `bitwhich` <double, double, double[]> => double[];
type `c.bit` <integer> => integer;
type `chunk.default` <double, double, double, null, null, integer, character[], null | integer, null | logical> => list<integer[]> | tuple<^integer[]>;
type `intisasc` <^integer[]> => null | logical;
type `intisdesc` <integer[]> => logical;
type `intrle` <integer[]> => null | struct<`lengths`:integer[], `values`:integer[]>;
type `is.bit` <integer> => logical;
type `is.bitwhich` <logical> => logical;
type `is.ri` <integer[]> => logical;
type `length.bit` <null | ^integer[]> => integer;
type `length.bitwhich` <integer[]> => integer;
type `length.ri` <integer[]> => integer;
type `length<-.bit` <integer, double> => ^integer[];
type `length<-.bitwhich` <integer, double> => integer;
type `max.bit` <integer[], null, logical> => null | integer;
type `min.bit` <integer[], null, logical> => null | integer;
type `physical.default` <null | double[] | ^integer[]> => null | struct<`vmode`:character>;
type `range.bit` <integer[], null | integer[], logical> => ^integer[];
type `regtest.bit` <double> => logical;
type `repeat.time` <language, logical, double, environment> => double[];
type `ri` <double, double, null | double> => ^integer[];
type `rlepack.integer` <integer[], logical | symbol, null> => struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>;
type `rleunpack.rlepack` <struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>> => integer[];
type `still.identical` <integer[], integer[]> => logical;
type `sum.bit` <null | integer[], null | integer[], logical> => integer;
type `sum.bitwhich` <integer[], logical> => integer;
type `sum.ri` <integer[], logical> => integer;
type `summary.bit` <integer[], null, null> => ^integer[];
type `unattr` <^logical[]> => ^logical[];
type `unique.rlepack` <struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>, logical, null> => struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>;
type `vecseq` <double[], null | double[], logical, logical> => integer[] | language | tuple<integer[], integer[]> | tuple<language, language>;
type `virtual.default` <null | ^integer[] | double[]> => null | struct<`Length`:integer>;
type `xor.bit` <integer[], integer[] | ^logical[]> => integer[];
type `::` <integer, null, null> => integer;
type `max.ri` <^integer[], logical> => integer;
type `min.ri` <^integer[], logical> => integer;
type `range.ri` <integer[], logical> => integer[];
