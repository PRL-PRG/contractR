type `all.bit` <class<`bit`>, null, ...> => logical;
type `all.bitwhich` <class<`bitwhich`>, ...> => logical;
type `any.bit` <class<`bit`>, null, ...> => logical;
type `any.bitwhich` <class<`bitwhich`>, ...> => logical;
type `anyDuplicated.rlepack` <class<`rlepack`>, logical, ...> => integer;
type `as.bit` <class<`bit`> | class<`ri`> | ^logical[] | class<`bitwhich`>, ...> => class<`bit`>;
type `as.bit.bit` <class<`bit`>, ...> => class<`bit`>;
type `as.bit.bitwhich` <class<`bitwhich`>, ...> => class<`bit`>;
type `as.bit.logical` <^logical[], ...> => class<`bit`>;
type `as.bit.ri` <class<`ri`>, ...> => class<`bit`>;
type `as.bitwhich` <class<`bit`> | class<`bitwhich`> | class<`ri`> | ^logical[], ...> => class<`bitwhich`>;
type `as.bit.which` <class<`which`> | double[], double, ...> => class<`bit`>;
type `as.bitwhich.bit` <class<`bit`>, null, ...> => class<`bitwhich`>;
type `as.bitwhich.bitwhich` <class<`bitwhich`>, ...> => class<`bitwhich`>;
type `as.bitwhich.logical` <^logical[], ...> => class<`bitwhich`>;
type `as.bitwhich.ri` <class<`ri`>, ...> => class<`bitwhich`>;
type `as.double.bit` <class<`bit`>, ...> => double[];
type `as.double.bitwhich` <class<`bitwhich`>, ...> => double[];
type `as.double.ri` <class<`ri`>, ...> => double[];
type `as.integer.bit` <class<`bit`>, ...> => integer[];
type `as.integer.bitwhich` <class<`bitwhich`>, ...> => integer[];
type `as.integer.ri` <class<`ri`>, ...> => integer[];
type `as.logical.bit` <class<`bit`>, ...> => logical[];
type `as.logical.bitwhich` <class<`bitwhich`>, ...> => logical[];
type `as.logical.ri` <class<`ri`>, ...> => logical[];
type `as.which` <class<`bit`> | class<`bitwhich`> | class<`ri`> | logical[], ...> => class<`which`>;
type `as.which.bit` <class<`bit`>, null, ...> => class<`which`>;
type `as.which.bitwhich` <class<`bitwhich`>, ...> => class<`which`>;
type `as.which.default` <logical[], ...> => class<`which`>;
type `as.which.ri` <class<`ri`>, ...> => class<`which`>;
type `bbatch` <double, double> => list<double>;
type `bit` <double> => class<`bit`>;
type `==.bit` <class<`bit`>, class<`bit`> | ^logical[]> => class<`bit`>;
type `|.bit` <class<`bit`>, class<`bit`> | ^logical[]> => class<`bit`>;
type `!=.bit` <class<`bit`>, class<`bit`> | ^logical[]> => class<`bit`>;
type `!.bit` <class<`bit`>> => class<`bit`>;
type `[<-.bit` <class<`bit`>, any, null | ^logical[]> => class<`bit`>;
type `[.bit` <class<`bit`>, any> => any;
type `[[<-.bit` <class<`bit`>, double, logical> => class<`bit`>;
type `[[.bit` <class<`bit`>, double> => logical;
type `&.bit` <class<`bit`>, class<`bit`> | ^logical[]> => class<`bit`>;
type `bit_done` < > => null;
type `bit_init` < > => null;
type `bitwhich` <double, double, double[] | class<`bitwhich`>> => class<`bitwhich`>;
type `==.bitwhich` <class<`bitwhich`>, class<`bitwhich`> | ^logical[]> => class<`bitwhich`>;
type `|.bitwhich` <class<`bitwhich`>, class<`bitwhich`> | ^logical[]> => class<`bitwhich`>;
type `!=.bitwhich` <class<`bitwhich`>, class<`bitwhich`> | ^logical[]> => class<`bitwhich`>;
type `!.bitwhich` <class<`bitwhich`>> => class<`bitwhich`>;
type `&.bitwhich` <class<`bitwhich`>, class<`bitwhich`> | ^logical[]> => class<`bitwhich`>;
type `c.bit` <...> => class<`bit`>;
type `c.bitwhich` <...> => class<`bitwhich`>;
type `chunk` <...> => list<class<`ri`>>;
type `chunk.default` <double, double, double, null, null, integer, character[], null, ...> => list<class<`ri`>>;
type `clone` <integer[], ...> => integer[];
type `clone.default` <integer[], ...> => integer[];
type `FUN` <class<`bit`> | class<`ri`> | ^logical[] | class<`bitwhich`>, ...> => class<`bit`>;
type `intisasc` <^integer[]> => (logical | null);
type `intisdesc` <integer[]> => logical;
type `intrle` <integer[]> => (class<`rle`> | null);
type `is.bit` <class<`bit`> | logical> => logical;
type `is.bitwhich` <class<`bitwhich`> | logical> => logical;
type `is.ri` <class<`ri`> | logical> => logical;
type `length<-.bit` <class<`bit`>, double> => class<`bit`>;
type `length.bit` <class<`bit`>> => integer;
type `length<-.bitwhich` <class<`bitwhich`>, double> => class<`bitwhich`>;
type `length.bitwhich` <class<`bitwhich`>> => integer;
type `length.ri` <class<`ri`>> => integer;
type `max.bit` <class<`bit`>, null, ...> => (integer | null);
type `max.bitwhich` <class<`bitwhich`>, ...> => integer;
type `min.bit` <class<`bit`>, null, ...> => (integer | null);
type `min.bitwhich` <class<`bitwhich`>, ...> => integer;
type `physical` <class<`bit`>> => list<character>;
type `physical.default` <class<`bit`>> => list<character>;
type `range.bit` <class<`bit`>, integer[] | null, ...> => ^integer[];
type `range.bitwhich` <class<`bitwhich`>, ...> => integer;
type `regtest.bit` <double> => logical;
type `repeat.time` <any, logical, double, environment> => class<`proc_time`>;
type `repfromto` <integer[], double, double> => integer[];
type `ri` <double, double, double | null> => class<`ri`>;
type `rlepack` <integer[], ...> => class<`rlepack`>;
type `rlepack.integer` <integer[], logical, ...> => class<`rlepack`>;
type `rleunpack` <class<`rlepack`>> => integer[];
type `rleunpack.rlepack` <class<`rlepack`>> => integer[];
type `setattr` <double[], character, null> => null;
type `still.identical` <integer[], integer[]> => logical;
type `sum.bit` <class<`bit`>, integer[] | null, ...> => integer;
type `sum.bitwhich` <class<`bitwhich`>, ...> => integer;
type `summary.bit` <class<`bit`>, null, ...> => ^integer[];
type `summary.bitwhich` <class<`bitwhich`>, ...> => integer;
type `sum.ri` <class<`ri`>, ...> => integer;
type `unattr` <^logical[]> => ^logical[];
type `unique.rlepack` <class<`rlepack`>, logical, ...> => class<`rlepack`>;
type `vecseq` <double[], double[] | null, logical, logical> => (class<`call`> | integer[] | list<class<`call`> | integer[]>);
type `virtual` <class<`bit`>> => list<integer>;
type `virtual.default` <class<`bit`>> => list<integer>;
type `xor` <class<`bit`> | class<`bitwhich`> | logical[], class<`bit`> | ^logical[] | class<`bitwhich`>> => (class<`bit`> | class<`bitwhich`> | logical[]);
type `xor.bit` <class<`bit`>, class<`bit`> | ^logical[]> => class<`bit`>;
type `xor.bitwhich` <class<`bitwhich`>, class<`bitwhich`> | ^logical[]> => class<`bitwhich`>;
type `xor.default` <logical[], logical[]> => logical[];
