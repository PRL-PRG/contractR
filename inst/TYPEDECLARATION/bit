type `bit_init` < > => null;
type `clone.default` <double[], ???> => double[];
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null;
type `setattr` <? ^double[] | environment, character, ? environment | ^character[]> => null;
type `xor.default` <^integer[], ^integer[]> => ^logical[];
type `!.bit` <integer[]> => integer[];
type `!.bitwhich` <integer[]> => integer[];
type `!=.bit` <integer[], integer[] | ^logical[]> => integer[];
type `!=.bitwhich` <integer[], integer[] | ^logical[]> => integer[];
type `[.bit` <^integer[], ^double[] | ???> => ^logical[];
type `[[.bit` <integer, double> => logical;
type `[[<-.bit` <integer, double, logical> => integer;
type `[<-.bit` <? integer[], double | integer[] | ???, ? ^logical[]> => ? ^integer[];
type `&.bit` <integer[], integer[] | ^logical[]> => integer[];
type `==.bit` <integer[], integer[] | ^logical[]> => integer[];
type `==.bitwhich` <integer[], integer[] | ^logical[]> => integer[];
type `|.bit` <integer[], integer[] | ^logical[]> => integer[];
type `all.bit` <integer[], null, logical> => logical;
type `all.bitwhich` <logical, logical> => logical;
type `any.bit` <integer[], null, logical> => logical;
type `any.bitwhich` <logical, logical> => logical;
type `anyDuplicated.rlepack` <struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>, logical, ???> => integer;
type `as.bit.bit` <integer[], ???> => integer[];
type `as.bit.logical` <^logical[], ???> => integer[];
type `as.bit.ri` <integer[], ???> => ? integer[];
type `as.bit.which` <double[], double, ???> => integer[];
type `as.bitwhich.bit` <integer[], null, ???> => integer[];
type `as.bitwhich.bitwhich` <integer[], ???> => integer[];
type `as.bitwhich.logical` <^logical[], ???> => integer[];
type `as.bitwhich.ri` <integer[], ???> => integer[];
type `as.double.bit` <integer, ???> => double[];
type `as.double.bitwhich` <integer[], ???> => double[];
type `as.double.ri` <integer[], ???> => double[];
type `as.integer.bit` <integer, ???> => integer[];
type `as.integer.bitwhich` <integer[], ???> => integer[];
type `as.integer.ri` <integer[], ???> => integer[];
type `as.logical.bit` <integer[], ???> => logical[];
type `as.logical.bitwhich` <integer[], ???> => logical[];
type `as.logical.ri` <integer[], ???> => logical[];
type `as.which.bit` <integer[], null, ???> => integer[];
type `as.which.bitwhich` <integer[], ???> => integer[];
type `as.which.default` <logical[], ???> => integer[];
type `as.which.ri` <integer[], ???> => integer[];
type `bit` <double> => integer[];
type `bit_done` < > => null;
type `bitwhich` <double, double, double[]> => double[];
type `c.bit` <integer> => integer;
type `chunk.default` <double, double, double, null, null, integer, character[], ? integer, ??? | logical> => list<integer[]> | tuple<^integer[]>;
type `intisasc` <^integer[]> => ? logical;
type `intisdesc` <integer[]> => logical;
type `intrle` <integer[]> => ? struct<`lengths`:integer[], `values`:integer[]>;
type `is.bit` <integer> => logical;
type `is.bitwhich` <logical> => logical;
type `is.ri` <integer[]> => logical;
type `length.bit` <? ^integer[]> => integer;
type `length.bitwhich` <integer[]> => integer;
type `length.ri` <integer[]> => integer;
type `length<-.bit` <integer, double> => ^integer[];
type `length<-.bitwhich` <integer, double> => integer;
type `max.bit` <integer[], null, logical> => ? integer;
type `min.bit` <integer[], null, logical> => ? integer;
type `physical.default` <? double[] | ^integer[]> => ? struct<`vmode`:character>;
type `range.bit` <integer[], ? integer[], logical> => ^integer[];
type `regtest.bit` <double> => logical;
type `repeat.time` <language, logical, double, environment> => double[];
type `ri` <double, double, ? double> => ^integer[];
type `rlepack.integer` <integer[], logical | symbol, ???> => struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>;
type `rleunpack.rlepack` <struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>> => integer[];
type `still.identical` <integer[], integer[]> => logical;
type `sum.bit` <? integer[], ? integer[], logical> => integer;
type `sum.bitwhich` <integer[], logical> => integer;
type `sum.ri` <integer[], logical> => integer;
type `summary.bit` <integer[], null, ???> => ^integer[];
type `unattr` <^logical[]> => ^logical[];
type `unique.rlepack` <struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>, logical, ???> => struct<`first`:integer, `dat`:integer[], `last`:integer> | struct<`first`:integer, `dat`:struct<`lengths`:integer[], `values`:integer[]>, `last`:integer>;
type `vecseq` <double[], ? double[], logical, logical> => integer[] | language | tuple<integer[], integer[]> | tuple<language, language>;
type `virtual.default` <? ^integer[] | double[]> => ? struct<`Length`:integer>;
type `xor.bit` <integer[], integer[] | ^logical[]> => integer[];
type `::` <integer, null, ???> => integer;
type `max.ri` <^integer[], logical> => integer;
type `min.ri` <^integer[], logical> => integer;
type `range.ri` <integer[], logical> => integer[];
