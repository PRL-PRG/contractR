type `%::%` <any, any> => null;
type `add_type` <character, list<class<`data.frame`> | character>> => null;
type `add_variant` <character, list<any>, environment> => null;
type `%as%` <any, any> => null;
type `body_fn` <class<`data.frame`>, class<`data.frame`>, environment> => class<`function`>;
type `check_types` <null | list<class<`data.frame`> | character | integer[]>, any> => logical;
type `clean_defaults` <list<any>> => (^character[] | null);
type `clean_tokens` <list<any>> => character[];
type `dereference_type` <character[], list<character[]>> => class<`function`>;
type `fill_args` <list<any>, character[], ^character[] | null, integer[]> => list<any>;
type `filter` <character[]> => logical[];
type `from_root_env` <pairlist> => logical;
type `FUN` <integer> => character | <integer> => null | <integer> => null | <character> => logical | <class<`GradientDescent`, `list`> | class<`Integer`, `numeric`> | class<`NewtonRaphson`, `list`> | character | double> => character[] | <class<`GradientDescent`, `list`> | class<`Integer`, `numeric`> | class<`NewtonRaphson`, `list`> | character | double> => character[] | <integer> => logical | <integer> => class<`data.frame`> | <integer> => null | <integer> => character | <integer> => character;
type `get_function_env` < > => environment;
type `get_lr` <character> => (class<`function`, `lambdar.fun`> | class<`function`, `lambdar.type`>);
type `get_name` <class<`function`>> => character;
type `get_type` <any, null | double> => (null | list<class<`data.frame`> | character | integer[]>);
type `get_type_index` <class<`function`, `lambdar.fun`> | class<`function`, `lambdar.type`>, any, any> => (double | null);
type `get_variant` <class<`function`, `lambdar.type`> | class<`function`, `lambdar.fun`>, integer> => list<list<any>>;
type `guard_fn` <class<`data.frame`>, class<`data.frame`> | null, any> => (class<`function`> | null);
type `has_ellipsis` <character[]> => integer[];
type `has_variant` <list<any>, any, any, any> => (logical[] | list<any>);
type `idx_ellipsis` <list<class<`data.frame`> | class<`function`> | character>> => integer[];
type `init_function` <character, environment> => (class<`function`, `lambdar.fun`> | class<`function`, `lambdar.type`>);
type `%isa%` <double, any> => logical;
type `is.bound` <character> => logical;
type `is.infix` <character> => logical;
type `is.type` <character> => logical;
type `it` <logical, logical> => (class<`data.frame`> | null);
type `iterator` <class<`data.frame`>> => class<`function`>;
type `NewObject` <any, character, ...> => (class<`GradientDescent`, `list`> | class<`Integer`, `numeric`> | class<`NewtonRaphson`, `list`> | class<`Point`, `list`>);
type `parse_body` <class<`function`>> => class<`data.frame`>;
type `parse_eval` <class<`function`>, null> => class<`data.frame`>;
type `parse_fun` <class<`function`>, null> => class<`data.frame`>;
type `parse_guard` <class<`function`>> => (class<`data.frame`> | null);
type `parse_infix` <class<`data.frame`>> => null;
type `parse_types` <class<`function`>, class<`data.frame`>, any> => class<`data.frame`>;
type `print.lambdar.fun` <class<`function`, `lambdar.fun`>, ...> => null;
type `rep.fn` <integer, character, character> => class<`data.frame`>;
type `return_type` <list<class<`data.frame`> | character | integer[]>, list<any>, any> => character;
type `seal` <class<`function`, `lambdar.fun`>> => null;
type `setup_parent` <character, environment> => (class<`function`, `lambdar.fun`> | class<`function`, `lambdar.type`> | null);
type `.sync_debug` <any> => null;
type `target_env` <class<`call`>, integer> => environment;
type `transform_attrs` <class<`data.frame`> | null> => (class<`data.frame`> | null);
type `UseFunction` <any, character, ...> => (class<`Integer`, `numeric`> | double | list<class<`function`> | class<`function`> | double | double>);
