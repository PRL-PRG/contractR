type `addvar` <...> => class<`mcnode`>;
type `converg` <class<`mcnode`>, any, character, double, double, double[], any, null, logical> => null;
type `cornode` <..., class<`matrix`>, logical, logical, null> => (class<`matrix`> | list<class<`mcnode`>>);
type `dbetagen` <double[], double, double, double, double, double, logical> => double[];
type `ddirichlet` <class<`matrix`>, class<`matrix`>> => double[];
type `dempiricalC` <double[], double, double, class<`matrix`> | integer[], null | double[], logical> => double[];
type `dempiricalD` <double[], class<`matrix`> | integer[], null | double[], logical> => double[];
type `dimmc` <class<`mc`>> => integer[];
type `dimmcnode` <class<`mcnode`>> => integer[];
type `dmultinomial` <class<`matrix`> | double[], null, class<`matrix`> | double[], logical> => double[];
type `evalmcmod` <expression, double, double, double> => class<`mc`>;
type `extractvar` <class<`mcnode`>, double[]> => class<`mcnode`>;
type `filter` <character[]> => logical[];
type `FUN` <class<`mcnode`>> => integer[] | <integer> => double[] | <integer> => double[] | <double[]> => logical[] | <integer> => double | <double[]> => logical | <integer> => double[] | <integer> => double | <integer> => double[] | <integer> => integer[] | <class<`mcnode`>> => logical | <class<`mcnode`> | double> => (integer | null) | <class<`array`>> => class<`array`> | <integer> => double[] | <class<`mcnode`> | double> => (integer | null) | <integer> => double[] | <class<`array`>> => double[] | <class<`matrix`>> => double[] | <class<`mcnode`> | double> => (integer | null) | <integer> => double[] | <integer, double[], double[]> => double[] | <integer[]> => integer[] | <integer> => class<`matrix`> | <double[]> => logical | <class<`name`>> => character;
type `graph` <class<`matrix`>, character, character> => null;
type `iman` <class<`matrix`>> => class<`matrix`>;
type `is.mc` <class<`mc`>> => logical;
type `list.names` <...> => list<character> | <...> => character[];
type `mc` <..., null, logical> => class<`mc`>;
type `mcdata` <class<`mcnode`> | double[], character[], any, any, double, character> => class<`mcnode`>;
type `mcstoc` <class<`function`>, character[], ..., any, any, double, character[], character, null, logical, any, double> => class<`mcnode`>;
type `ndunc` <any> => double;
type `ndvar` <any> => double;
type `onerow` <double[], double, double, integer[], double[]> => double[] | <double[], double, double, integer[], double[]> => double[];
type `Ops.mcnode` <class<`mcnode`> | double, class<`mcnode`>> => class<`mcnode`>;
type `pempiricalC` <double[], double, double, integer[], double[], logical, logical> => double[];
type `pempiricalD` <integer[], integer[], double[], logical, logical> => double[];
type `pmax` <..., logical> => integer[];
type `pmax.default` <..., logical> => integer[];
type `qempiricalC` <double[], double, double, class<`matrix`>, null, logical, logical> => double[];
type `qempiricalD` <double[], integer[], double[], logical, logical> => double[];
type `rbern` <double, double[]> => integer[];
type `rdirichlet` <double, class<`matrix`> | double[]> => class<`matrix`>;
type `rempiricalD` <double, class<`matrix`> | double[], double[] | null> => double[];
type `rmultinomial` <double, double[] | class<`matrix`>, double[] | class<`matrix`>> => class<`matrix`>;
type `typemcnode` <class<`mcnode`>, logical> => character;
