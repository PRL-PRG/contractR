type `Beta_Weights` <double[], double[]> => double[];
type `Beta.Weights` <double[], double[]> => double[];
type `Check_File_Exists` <character> => any;
type `Check_Sex_Var` <class<`formula`>, character, null> => double[];
type `Dist_Case` <double[], double> => double[];
type `Dist_Case_Control` <double[], double, double> => double[];
type `Dist_Control` <double[], double> => double[];
type `emma.delta.REML.LL.wo.Z` <double, double[], class<`matrix`>> => double;
type `emma.eigen.R.wo.Z` <class<`matrix`>, class<`matrix`>> => list<double[] | class<`matrix`>>;
type `fast.invFisher` <class<`matrix`>> => class<`matrix`>;
type `fast.logDet` <class<`matrix`>> => double;
type `fast.logistf.control` <double, double, double, double, double, double> => list<double>;
type `fast.logistf.fit` <class<`matrix`>, double[], null, null, logical, integer[] | null, null, any> => list<double[] | class<`matrix`>>;
type `Generate_SSD_SetID` <character, character, character, character, character, character, logical> => any;
type `Generate_SSD_SetID_Work` <character, character, character, character, character, character, any> => any;
type `Get_A` <class<`matrix`>, double[], double[], double> => class<`matrix`>;
type `Get_A_Q` <class<`matrix`>> => class<`matrix`>;
type `Get_B` <class<`matrix`>, double[], double[], double> => class<`matrix`>;
type `Get_Beta` <character, double[], double, double> => double[];
type `Get_B_Q` <class<`matrix`>, double[]> => class<`matrix`>;
type `Get_CausalSNPs` <double[], double, double> => integer[];
type `Get_Critical_Value` <double[], double> => list<double[] | list<double>>;
type `Get_Davies_PVal` <class<`matrix`>, class<`matrix`>, double[] | null> => list<double[] | null | list<double[]> | double | null | list<double>>;
type `Get_Lambda` <class<`matrix`>> => double[];
type `Get_Lambda_U_From_Z` <class<`matrix`>> => list<double[] | class<`matrix`>>;
type `Get_Liu_Params` <double[]> => list<double>;
type `Get_Liu_Params_Mod` <double[]> => list<double>;
type `Get_Liu_Params_Mod_Lambda` <double[]> => list<double>;
type `Get_Liu_PVal.MOD.Lambda` <double[], double[], logical> => double[];
type `Get_Logistic_Weights` <class<`matrix`>, double, double> => double[];
type `Get_Logistic_Weights_MAF` <double[], double, double> => double[];
type `Get_MAF` <class<`matrix`>> => double[];
type `Get_PI_New` <double[], double> => double[];
type `Get_Power_Continuous` <class<`matrix`>, double[], double[], double[], double[]> => class<`matrix`>;
type `Get_Power_Logistic` <class<`matrix`>, double[], double, double, double[], double[], double[]> => class<`matrix`>;
type `Get_PValue` <class<`matrix`>, double[]> => list<double[] | null | double | null>;
type `Get_PValue.Lambda` <double[], double[]> => list<double[] | null | double | null>;
type `Get_RandomRegion` <integer[], double> => integer[];
type `Get_RequiredSampleSize` <class<`SKAT_Power`>, double> => list<character | double | character>;
type `Get_RequiredSampleSize.numeric` <class<`matrix`>, double> => list<character | double | character>;
type `Get_RequiredSampleSize.SKAT_Power` <class<`SKAT_Power`>, double> => list<character | double | character>;
type `Get_Resampling_Pvalue` <class<`SKAT_OUT`>> => list<double>;
type `Get_Res_Arrays` <double[], null, integer[]> => list<double[]>;
type `Get_SKAT_Residuals.Get_X1` <class<`matrix`>> => class<`matrix`>;
type `Get_SKAT_Residuals.linear` <class<`formula`>, null, double, character, integer[]> => list<any>;
type `Get_SKAT_Residuals.logistic` <class<`formula`>, null | list<class<`matrix`> | double[] | list<class<`matrix`>>>, double, character, integer[]> => list<any>;
type `Get_Total_K` <integer> => list<double[]>;
type `Get_W_New` <double[], double[]> => double[];
type `Impute` <class<`matrix`>, character> => class<`matrix`>;
type `KMTest.linear.Linear` <double[], class<`matrix`>, class<`matrix`>, character, any, double, character, any, double, double> => list<any>;
type `KMTest.logistic.Linear` <double[], class<`matrix`>, class<`matrix`>, character, any, double[], character, any, double, double> => list<any>;
type `KMTest.logistic.Linear.VarMatching` <double[], class<`matrix`>, class<`matrix`>, character, null | double[], double[], character, any, double, double, double[], null | class<`matrix`>, double[] | null> => list<any>;
type `Met_SKAT_Get_Pvalue` <double[], class<`matrix`>, double[], character, null> => list<double | null | list<double[]>>;
type `MSG_SKAT_Example` < > => null;
type `Power_Continuous` <null, null, double, double, double, double[], double[], double[], double, character, double, double> => class<`SKAT_Power`>;
type `Power_Logistic` <null, null, double, double, double, double, double, double[], double[], double[], double, character, double, double> => class<`SKAT_Power`>;
type `SKAT` <class<`matrix`>, class<`SKAT_NULL_Model`> | class<`SKAT_NULL_Model_ADJ`> | class<`SKAT_NULL_Model_EMMAX`>, character, character, any, double[] | null, any, double, logical, logical, double, double, double> => class<`SKAT_OUT`>;
type `SKAT_1` <class<`matrix`>, class<`SKAT_NULL_Model`>, ...> => class<`SKAT_OUT`>;
type `SKAT_2Kernel_Optimal_Get_Q` <class<`matrix`>, class<`matrix`>, double[], double[], double, any, null> => list<double[] | null>;
type `SKAT_2Kernel_Ortho_Optimal_Each_Q` <any, class<`matrix`>, double[], class<`matrix`>> => list<double | class<`matrix`>>;
type `SKAT_2Kernel_Ortho_Optimal_Get_Params_each_r` <class<`matrix`>, class<`matrix`>, double[]> => class<`matrix`>;
type `SKAT_2Kernel_Ortho_Optimal_Get_Pvalue` <class<`matrix`>, class<`matrix`>, class<`matrix`>, double[], any> => list<double | class<`matrix`>>;
type `SKAT_2Kernel_Ortho_Optimal_Param` <class<`matrix`>, class<`matrix`>, double[]> => list<list<double[]>>;
type `SKAT_2Kernel_Ortho_Optimal_PValue_Liu` <double[], list<list<double[]>>, double[], double> => double;
type `SKATBinary` <class<`matrix`>, class<`SKAT_NULL_Model`>, character, character, character, double[], null, double, character, logical, logical, double, double, double, any, double, any, null> => (class<`SKAT_OUT`> | list<any>);
type `SKATBinary_RestoreSeed` <any> => double;
type `SKATBinary_SeedNum` <double> => double;
type `SKATBinary_Single` <double[], class<`SKAT_NULL_Model`>, character, character, logical, logical, double, double, double, any, double, any> => list<any>;
type `SKATBinary.Single.CheckZ` <double[], integer[], any, logical, logical, double> => list<double[]>;
type `SKAT_Check_Method` <character, any, integer | null, integer | null> => list<character | double[] | character | double>;
type `SKAT_Check_RCorr` <any, double[]> => (double | null);
type `SKAT_ChrX` <class<`matrix`>, class<`SKAT_NULL_Model_ChrX`>, logical, character, character, double[], null, character, double, logical, logical, double, double, double, null> => class<`SKAT_OUT`>;
type `SKAT_Code_XChr` <class<`matrix`>, logical, double[]> => class<`matrix`>;
type `SKAT_CommonRare` <class<`matrix`>, class<`SKAT_NULL_Model`>, any, any, character, double, double, null | double, character, logical, double, double, null> => (class<`SKAT_OUT`> | list<any>);
type `SKAT_CR_Linear` <class<`SKAT_NULL_Model`>, class<`matrix`>, class<`matrix`>, double[], logical> => list<double | null | list<double[]>>;
type `SKAT_CR_Optimal` <double[], class<`matrix`>, class<`matrix`>, class<`matrix`>, any, any, any, double, double[], character> => list<double | null | list<double[]>>;
type `SKAT_davies` <double, double[], double[], double[], double, double, double> => list<double[]>;
type `SKAT_emmaX` <class<`matrix`>, class<`SKAT_NULL_Model_EMMAX`>, character, character, double[], null, any, double, logical, logical, double, double, double, null> => list<any>;
type `SKAT_emmaX_work` <any, class<`matrix`>, class<`SKAT_NULL_Model_EMMAX`>, character, character, double[], double> => list<any>;
type `SKATExactBin` <class<`matrix`>, class<`SKAT_NULL_Model`>, character, character, double[], null, any, double[], any, logical, double, double, null, double, any, double, double, logical, null, logical> => list<any>;
type `SKATExactBin.Adaptive` <class<`matrix`>, class<`SKAT_NULL_Model`>, character, double[], null, any, double, any, logical, double, double, double, double, null, double, double> => list<double | null | list<integer>>;
type `SKATExactBin_Check` <class<`matrix`>, class<`SKAT_NULL_Model`>, any, double[], null, any, double[], logical, double, double, any, double, logical, logical> => list<class<`matrix`> | class<`SKAT_NULL_Model`> | double[]>;
type `SKATExactBin_CheckAccuracy` <double, double, double> => logical;
type `SKATExactBin_CheckObj` <class<`SKAT_NULL_Model`>> => class<`SKAT_NULL_Model`>;
type `SKATExactBin.ComputeProb_Group` <integer[], double[], integer, double, double> => list<double[]>;
type `SKATExactBin.ComputProb_New` <integer[], double[], integer, double, double, any, any, double> => list<double[]>;
type `SKATExactBin.ComputProb_Random` <list<double[]>, integer[], double[], integer, any, double, double, double> => list<double[] | class<`matrix`>>;
type `SKATExactBin.Firth` <class<`matrix`>, class<`SKAT_NULL_Model`>, character, character, double[], null, any, double, any, logical, double, double, null, double, logical> => list<double | null>;
type `SKATExactBin.Moment` <class<`matrix`>, double[], double[], double, integer[], double, null, class<`matrix`>, double[], character> => list<any>;
type `SKATExactBin.SKATO_GetQParam` <class<`matrix`>, double[], integer[], double[], double[], double[], any, null, double, logical> => list<class<`matrix`> | integer>;
type `SKATExactBin.Work` <class<`matrix`>, double[], double[], double, integer[], double[], null, any, any, double, any, double, any> => list<double | null>;
type `SKATExactBin.Work_Adaptive` <class<`matrix`>, double[], double[], double, integer[], double, null, logical, null, double, double, double, double> => list<double | null>;
type `SKAT_Get_Cov_Param` <double[], double[], class<`matrix`>> => list<double[]>;
type `SKAT_Get_DF_Sim` <double[]> => double;
type `SKAT_GET_kurtosis` <double[]> => double;
type `SKAT_Get_MAF` <class<`matrix`>, integer[] | null, logical, any> => double[];
type `SKAT_Get_Var_Elements` <double[], any, double[], double[]> => double;
type `SKAT.linear.Linear` <double[], class<`matrix`>, class<`matrix`>, character, any, double, character, any, double, double[], logical> => list<any>;
type `SKAT.logistic.Linear` <double[], class<`matrix`>, class<`matrix`>, character, any, double[], character, any, double, double[], logical> => list<any>;
type `SKAT_Logistic_VarMatching_GetParam` <double[], class<`matrix`>, double[], double[]> => list<double[] | list<double>>;
type `SKAT_Logistic_VarMatching_GetParam1` <class<`matrix`>, double[], double[], character> => list<double[] | list<double>>;
type `SKAT_MAIN_Check_OutType` <character> => null;
type `SKAT_MAIN_Check_Z` <class<`matrix`>, integer, integer[], any, double[] | null, any, any, logical, logical, double, double, double, logical, null | double[]> => list<class<`matrix`> | double[] | class<`matrix`> | double | integer[]>;
type `SKAT_MAIN_Check_Z_Flip` <class<`matrix`>, any, logical, any> => class<`matrix`>;
type `SKAT_MAIN_Check_Z_Impute` <class<`matrix`>, integer[], any, any, logical, any> => class<`matrix`>;
type `SKAT_META_Optimal` <double[], class<`matrix`>, double[], character, null> => list<double | null | list<double[]>>;
type `SKAT_META_Optimal_Get_Pvalue` <class<`matrix`>, class<`matrix`>, double[], character> => list<double | class<`matrix`>>;
type `SKAT_META_Optimal_Get_Q` <double[], double[]> => list<double[]>;
type `SKAT_META_Optimal_Param` <class<`matrix`>, double[]> => list<double[]>;
type `SKAT_NULL_emmaX` <class<`formula`>, null, class<`matrix`>, null, double, double, double, double, logical> => class<`SKAT_NULL_Model_EMMAX`>;
type `SKAT_Null_Model` <class<`formula`>, null, character, double, character, logical> => (class<`SKAT_NULL_Model`> | class<`SKAT_NULL_Model_ADJ`>);
type `SKAT_Null_Model_ChrX` <class<`formula`>, character, null | list<class<`matrix`> | double[] | list<class<`matrix`>>>, character, double, character, logical> => class<`SKAT_NULL_Model_ChrX`>;
type `SKAT_Null_Model_Get_Includes` <class<`data.frame`>, class<`data.frame`>> => integer[];
type `SKAT_Null_Model_MomentAdjust` <class<`formula`>, null, double, character, logical, double> => class<`SKAT_NULL_Model_ADJ`>;
type `SKAT_Optimal_Each_Q` <any, class<`matrix`>, double[], list<double[]>, character> => list<double | class<`matrix`>>;
type `SKAT_Optimal_Get_Pvalue` <class<`matrix`>, class<`matrix`>, double[], character> => list<double | class<`matrix`>>;
type `SKAT_Optimal_Get_Q` <class<`matrix`>, double[], double[], double, any, null, null> => list<double[] | null>;
type `SKAT_Optimal_Linear` <double[], class<`matrix`>, class<`matrix`>, character, double[], double, character, any, double, double[]> => list<any>;
type `SKAT_Optimal_Logistic` <double[], class<`matrix`>, class<`matrix`>, character, double[], double[], character, any, double, double[]> => list<any>;
type `SKAT_Optimal_Param` <class<`matrix`>, double[]> => list<double[]>;
type `SKAT_Optimal_PValue_Davies` <double[], list<double[]>, double[], double> => double;
type `SKAT_PValue_Logistic_VarMatching` <double, class<`matrix`>, double[], double[], character> => list<double | null | list<double[] | list<double>>>;
type `SKAT_RunFrom_MetaSKAT` <class<`matrix`>, class<`matrix`>, null, character, double[], null, null, class<`matrix`>, character, character, null, double, double[]> => list<double | null | list<double[]>>;
type `SKAT_Scale_Genotypes` <class<`SKAT_NULL_Model`>, class<`matrix`>, class<`matrix`>, double[], double[], null, double, double> => list<class<`matrix`> | double>;
type `SKAT_With_NullModel` <class<`matrix`>, class<`SKAT_NULL_Model`> | class<`SKAT_NULL_Model_ChrX`>, character, character, any, any, any, double, any, any, any, any, any, any, null | list<class<`matrix`> | double[]>> => list<any>;
type `SKAT_With_NullModel_ADJ` <class<`matrix`>, class<`SKAT_NULL_Model_ADJ`>, character, character, double[], null, any, double, logical, logical, double, double, double, null, null> => list<any>;
type `trace.SKAT` <class<`matrix`>> => double;
