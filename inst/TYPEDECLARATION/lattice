type `::` <class<`formula`> | class<`data.frame`>, any, ...> => class<`trellis`> | <class<`formula`> | class<`matrix`>, any, ...> => class<`trellis`> | <class<`formula`> | class<`table`>, any, ...> => class<`trellis`> | <class<`formula`> | double[], any, ...> => class<`trellis`> | <character> => double | <class<`formula`>, class<`data.frame`>, ...> => class<`trellis`>;
type `$` <double[], double, null, logical, ...> => list<double[] | list<list<double[] | double[] | character[]>> | double[] | list<list<integer[] | double | integer[] | character[] | double>>> | <character, list<character | double[] | null>, any, any, character[], character[], ..., character> => null | <double[], double, null, logical, ...> => list<double[] | list<list<double[] | double[] | character[]>> | double[] | list<list<integer[] | double | integer[] | character[]>>>;
type `as.character.shingleLevel` <class<`shingleLevel`>, ...> => character[];
type `as.factorOrShingle` <class<`factor`> | class<`shingle`> | double[], logical, logical> => (class<`factor`> | class<`shingle`>);
type `as.shingle` <class<`shingle`> | double[]> => class<`shingle`>;
type `atBoundary` < > => logical;
type `barchart` <class<`formula`> | class<`table`>, any, ...> => class<`trellis`>;
type `barchart.formula` <class<`formula`>, class<`data.frame`>, character, character, double, ...> => class<`trellis`>;
type `barchart.table` <class<`table`>, null, logical, double, logical, ..., logical> => class<`trellis`>;
type `bwplot` <class<`formula`>, class<`data.frame`>, ...> => class<`trellis`>;
type `bwplot.formula` <class<`formula`>, class<`data.frame`>, logical, logical, logical | list<character | double>, character | double, character | class<`function`>, null, list<any>, logical, any, any> => class<`trellis`>;
type `calculateAxisComponents` <double[], ..., any, any, logical | null, any> => list<double[] | character[] | character[] | double[]>;
type `calculateGridLayout` <class<`trellis`>, double, double, any, list<double | character | null>, list<double | character | null>, null | class<`gDesc`, `grob`, `text`>, null, class<`gDesc`, `grob`, `text`> | null, class<`gDesc`, `grob`, `text`> | null, null, null> => list<class<`layout`> | list<double[]>>;
type `canonical.theme` <character, logical> => list<list<any>>;
type `checkArgsAndCall` <class<`function`>, list<any>> => (class<`path`, `vpPath`> | double[] | null);
type `chooseFace` <null, double> => double;
type `cloud` <class<`formula`> | class<`table`>, any, ...> => class<`trellis`>;
type `cloud.formula` <class<`formula`>, class<`data.frame`> | null, logical, logical, logical, double[], double, character, null, list<any>, logical | class<`function`>, any> => class<`trellis`>;
type `cloud.table` <class<`table`>, null, logical, character, character[], ...> => class<`trellis`>;
type `complete_names` <list<double | double | character | character>, list<character | double | null>, logical> => list<double | double | character | character>;
type `compute.layout` <double[] | null, integer[], logical> => double[];
type `compute.packet` <list<class<`factor`> | class<`shingle`> | class<`shingle`> | class<`factor`>>, double[]> => logical[];
type `concat` <list<class<`factor`> | class<`matrix`> | double[]>> => (class<`factor`> | class<`matrix`> | double[]);
type `cond.orders` <class<`trellis`> | list<any>, ...> => list<integer[] | list<integer[]> | integer | list<integer[]> | integer | list<integer>>;
type `construct.legend` <null, null | list<any>, character> => (null | list<list<any>>);
type `construct.scales` <logical, character, double[], double, logical, logical, character | logical, double[], character, logical, double, null> => list<list<character | double[] | null>>;
type `contourplot` <class<`formula`>, class<`data.frame`>, ...> => class<`trellis`>;
type `contourplot.formula` <class<`formula`>, class<`data.frame`>, character, any, double, logical, logical, logical, logical, ...> => class<`trellis`>;
type `convertTri` <null, logical> => double;
type `cupdate` <double[], integer[]> => double[];
type `current.column` <character> => double;
type `current.panel.limits` <character> => list<double[]>;
type `current.row` <character> => double;
type `.defaultLatticeOptions` < > => list<any>;
type `.defaultLatticePrefixStatus` < > => list<double>;
type `.defaultLatticeStatus` < > => list<double>;
type `densityplot` <class<`formula`> | double[], any, ...> => class<`trellis`>;
type `densityplot.formula` <class<`formula`>, class<`data.frame`> | environment, logical, logical, logical, character, character, null, list<any>, logical, null, null> => class<`trellis`>;
type `densityplot.numeric` <double[], null, character, ...> => class<`trellis`>;
type `determineStatus` <logical | list<list<double[] | double[] | character[] | integer[] | double | integer[] | character[] | double | integer[] | double | integer[] | character[]>>> => logical;
type `do.breaks` <double[], double> => double[];
type `dotplot` <class<`formula`>, class<`data.frame`>, ...> => class<`trellis`>;
type `dotplot.formula` <class<`formula`>, class<`data.frame`>, character, character, ...> => class<`trellis`>;
type `drawInViewport` <class<`frame`, `gDesc`, `gTree`, `grob`> | class<`gDesc`, `grob`, `text`>, class<`viewport`>> => class<`path`, `vpPath`>;
type `emptyLabel` <character | null | list<character | double>> => logical;
type `equal.count` <double[] | class<`ts`>, ...> => class<`shingle`>;
type `evaluate.legend` <null | list<list<character | list<logical | list<double[] | character>>>>> => (null | list<list<class<`frame`, `gDesc`, `gTree`, `grob`>>>);
type `experimentalOptions` < > => list<list<list<double | character | null>>>;
type `expr2char` <class<`(`> | class<`call`> | class<`name`>> => character;
type `extend.limits` <character[] | double[], double, character, any> => double[];
type `filter` <character[]> => logical[];
type `formatLabel` <character[], null, null, null> => character[];
type `formattedTicksAndLabels` <double[], ...> => list<double[] | character[] | character[] | double[]>;
type `formattedTicksAndLabels.default` <double[], logical, any, logical, logical, ..., any, null, double, any, any> => list<double[] | character[] | character[] | double[]>;
type `fun` <any, any> => null | <list<double[] | character>, logical, null> => class<`frame`, `gDesc`, `gTree`, `grob`>;
type `FUN` <class<`(`> | class<`call`> | class<`name`>> => character | <list<double[]>, double> => double | <double[]> => double | <integer[]> => logical | <double[]> => character | <class<`name`>> => double[] | <class<`name`> | class<`(`> | class<`call`>> => (class<`factor`> | class<`matrix`> | double[]) | <character[] | ^double[]> => logical | <double[] | class<`factor`> | class<`shingle`> | class<`ts`>> => logical | <character[] | class<`shingleLevel`>> => integer[];
type `getFunctionOrName` <class<`function`> | character | logical | null> => (class<`function`> | logical | null);
type `getLabelList` <null | character, any, any> => (null | list<character | double>);
type `getxx` <any, null, integer> => double[];
type `getyy` <double[], null, any> => double[];
type `grobFromLabelList` <null | list<character | double>, any, double> => (class<`gDesc`, `grob`, `text`> | null);
type `hasGroupNumber` < > => logical;
type `hist.constructor` <double[], double[], logical, logical, ...> => class<`histogram`>;
type `histogram` <class<`formula`>, class<`data.frame`>, ...> => class<`trellis`>;
type `histogram.formula` <class<`formula`>, class<`data.frame`>, logical, logical, logical, character | double, class<`function`> | character, null, list<any>, logical, null, character> => class<`trellis`>;
type `is.characterOrExpression` <character> => logical;
type `is.shingle` <double[] | class<`factor`> | class<`shingle`> | class<`ts`>> => logical;
type `larrows` <double, double, double, double, null, null, double, double, double, character, character, character> => class<`gDesc`, `grob`, `segments`>;
type `lastPanel` < > => logical;
type `lattice.getOption` <character> => (character | class<`function`> | double | null | list<any>);
type `lattice.getStatus` <character, null | character> => (character | class<`matrix`> | class<`trellis`> | double[]);
type `lattice.options` <...> => list<any>;
type `latticeParseFormula` <class<`formula`>, class<`data.frame`> | null | environment, double, logical, null | class<`factor`> | integer[], logical, any, logical, list<logical>> => list<any>;
type `lattice.setStatus` <..., character | null, logical> => null;
type `layoutNCol` <class<`layout`>> => integer;
type `layoutNRow` <class<`layout`>> => integer;
type `level.colors` <double[], double[], character[] | class<`function`>, logical, ...> => character[];
type `levelplot` <class<`formula`> | class<`matrix`>, any, ...> => class<`trellis`>;
type `levelplot.formula` <class<`formula`>, class<`data.frame`> | null, logical, logical, character, character | class<`function`>, null, list<any>, logical, null, any, any> => class<`trellis`>;
type `levelplot.matrix` <class<`matrix`>, null, character, ..., any, any, integer[], integer[]> => class<`trellis`>;
type `limits.and.aspect` <character, null | class<`function`>, logical, any, logical, any, character, character, list<any>, list<list<class<`factor`> | double[] | double[] | class<`factor`> | double[]>>, character | double, any> => list<any>;
type `limitsFromLimitlist` <logical, any, character, list<character[] | ^double[]>, any, any, character, any> => list<any>;
type `llines` <double[], ...> => null;
type `llines.default` <double[], double[], character, character, double, double, double, ..., character, character> => null;
type `lower.saturation` <character[], double> => character[];
type `lplot.xy` <list<double[] | null | double | null>, character, double[], double, character[], double[], double, double, null, null, any, any> => null;
type `lpoints` <double[], ...> => null;
type `lpoints.default` <double[], double[], character, character[], double[], double, character, double, null, null, double[], ...> => null;
type `lpretty` <double[], ...> => double[];
type `lrep` <class<`factor`> | class<`matrix`> | class<`shingle`> | double[], double> => (class<`factor`> | class<`matrix`> | class<`shingle`> | double[]);
type `lsegments` <double[], double[], double[], double[], null, null, character, double, double, double, any, any> => class<`gDesc`, `grob`, `segments`>;
type `ltransform3dMatrix` <list<double>, class<`matrix`>> => class<`matrix`>;
type `ltransform3dto3d` <class<`matrix`>, class<`matrix`>, double> => class<`matrix`>;
type `make.groups` <...> => class<`data.frame`>;
type `make.list.from.intervals` <class<`matrix`>> => list<double[]>;
type `needAutoKey` <logical | list<double | character>, class<`factor`> | null> => logical;
type `packet.number` <character> => double;
type `packet.panel` <double[], list<integer[]>, double, integer, integer, logical, logical> => double[];
type `packet.panel.default` <double[], list<integer[]>, double, integer, integer, logical, logical> => double[];
type `panel.abline` <class<`lm`>, double, null, null, null, null, any, any, any, any, any, any> => null;
type `panel.axis` <character, double[], character[] | logical, logical, logical, logical, logical, logical, any, double, double, character> => null;
type `panel.lines` <...> => null;
type `panel.lmline` <double[], double[], ..., character> => null;
type `panel.number` <character> => double;
type `panel.points` <...> => null;
type `parseCond` <class<`call`> | class<`name`>> => list<class<`call`> | class<`name`> | class<`call`> | class<`name`>>;
type `parseSide` <class<`call`> | class<`name`> | class<`(`>> => list<class<`call`> | class<`name`> | class<`(`>>;
type `paste.and.draw` <any, any, character, logical, logical, logical, logical, class<`gpar`>> => (class<`gDesc`, `grob`, `text`> | null);
type `plot.trellis` <class<`trellis`>, null | double[], null | double[], logical, logical, class<`function`>, null, list<double | character | null>, list<double | character | null>, logical, character, null> => null;
type `prepanel.loess` <double[], double[], double, double, character[], double, logical, ...> => list<double[]>;
type `prepanel.null` < > => list<^double[] | null>;
type `primName` <character, character, character, double> => character;
type `printFunction` <class<`trellis`>, null | double[], null | double[], logical, logical, class<`function`>, null, list<double | character | null>, list<double | character | null>, logical, character, null> => null;
type `print.trellis` <class<`trellis`>, ...> => class<`trellis`>;
type `qqmath` <class<`formula`>, any, ...> => class<`trellis`>;
type `qqmath.formula` <class<`formula`>, class<`data.frame`> | null, logical, logical, class<`function`>, null, logical, character, character | class<`function`>, null, list<any>, logical> => class<`trellis`>;
type `rearrangeUnit` <class<`unit`> | class<`unit`, `unit.list`>, double, class<`unit`, `unit.arithmetic`>> => class<`unit`, `unit.list`>;
type `Rows` <list<double[] | character[]>, integer[]> => list<double[] | character[]>;
type `scale.limits` <double[]> => double[];
type `shingle` <double[], double[]> => class<`shingle`>;
type `[.shingle` <class<`shingle`>, logical, logical> => class<`shingle`>;
type `sign.dist.from.line` <double[], double[]> => integer[];
type `simpleKey` <character[], logical, logical, logical, character, double, double, double, null, null, any, ...> => list<any>;
type `splom` <class<`formula`> | class<`data.frame`>, any, ...> => class<`trellis`>;
type `splom.data.frame` <class<`data.frame`>, null, ..., null, logical> => class<`trellis`>;
type `splom.formula` <class<`formula`>, environment | null, logical, double, list<double>, class<`function`>, null, list<any>, logical, null, character, any> => class<`trellis`>;
type `strip` <integer, double[], character[], character[], class<`matrix`> | null, logical[], logical[], character, double, logical, character, any> => class<`path`, `vpPath`>;
type `strip.custom` <...> => class<`function`>;
type `stripname` <character, character, integer, integer, integer, double[]> => character;
type `[.trellis` <class<`trellis`>, any, any, ..., logical> => class<`trellis`>;
type `trellis.currentLayout` <character, character> => class<`matrix`>;
type `trellis.device` <class<`function`>, logical, null, logical, logical, ...> => null;
type `trellis.focus` <character, double, double, null, logical, any, ..., any, logical, any> => any;
type `trellis.grobname` <character, character, double, any, any, any, any, character> => character;
type `trellis.last.object` <..., character> => class<`trellis`>;
type `trellis.panelArgs` <any, any> => list<any>;
type `trellis.par.get` <character | null> => list<any>;
type `trellis.par.set` <any, any, ..., any, logical, integer> => null;
type `trellis.skeleton` <class<`formula`>, list<class<`shingle`> | class<`factor`> | class<`factor`> | class<`shingle`>>, character | double, logical, list<double[]>, null | list<any>, null, null, null | character, null | character, null, double[] | null> => list<list<any>>;
type `trellis.unfocus` < > => null;
type `trellis.vpname` <character, any, any, character[] | null, logical, character> => character;
type `updateList` <list<any>, list<any>> => list<any>;
type `update.trellis` <class<`trellis`>, any, any, any, any, any, any, any, any, any, any, any> => class<`trellis`>;
type `which.packet` <character> => double[];
type `wireframe` <class<`formula`> | class<`matrix`>, any, ...> => class<`trellis`>;
type `wireframe.formula` <class<`formula`>, class<`data.frame`> | null, character, character, ...> => class<`trellis`>;
type `wireframe.matrix` <class<`matrix`>, null, character, double[], ..., any, any, integer[], integer[]> => class<`trellis`>;
type `xscale.components.default` <double[], double, null, logical, ...> => list<double[] | list<list<double[] | double[] | character[]>> | double[] | list<list<integer[] | double | integer[] | character[]>>>;
type `xyplot` <class<`formula`>, any, ...> => class<`trellis`>;
type `xyplot.formula` <class<`formula`>, class<`data.frame`> | null, logical, logical, logical, character | double, character | class<`function`>, null | class<`function`>, list<any>, logical | class<`function`>, null, any> => class<`trellis`>;
