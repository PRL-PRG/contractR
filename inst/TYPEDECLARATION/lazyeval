type `%||%` <character[] | null, any> => character[];
type `all_values` <any, ...> => list<any>;
type `as_call` <character | class<`formula`> | class<`name`>> => class<`call`>;
type `as_call.character` <character> => class<`call`>;
type `as_call.formula` <class<`formula`>> => class<`call`>;
type `as_call.name` <class<`name`>> => class<`call`>;
type `as.lazy` <character | class<`call`> | class<`formula`> | class<`lazy`> | class<`name`> | double, any> => class<`lazy`>;
type `as.lazy.call` <class<`call`> | class<`name`>, environment> => class<`lazy`>;
type `as.lazy.character` <character, environment> => class<`lazy`>;
type `as.lazy_dots` <character[] | class<`call`> | class<`formula`> | class<`lazy`> | class<`lazy_dots`> | class<`name`> | list<class<`formula`> | class<`formula`> | class<`name`> | double | class<`formula`>>, any> => class<`lazy_dots`>;
type `as.lazy_dots.call` <class<`call`> | class<`formula`> | class<`name`>, any> => class<`lazy_dots`>;
type `as.lazy_dots.character` <character[] | list<class<`formula`> | class<`formula`> | class<`name`> | double | class<`formula`>>, any> => class<`lazy_dots`>;
type `as.lazy_dots.formula` <class<`call`> | class<`formula`> | class<`name`>, any> => class<`lazy_dots`>;
type `as.lazy_dots.lazy` <class<`lazy`>, any> => class<`lazy_dots`>;
type `as.lazy_dots.lazy_dots` <class<`lazy_dots`>, any> => class<`lazy_dots`>;
type `as.lazy_dots.list` <character[] | list<class<`formula`> | class<`formula`> | class<`name`> | double | class<`formula`>>, any> => class<`lazy_dots`>;
type `as.lazy_dots.name` <class<`call`> | class<`formula`> | class<`name`>, any> => class<`lazy_dots`>;
type `as.lazy.formula` <class<`formula`>, any> => class<`lazy`>;
type `as.lazy.lazy` <class<`lazy`>, any> => class<`lazy`>;
type `as.lazy.name` <class<`call`> | class<`name`>, environment> => class<`lazy`>;
type `as.lazy.numeric` <double, environment> => class<`lazy`>;
type `as_name` <character | class<`call`> | class<`formula`>> => class<`name`>;
type `as_name.call` <class<`call`>> => class<`name`>;
type `as_name.character` <character> => class<`name`>;
type `as_name.formula` <class<`formula`>> => class<`name`>;
type `ast` <any> => null;
type `ast_` <class<`call`> | class<`if`> | expression, integer> => null;
type `auto_name` <class<`lazy_dots`> | list<class<`formula`> | class<`name`>>, double> => (class<`lazy_dots`> | list<class<`formula`> | class<`name`>>);
type `auto_names` <class<`lazy_dots`> | list<class<`formula`> | class<`name`>>, any> => character[];
type `call_modify` <class<`call`>, list<class<`name`> | null | double>, environment> => class<`call`>;
type `call_new` <character | class<`call`> | class<`name`>, ..., list<any>> => class<`call`>;
type `call_standardise` <class<`call`>, environment> => class<`call`>;
type `c.lazy_dots` <..., logical> => class<`lazy_dots`>;
type `clone_env` <environment> => environment;
type `common_env` <class<`lazy_dots`> | list<class<`formula`>>> => environment;
type `complain` <class<`data.frame`> | environment | list<any>, character> => (class<`complain`, `data.frame`> | class<`complain`, `environment`> | class<`complain`, `list`>);
type `[[.complain` <class<`complain`, `data.frame`> | class<`complain`, `environment`>, character, ...> => double[];
type `$.complain` <class<`complain`, `data.frame`> | class<`complain`, `environment`>, character> => any;
type `dots_capture` <..., logical> => list<class<`formula`>>;
type `eval_expr` <class<`call`> | class<`name`>, environment, class<`data.frame`> | null | list<class<`function`> | double>> => any;
type `expr_find` <any> => (character | class<`{`> | class<`call`> | class<`if`> | class<`name`> | double);
type `expr_label` <any> => character;
type `expr_label_` <character | class<`call`> | class<`name`> | double> => character;
type `expr_text` <any, integer, double> => character;
type `expr_text_` <class<`{`> | class<`call`>, integer, double> => character;
type `f_capture` <any> => class<`formula`>;
type `f_env` <class<`formula`>> => environment;
type `f_eval` <class<`formula`>, class<`data.frame`> | null | list<class<`function`> | double>> => any;
type `find_data` <class<`data.frame`> | null | list<class<`function`> | double>> => (class<`data.frame`> | list<any>);
type `find_data.data.frame` <class<`data.frame`> | list<class<`function`> | double>> => (class<`data.frame`> | list<class<`function`> | double>);
type `find_data.list` <class<`data.frame`> | list<class<`function`> | double>> => (class<`data.frame`> | list<class<`function`> | double>);
type `find_data.NULL` <null> => list<any>;
type `f_interp` <class<`formula`>, class<`data.frame`> | null | list<class<`function`> | double>> => class<`formula`>;
type `f_label` <class<`formula`>> => character;
type `f_lhs` <class<`formula`>> => (class<`name`> | null);
type `f_list` <...> => list<class<`formula`>>;
type `f_new` <class<`call`> | class<`name`>, class<`name`> | null, environment> => class<`formula`>;
type `f_rhs` <class<`formula`>> => (character | class<`call`> | class<`name`> | double);
type `f_rhs<-` <class<`formula`>, class<`call`> | class<`name`>> => class<`formula`>;
type `f_text` <class<`formula`>, integer, double> => character;
type `FUN` <character | class<`call`> | class<`formula`> | class<`lazy`> | class<`name`> | double, any> => class<`lazy`> | <class<`lazy`> | class<`formula`> | character | class<`call`> | class<`lazy_dots`>, null | class<`data.frame`> | list<double>> => (double | logical[] | list<double>) | <class<`{`> | class<`call`> | class<`name`> | double | null | pairlist | class<`if`>, double, double, character> => character;
type `function_new` <list<class<`name`>>, class<`call`>, environment> => class<`function`>;
type `f_unwrap` <class<`formula`>> => class<`formula`>;
type `has_name` <class<`complain`, `data.frame`> | class<`complain`, `environment`>, character> => logical;
type `has_name.default` <class<`complain`, `data.frame`>, character> => logical;
type `has_name.environment` <class<`complain`, `environment`>, character> => logical;
type `has_names` <list<class<`name`> | null | double>> => logical;
type `interp` <character | class<`call`> | class<`formula`> | class<`lazy`>, ..., any> => (character | class<`call`> | class<`formula`> | class<`lazy`>);
type `interp.call` <class<`call`>, ..., any> => class<`call`>;
type `interp.character` <character, ..., any> => character;
type `interp.formula` <class<`formula`>, ..., any> => class<`formula`>;
type `interp.lazy` <class<`lazy`>, ..., any> => class<`lazy`>;
type `is_atomic` <class<`{`> | class<`call`> | class<`if`> | class<`name`> | double | null | pairlist | list<integer[] | double>> => logical;
type `is_call` <class<`{`> | class<`call`> | class<`if`> | class<`name`> | double | null | pairlist> => logical;
type `is_formula` <any> => logical;
type `is_lang` <class<`call`> | class<`name`> | double> => logical;
type `is.lazy_dots` <character | class<`call`> | class<`formula`> | class<`lazy`> | class<`lazy_dots`>> => logical;
type `is_name` <class<`{`> | class<`call`> | class<`if`> | class<`name`> | null | pairlist> => logical;
type `is_pairlist` <class<`name`> | double | null | pairlist> => logical;
type `is_vector` <list<integer[] | double>> => logical;
type `lazy` <any, any, logical> => class<`lazy`>;
type `lazy_` <class<`call`> | class<`name`> | double, environment> => class<`lazy`>;
type `[<-.lazy_dots` <class<`lazy_dots`>, character, list<class<`formula`>>> => class<`lazy_dots`>;
type `[.lazy_dots` <class<`lazy_dots`>, logical[] | character[]> => class<`lazy_dots`>;
type `$<-.lazy_dots` <class<`lazy_dots`>, character, class<`name`>> => class<`lazy_dots`>;
type `lazy_dots` <..., logical, logical> => class<`lazy_dots`>;
type `lazy_eval` <class<`lazy`> | class<`formula`> | character | class<`call`> | class<`lazy_dots`>, null | class<`data.frame`> | list<double>> => (double | logical[] | list<double>);
type `make_call` <class<`name`>, class<`formula`> | class<`lazy_dots`> | class<`name`> | list<double | class<`formula`>>> => class<`lazy`>;
type `missing_arg` < > => any;
type `str_dup` <character, double> => character;
type `str_trunc` <character, double> => character;
type `substitute_` <class<`call`>, environment | list<any>> => class<`call`>;
type `tree` <class<`{`> | class<`call`> | class<`name`> | double | null | pairlist | class<`if`>, double, double, character> => character;
type `uq` <any, null | class<`data.frame`>> => any;
type `uqs` <list<integer[] | double>> => pairlist;
