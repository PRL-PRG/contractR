type `commutation.matrix` <double, double> => class<`matrix`>;
type `creation.matrix` <double> => class<`matrix`>;
type `direct.prod` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `direct.sum` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `D.matrix` <double> => class<`matrix`>;
type `duplication.matrix` <double> => class<`matrix`>;
type `elimination.matrix` <double> => class<`matrix`>;
type `E.matrices` <double> => list<list<class<`matrix`>>>;
type `entrywise.norm` <class<`matrix`>, double> => double;
type `fibonacci.matrix` <double> => class<`matrix`>;
type `filter` <character[]> => logical[];
type `frobenius.matrix` <double> => class<`matrix`>;
type `frobenius.norm` <class<`matrix`>> => double;
type `frobenius.prod` <class<`matrix`>, class<`matrix`>> => double;
type `hadamard.prod` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `hankel.matrix` <double, integer[]> => class<`matrix`>;
type `hilbert.matrix` <double> => class<`matrix`>;
type `hilbert.schmidt.norm` <class<`matrix`>> => double;
type `H.matrices` <double, double> => list<list<class<`matrix`>>>;
type `inf.norm` <class<`matrix`>> => double;
type `is.diagonal.matrix` <class<`matrix`>, double> => logical;
type `is.idempotent.matrix` <class<`matrix`>, double> => logical;
type `is.indefinite` <class<`matrix`>, double> => logical;
type `is.negative.definite` <class<`matrix`>, double> => logical;
type `is.negative.semi.definite` <class<`matrix`>, double> => logical;
type `is.non.singular.matrix` <class<`matrix`>, double> => logical;
type `is.positive.definite` <class<`matrix`>, double> => logical;
type `is.positive.semi.definite` <class<`matrix`>, double> => logical;
type `is.singular.matrix` <class<`matrix`>, double> => logical;
type `is.skew.symmetric.matrix` <class<`matrix`>, double> => logical;
type `is.square.matrix` <class<`matrix`>> => logical;
type `is.symmetric.matrix` <class<`matrix`>> => logical;
type `K.matrix` <double, double> => class<`matrix`>;
type `L.matrix` <double> => class<`matrix`>;
type `lower.triangle` <class<`matrix`>> => class<`matrix`>;
type `lu.decomposition` <class<`matrix`>> => list<class<`matrix`>>;
type `matrix.inverse` <class<`matrix`>> => class<`matrix`>;
type `matrix.power` <class<`matrix`>, double> => class<`matrix`>;
type `matrix.rank` <class<`matrix`>, character[]> => integer;
type `matrix.trace` <class<`matrix`>> => double;
type `maximum.norm` <class<`matrix`>> => double;
type `N.matrix` <double> => class<`matrix`>;
type `n.over.r` <integer, integer> => double;
type `one.norm` <class<`matrix`>> => double;
type `pascal.matrix` <double> => class<`matrix`>;
type `%s%` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `set.submatrix` <class<`matrix`>, class<`matrix`>, double, double> => class<`matrix`>;
type `shift.down` <class<`matrix`>, double, double> => class<`matrix`>;
type `shift.left` <class<`matrix`>, double, double> => class<`matrix`>;
type `shift.right` <class<`matrix`>, double, double> => class<`matrix`>;
type `shift.up` <class<`matrix`>, double, double> => class<`matrix`>;
type `spectral.norm` <class<`matrix`>> => double;
type `stirling.matrix` <double> => class<`matrix`>;
type `svd.inverse` <class<`matrix`>> => class<`matrix`>;
type `symmetric.pascal.matrix` <double> => class<`matrix`>;
type `T.matrices` <double> => list<list<class<`matrix`>>>;
type `toeplitz.matrix` <double, integer[]> => class<`matrix`>;
type `upper.triangle` <class<`matrix`>> => class<`matrix`>;
type `u.vectors` <double> => list<class<`matrix`>>;
type `vandermonde.matrix` <double[], double> => class<`matrix`>;
type `vec` <class<`matrix`>> => class<`matrix`>;
type `vech` <class<`matrix`>> => class<`matrix`>;
