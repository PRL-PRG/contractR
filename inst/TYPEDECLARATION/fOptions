type `.BAWAmPutApproxOption` <double, double, double, double, double, double> => double;
type `.bawKp` <double, double, double, double, double> => double;
type `.BSAmericanCallApprox` <double, double, double, double, double, double> => struct<`Premium`:double, `TriggerPrice`:double>;
type `.bsPhi` <double, double, double, double, double, double, double, double> => double;
type `.fHN` <double[], double, struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double>, double, double, double, double> => complex[];
type `.GBSDelta` <character, double, double, double, double, double, double> => double;
type `.GBSGamma` <symbol, double, double, double, double, double, double> => double;
type `.GBSLambda` <character, double, double, double, double, double, double> => double;
type `.GBSRho` <character, double, double, double, double, double, double> => double;
type `.GBSTheta` <character, double, double, double, double, double, double> => double;
type `.GBSVega` <symbol, double, double, double, double, double, double> => double;
type `.getfOptionsEnv` <character, character> => struct<`base`:double[], `offset`:double> | struct<`quasi`:double[], `ll`:double, `count`:double, `sv`:double[], `seed`:double>;
type `.llhHNGarch` <double[], logical, logical, double, double[]> => double;
type `.setfOptionsEnv` <tuple<> | struct<`base`:double[], `offset`:double> | struct<`quasi`:double[], `ll`:double, `count`:double, `sv`:double[], `seed`:double>> => null;
type `BAWAmericanApproxOption` <double, double, double, double, double, double, null, null> => character;
type `BinomialTreeOption` <character, double, double, double, double, double, double, double, null, null> => ^double[];
type `BinomialTreePlot` <^double[], double, double, double, double, double[]> => null;
type `Black76Option` <double, double, double, double, double, null, null> => character;
type `BSAmericanApproxOption` <double, double, double, double, double, double, null, null> => character;
type `CND` <double> => double;
type `CRRBinomialTreeOption` <double, double, double, double, double, double, double, null, null> => character;
type `f` <double[], double, struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double> | logical, double, double[], double, double> => double[];
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null;
type `FUN` <character> => tuple<> | struct<`base`:double[], `offset`:double> | struct<`quasi`:double[], `ll`:double, `count`:double, `sv`:double[], `seed`:double>;
type `GBSCharacteristics` <character, double, double, double, double, double, double> => struct<`premium`:double, `delta`:double, `theta`:double, `vega`:double, `rho`:double, `lambda`:double, `gamma`:double>;
type `GBSGreeks` <character, character, double, double, double, double, double, double> => double;
type `GBSOption` <double, double, double, double, double, double, null, null> => character;
type `hngarchFit` <double[], struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double, `rf`:double>, logical, logical, null, null, null> => struct<`minimum`:double, `estimate`:double[], `gradient`:double[], `code`:integer, `iterations`:integer, `params`:double[], `symmetric`:logical, `h`:double[], `z`:double[], `model`:struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double, `rf`:double>, `x`:double[], `persistence`:double, `sigma2`:double, `call`:language, `title`:character, `description`:character>;
type `hngarchSim` <struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double, `rf`:double>, double, null, double, null, any => any, null> => double[];
type `hngarchStats` <struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double, `rf`:double>> => struct<`mean`:double, `variance`:double, `skewness`:double, `kurtosis`:double, `persistence`:double, `leverage`:double, `meansigma2`:double, `meansigma4`:double, `meansigma6`:double, `meansigma8`:double>;
type `HNGGreeks` <character, character, struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double>, double, double, double, double> => double;
type `HNGOption` <character, struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double>, double, double, double, double> => struct<`price`:double, `call`:language>;
type `JRBinomialTreeOption` <double, double, double, double, double, double, integer, null, null> => character;
type `MiltersenSchwartzOption` <double, double, double, double, double, double, double, double, double, double, double, double, double, null, null> => character;
type `MonteCarloOption` <double, double, double, double, logical, any => any, any => any, any => any, logical, logical, logical, double> => double[];
type `NDF` <double> => double;
type `rnorm.halton` <double, double, logical> => ^double[];
type `rnorm.pseudo` <double, double, logical> => ^double[];
type `rnorm.sobol` <double, double, logical, double, double> => ^double[];
type `RollGeskeWhaleyOption` <double, double, double, double, double, double, null, null> => double;
type `runif.halton` <double, double, logical> => ^double[];
type `runif.pseudo` <double, double, null> => ^double[];
type `runif.sobol` <double, double, logical, double, double> => ^double[];
type `summary.hngarch` <struct<`minimum`:double, `estimate`:double[], `gradient`:double[], `code`:integer, `iterations`:integer, `params`:double[], `symmetric`:logical, `h`:double[], `z`:double[], `model`:struct<`lambda`:double, `omega`:double, `alpha`:double, `beta`:double, `gamma`:double, `rf`:double>, `x`:double[], `persistence`:double, `sigma2`:double, `call`:language, `title`:character, `description`:character>, null> => null;
type `TIANBinomialTreeOption` <double, double, double, double, double, double, integer, null, null> => character;
