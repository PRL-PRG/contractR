type `backsolvet` <class<`matrix`>, double[], integer> => double[];
type `betabreaker` <class<`lars`>> => class<`matrix`>;
type `coef.lars` <class<`lars`>, ...> => double[];
type `cv.folds` <integer, double> => list<integer[]>;
type `cv.lars` <class<`AsIs`>, double[], double, any, logical, logical, logical, character[]> => list<double[] | character>;
type `delcol` <class<`matrix`>, double[], integer> => list<class<`matrix`>>;
type `downdateR` <class<`matrix`>, integer> => class<`matrix`>;
type `error.bars` <double[], double[], double[], double, ...> => double[];
type `lars` <class<`AsIs`>, double[], character[], logical, logical, logical, any, double> => class<`lars`>;
type `nnls.lars` <integer[], double[], class<`matrix`>, double[], class<`matrix`>, any, logical, logical> => list<class<`matrix`> | double[]>;
type `plotCVLars` <list<double[] | character>, logical> => null;
type `plot.lars` <class<`lars`>, character[], logical, character[], logical, double, ...> => null;
type `predict.lars` <class<`lars`>, any, any, character[], character[], ...> => (list<double[] | character | class<`matrix`>> | list<character | double[]>);
type `summary.lars` <class<`lars`>, null, ...> => class<`anova`, `data.frame`>;
type `updateR` <double, class<`matrix`> | null, any, any, logical> => class<`matrix`>;
