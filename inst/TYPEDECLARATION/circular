type `A1inv` <double> => double;
type `angular.deviation` <double[], logical> => double;
type `angular.variance` <double[], logical> => double;
type `arrows.circular` <double[], ? double[], double[], double[], logical, double, null, null, null, double | ???> => null;
type `as.circular` <^double[], tuple<> | struct<`units`:character, `zero`:double>, ???> => ^double[];
type `axis.circular` <? double[], ? expression, ? character | symbol, ? character, ? character, ? double, ? character, logical, ???, ???, ??? | double, ???, ???, double, double, double> => null;
type `AxisCircularRad` <double[], symbol, character[] | expression, symbol, logical, double, double, double, character, character | symbol, double | symbol> => null;
type `CirclePlotRad` <double[], double[], null, double, double, ? character | expression, null, character | expression, character, struct<`n`:double, `type`:character, `col`:double, `bg`:character, `pch`:double, `cex`:double, `lty`:double, `lwd`:double>> => null;
type `circles` <double, double[], double, character, null, logical> => null;
type `circular.colors` <double, double, double, double, ???> => character[];
type `circularp` <^double[]> => ? struct<`type`:character, `units`:character, `template`:character, `modulo`:character, `zero`:double, `rotation`:character>;
type `curve.circular` <symbol, ? double, ? double, double, logical, double, logical, logical, double, double, double, double, null, language | double[], language | double[], double, character[], ? character, null> => struct<`x`:double[], `y`:double[], `zero`:double, `rotation`:character, `next.points`:double>;
type `dasytriangular` <double[], double> => double[];
type `density.circular` <double[], ? double[], double, double, symbol | language, character[], symbol | logical, ? double, double | list<double>, double[], null, double, tuple<>, ???> => struct<`data`:double[], `x`:double[], `y`:double[], `bw`:double, `n`:integer, `kernel`:character, `call`:language, `data.name`:character, `has.na`:logical>;
type `dgenvonmises` <double[], double, double, double, double> => double[];
type `djonespewsey` <double[], double, double, double> => double[];
type `dkatojones` <double[], double, double, double, double> => double[];
type `dpnorm` <double[], double[], ^double[], logical> => double[];
type `dtriangular` <double[], double> => double[];
type `dvonmises` <double[], double, double, logical> => double[];
type `dwrappedcauchy` <double[], double, double> => double[];
type `f` <double[], double> => double[];
type `filter` <character[]> => logical[];
type `fn` <double[], double[], double[]> => double;
type `fun` <symbol, symbol | character> => ? character;
type `FUN` <double[], ? double[], logical, ???, ???> => ^double[];
type `int` <double[], double> => double[];
type `is.circular` <? ^double[]> => logical;
type `ker` <double[]> => double[];
type `lines.edf` <double[], character, double> => null;
type `LinesCircularRad` <double[], double[], logical, logical, double, double, character | double | ???> => struct<`x`:double[], `y`:double[]>;
type `lm.circular` <double[], character[]> => struct<`rho`:^double[], `fitted`:double[], `x`:^double[], `residuals`:double[], `coefficients`:^double[], `p.values`:^double[], `A.k`:double, `kappa`:double, `call`:language, `message`:character> | struct<`x`:^double[], `y`:double[], `mu`:double, `se.mu`:double, `kappa`:double, `se.kappa`:double, `coefficients`:double[], `cov.coef`:^double[], `se.coef`:double[], `log.lik`:double, `t.values`:double[], `p.values`:double[], `call`:language>;
type `meandeviation` <double[], logical> => double;
type `plot.edf` <double[], character, double[], double[], character> => null;
type `plot.function.circular` <any => any, double, double, double[]> => struct<`x`:double[], `y`:double[], `zero`:double, `rotation`:character, `next.points`:double>;
type `plot.lsfit.circle` <struct<`coefficients`:double[], `x`:double[], `y`:double[], `x.centered`:double[], `y.centered`:double[], `angles`:double[], `radius`:double[], `convergence`:integer, `optim`:struct<`par`:double[], `value`:double, `counts`:integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `call`:language>, logical, null, null, null, null, null, ???, double, double, ???> => struct<`coefficients`:double[], `x`:double[], `y`:double[], `x.centered`:double[], `y.centered`:double[], `angles`:double[], `radius`:double[], `convergence`:integer, `optim`:struct<`par`:double[], `value`:double, `counts`:integer[], `convergence`:integer, `message`:null, `hessian`:^double[]>, `call`:language>;
type `PointsCircularRad` <double[], double | symbol, logical, double, double, double, double | symbol, double, double, double | symbol, symbol | double, double, ??? | character> => null;
type `pp.plot` <double[], logical, double, character, character, tuple<>, ???> => struct<`mu`:double, `kappa`:double>;
type `pp.unif.plot` <double[], logical, ? double, character, character, null, null, null, ???> => null;
type `print.circular` <double[], logical, ???> => double[];
type `print.rao.spacing.test` <struct<`call`:language, `statistic`:double, `alpha`:double, `n`:integer>, double, ???> => struct<`call`:language, `statistic`:double, `alpha`:double, `n`:integer, `accepted`:logical>;
type `pvonmises` <double[], double, double, null, double> => double[];
type `rho.circular` <double[], logical> => double;
type `RosediagRad` <double[], double, character, double, logical, character, double, integer, ? double, ???> => null;
type `summary.circular` <double[], double, ??? | symbol> => double[];
type `ticks.circular` <double[], character[], null, null, double, null, ???> => null;
type `TicksCircularRad` <double[], double, character, ???> => null;
type `var.circular` <double[], logical, ???> => double;
type `var.default` <double[], double[], logical, ???, ???> => double;
type `windrose` <struct<`dir`:double[], `mag`:double[]> | double[], ? double[], ? double[], double, double, character, double, null, logical, double, double, logical, logical, double, double, double, double, null, null> => struct<`x`:double[], `y`:double[], `table`:^double[], `number.obs`:integer, `number.calm`:integer, `breaks`:double[], `mids`:double[], `shrink`:double, `call`:language>;
type `wt` <double[], double, ^double[]> => double[];
