type `$` <list<class<`Option`>>, list<class<`Option`>>> => list<logical | list<any>> | <character | null, character | null, double, logical | character> => integer | < > => class<`Required`> | <list<class<`Option`>>, list<any>> => list<logical | list<any> | logical | list<class<`Option`>>> | <character, null> => null | < > => character | <list<class<`Option`>>> => list<class<`Option`>> | <list<any>> => list<any> | <list<class<`Option`>>, list<any>> => list<logical | list<any>> | <list<any>, list<any>> => list<logical | list<any> | logical | list<class<`Option`>>> | <list<any>, list<class<`Option`>>> => list<logical | list<any>> | < > => character | <null | list<class<`Option`> | class<`Argument`>>> => list<class<`Option`> | class<`Argument`>> | <list<any>, list<class<`Option`>>> => list<logical | list<any>> | < > => character | < > => character | < > => character | <...> => list<class<`Argument`> | class<`Option`> | class<`Argument`> | class<`Option`>> | <character, class<`function`>, logical> => class<`function`> | < > => character;
type `Argument` <...> => class<`Argument`>;
type `as.character` <any, ...> => character | <any, ...> => character;
type `check` <character | null, character> => logical;
type `docopt` <character, character, null, logical, null, logical, logical, any> => class<`docopt`, `list`>;
type `either` < > => class<`Either`>;
type `Either` <...> => class<`Either`>;
type `extract` <character, character> => list<character[]>;
type `extras` <logical, null, list<class<`Option`>>, any> => null;
type `filter` <character[]> => logical[];
type `fix_identities` <null | list<class<`Option`> | class<`Argument`>>> => list<class<`Option`> | class<`Argument`>>;
type `fix_repeating_arguments` < > => class<`Required`>;
type `flat` <...> => list<class<`Argument`> | class<`Option`> | class<`Argument`> | class<`Option`>>;
type `formal_usage` <character> => character;
type `FUN` <any, ...> => character | <any, ...> => character | <class<`Option`>> => logical | <list<logical | list<any> | logical | list<class<`Option`>>>> => logical | <class<`Option`>> => logical | <class<`Option`>> => list<logical | list<any> | logical | list<class<`Option`>>> | <integer> => character[] | <list<logical | list<any>>> => integer | <integer> => character | <class<`Required`>> => list<class<`Argument`> | class<`Option`>> | <integer> => list<character[]> | <list<class<`Argument`> | class<`Option`>>> => class<`Required`> | <character> => class<`Option`> | <class<`Argument`> | class<`OneOrMore`> | class<`Optional`> | class<`Either`> | class<`Option`>> => list<class<`Argument`> | class<`Option`>> | <class<`Option`>> => character | <class<`Option`>> => logical;
type `matched` <logical, list<any>, list<any>> => list<logical | list<any> | logical | list<class<`Option`>>>;
type `name` < > => character;
type `OneOrMore` <...> => class<`OneOrMore`>;
type `Option` <...> => class<`Option`>;
type `Optional` <...> => class<`Optional`>;
type `OptionList` <...> => class<`OptionList`>;
type `parse_args` <character, class<`OptionList`>> => list<class<`Option`>>;
type `parse_atom` <class<`Tokens`>, any> => list<class<`Argument`> | class<`Optional`> | class<`Option`>>;
type `parse_doc_options` <character> => class<`OptionList`>;
type `parse_expr` <class<`Tokens`>, any> => list<any>;
type `parse_long` <class<`Tokens`>, class<`OptionList`>> => list<class<`Option`>>;
type `parse_option` <character> => class<`Option`>;
type `parse_pattern` <character, class<`OptionList`>> => class<`Required`>;
type `parse_seq` <class<`Tokens`>, any> => list<class<`OneOrMore`> | class<`Optional`> | class<`Option`>>;
type `parse_shorts` <class<`Tokens`>, class<`OptionList`>> => list<class<`Option`>>;
type `printable_usage` <character, any> => character;
type `Required` <...> => class<`Required`>;
type `single_match` <list<class<`Option`>>> => integer;
type `str_c` <character[], ...> => character;
type `str_extract` <character[], character> => character[];
type `str_extract_all` <character, character> => list<list<character[]>>;
type `str_match` <character, character> => class<`matrix`>;
type `str_replace` <character, character, character> => character;
type `str_split` <character, character> => list<character[]>;
type `str_sub` <null | character, double, integer> => character[];
type `str_trim` <character> => character;
type `Tokens` <...> => class<`Tokens`>;
