type `$` <null | character | tuple<> | list<null> | struct<`Option(-h#--help#0#FALSE)`:null, `Option(-s#--sorted#0#FALSE)`:null, `Option(-o##1#./test.txt)`:null, `Option(#--quiet#0#TRUE)`:null, `Option(#--verbose#0#TRUE)`:null, `Argument(INPUT#)`:null> | null, null | character | tuple<> | any => any, double, logical | character> => null | integer | struct<`matched`:logical, `left`:tuple<>, `collected`:tuple<>> | character | tuple<> | list<null> | struct<`Option(-h#--help#0#FALSE)`:null, `Option(-s#--sorted#0#FALSE)`:null, `Option(-o##1#./test.txt)`:null, `Option(#--quiet#0#TRUE)`:null, `Option(#--verbose#0#TRUE)`:null, `Argument(INPUT#)`:null> | any => any;
type `Argument` < > => character;
type `as.character` <null, null> => character;
type `check` <null | character, character> => logical;
type `either` <null, null> => null;
type `Either` < > => tuple<null, null>;
type `extract` <character, character> => tuple<character[]>;
type `extras` <logical, null, tuple<null, null>, symbol> => null;
type `filter` <character[]> => logical[];
type `fix_identities` <null> => struct<`Option(-h#--help#0#FALSE)`:null, `Option(-s#--sorted#0#FALSE)`:null, `Option(-o##1#./test.txt)`:null, `Option(#--quiet#0#TRUE)`:null, `Option(#--verbose#0#TRUE)`:null, `Argument(INPUT#)`:null>;
type `fix_repeating_arguments` <null, null> => null;
type `flat` <null> => list<null>;
type `formal_usage` <character> => character;
type `FUN` <struct<`matched`:logical, `left`:tuple<>, `collected`:tuple<>> | null | integer | list<null> | character, null> => struct<`matched`:logical, `left`:tuple<>, `collected`:tuple<>> | character[] | integer | list<null> | tuple<character[]> | tuple<>;
type `matched` <logical, tuple<>, tuple<>> => struct<`matched`:logical, `left`:tuple<>, `collected`:tuple<>>;
type `name` < > => character;
type `OneOrMore` < > => tuple<>;
type `Option` < > => null | character;
type `Optional` < > => tuple<>;
type `OptionList` < > => tuple<null, null, null, null, null>;
type `parse_atom` <symbol> => tuple<>;
type `parse_doc_options` < > => character;
type `parse_expr` < > => tuple<>;
type `parse_long` < > => tuple<>;
type `parse_option` < > => character;
type `parse_pattern` < > => character;
type `parse_seq` <symbol> => tuple<>;
type `parse_shorts` < > => tuple<>;
type `printable_usage` <character, symbol> => character;
type `Required` < > => tuple<null, null, null> | list<null>;
type `single_match` <tuple<>> => integer;
type `str_c` <character[], character> => character;
type `str_extract` <character[], character> => character[];
type `str_extract_all` <character, character> => tuple<tuple<character[]>>;
type `str_match` <character, character> => ^character[];
type `str_replace` <character, character, character> => character;
type `str_split` <character, character> => tuple<character[]>;
type `str_sub` <null | character, double, integer> => character[];
type `str_trim` <character> => character;
type `Tokens` < > => character;
