type `Argument` <...> => class<`Argument`>;
type `docopt` <character, character, null, logical, null, logical, logical, any> => class<`docopt`, `list`>;
type `Either` <...> => class<`Either`>;
type `extract` <character, character> => list<character[]>;
type `extras` <logical, null, list<class<`Option`>>, any> => null;
type `formal_usage` <character> => character;
type `matched` <logical, list<any>, list<any>> => list<logical | list<any> | logical | list<class<`Option`>>>;
type `OneOrMore` <...> => class<`OneOrMore`>;
type `Option` <...> => class<`Option`>;
type `Optional` <...> => class<`Optional`>;
type `OptionList` <...> => class<`OptionList`>;
type `parse_args` <character, class<`OptionList`>> => list<class<`Option`>>;
type `parse_atom` <class<`Tokens`>, any> => list<class<`Argument`> | class<`Optional`> | class<`Option`>>;
type `parse_doc_options` <character> => class<`OptionList`>;
type `parse_expr` <class<`Tokens`>, any> => list<any>;
type `parse_long` <class<`Tokens`>, class<`OptionList`>> => list<class<`Option`>>;
type `parse_option` <character> => class<`Option`>;
type `parse_pattern` <character, class<`OptionList`>> => class<`Required`>;
type `parse_seq` <class<`Tokens`>, any> => list<class<`OneOrMore`> | class<`Optional`> | class<`Option`>>;
type `parse_shorts` <class<`Tokens`>, class<`OptionList`>> => list<class<`Option`>>;
type `printable_usage` <character, any> => character;
type `Required` <...> => class<`Required`>;
type `str_c` <character[], ...> => character;
type `str_extract` <character[], character> => character[];
type `str_extract_all` <character, character> => list<list<character[]>>;
type `str_match` <character, character> => class<`matrix`>;
type `str_replace` <character, character, character> => character;
type `str_split` <character, character> => list<character[]>;
type `str_sub` <null | character, double, integer> => character[];
type `str_trim` <character> => character;
type `Tokens` <...> => class<`Tokens`>;
