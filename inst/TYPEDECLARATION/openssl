type `:::` <raw[], raw[], character> => raw[] | character;
type `*.bignum` <raw[], raw[]> => raw[];
type `%/%.bignum` <raw[], raw[]> => raw[];
type `%%.bignum` <raw[], raw[]> => raw[];
type `^.bignum` <raw[], raw[]> => raw[];
type `+.bignum` <raw[], raw[]> => raw[];
type `<.bignum` <raw[], raw[]> => logical;
type `==.bignum` <raw[], raw[]> => logical;
type `$.key` <raw[], character> => raw[] | struct<`e`:raw[], `n`:raw[], `p`:raw[], `q`:raw[], `d`:raw[], `dp`:raw[], `dq`:raw[], `qi`:raw[]>;
type `$.pubkey` <raw[], character> => struct<`e`:raw[], `n`:raw[]>;
type `aes_any` <raw[], raw[], raw[], logical, character> => raw[];
type `aes_cbc_decrypt` <raw[], raw[], raw[]> => raw[];
type `aes_cbc_encrypt` <character | raw[], raw[], raw[]> => raw[];
type `aes_decrypt` <raw[], raw[], raw[], character> => raw[];
type `aes_encrypt` <character | raw[], raw[], raw[], character> => raw[];
type `as.character.bignum` <raw[], logical, null> => character;
type `as.character.hash` <raw[], character, null> => character;
type `as.list.cert` <raw[], null, null> => struct<`subject`:character, `issuer`:character, `algorithm`:character, `signature`:raw[], `validity`:character[], `self_signed`:logical, `alt_names`:character[], `pubkey`:raw[]>;
type `as.list.key` <raw[], null> => struct<`type`:character, `size`:integer, `pubkey`:raw[], `data`:raw[]> | struct<`type`:character, `size`:integer, `pubkey`:raw[], `data`:struct<`curve`:character, `x`:raw[], `y`:raw[], `secret`:raw[]>> | struct<`type`:character, `size`:integer, `pubkey`:raw[], `data`:struct<`e`:raw[], `n`:raw[], `p`:raw[], `q`:raw[], `d`:raw[], `dp`:raw[], `dq`:raw[], `qi`:raw[]>>;
type `as.list.pubkey` <raw[], null> => struct<`type`:character, `size`:integer, `ssh`:character, `fingerprint`:raw[], `data`:raw[]> | struct<`type`:character, `size`:integer, `ssh`:character, `fingerprint`:raw[], `data`:struct<`curve`:character, `x`:raw[], `y`:raw[]>> | struct<`type`:character, `size`:integer, `ssh`:character, `fingerprint`:raw[], `data`:struct<`e`:raw[], `n`:raw[]>>;
type `base64_decode` <character> => raw[];
type `base64_encode` <raw[], logical> => character;
type `bignum` <character | raw[] | integer, logical> => raw[];
type `bignum_mod` <raw[], raw[]> => raw[];
type `bignum_mod_exp` <raw[], raw[], raw[]> => raw[];
type `ca_bundle` < > => list<raw[]>;
type `cert_info` <raw[], null> => struct<`subject`:character, `issuer`:character, `algorithm`:character, `signature`:raw[], `validity`:character[], `self_signed`:logical, `alt_names`:character[]> | struct<`subject`:character, `issuer`:character, `algorithm`:character, `signature`:raw[], `validity`:character[], `self_signed`:logical, `alt_names`:null>;
type `cert_pubkey` <raw[]> => raw[];
type `cert_verify` <tuple<raw[], raw[], raw[], raw[]>, list<raw[]>> => logical;
type `cert_verify_cert` <raw[], tuple<raw[], raw[], raw[]>, list<raw[]>> => logical;
type `connectionhash` <integer, character> => raw[];
type `connectionhmac` <integer, character, raw[]> => raw[];
type `data_sign` <raw[], raw[]> => raw[];
type `data_verify` <raw[], raw[], raw[]> => logical;
type `decrypt_envelope` <raw[], raw[], raw[], raw[], null> => raw[];
type `default_key` < > => character;
type `der_export.pubkey` <raw[], null> => raw[];
type `derive_pubkey` <raw[]> => raw[];
type `download_ssl_cert` <character, double, logical> => tuple<raw[], raw[], raw[], raw[]>;
type `dsa_keygen` <double> => raw[];
type `ec_dh` <raw[], raw[], symbol> => raw[];
type `ec_keygen` <character[]> => raw[];
type `ecdsa_build` <tuple<raw[], raw[], raw[]>> => raw[];
type `ecdsa_parse` <raw[]> => struct<`r`:raw[], `s`:raw[]>;
type `ecdsa_pubkey_build` <raw[], raw[], character> => raw[];
type `ecdsa_write` <raw[], raw[]> => raw[];
type `ed25519_keygen` < > => raw[];
type `ed25519_sign` <raw[], raw[]> => raw[];
type `ed25519_verify` <raw[], raw[], raw[]> => logical;
type `encrypt_envelope` <raw[], raw[]> => struct<`iv`:raw[], `session`:raw[], `data`:raw[]>;
type `filter` <character[]> => logical[];
type `fingerprint.key` <raw[], any => any> => raw[];
type `fingerprint.pubkey` <raw[], any => any> => raw[];
type `fpdata.dsa` <raw[]> => struct<``:raw[], `p`:raw[], `q`:raw[], `g`:raw[], `y`:raw[]>;
type `fpdata.ecdsa` <raw[]> => tuple<raw[], raw[], raw[]>;
type `fpdata.ed25519` <raw[]> => tuple<raw[], raw[]>;
type `fpdata.rsa` <raw[]> => struct<``:raw[], `e`:raw[], `n`:raw[]>;
type `fpdata.x25519` <raw[]> => tuple<raw[], raw[]>;
type `FUN` <character | raw[], logical> => raw[];
type `hash` <raw[], null> => raw[];
type `hash_sign` <raw[], raw[]> => raw[];
type `hash_verify` <raw[], raw[], raw[]> => logical;
type `hashfun` <raw[], null> => raw[];
type `hmac_feed` <raw[]> => logical;
type `hmac_final` < > => raw[];
type `hmac_init` <raw[]> => character;
type `is_pubkey_str` <character | raw[]> => logical;
type `is_windows` < > => logical;
type `md_feed` <raw[]> => logical;
type `md_final` < > => raw[];
type `md_init` < > => character;
type `md5` <character[] | integer | raw[], null | character> => character[] | raw[];
type `my_key` < > => raw[];
type `my_pubkey` < > => raw[];
type `normalize_home` <character> => character;
type `openssl_config` < > => struct<`version`:character, `ec`:logical, `x25519`:logical>;
type `parse_der_key` <raw[]> => raw[];
type `parse_der_pubkey` <raw[]> => raw[];
type `parse_openssh` <raw[]> => raw[];
type `parse_pem` <raw[]> => tuple<struct<`name`:character, `header`:character, `data`:raw[]>>;
type `parse_pem_cert` <raw[], null> => raw[];
type `parse_pem_key` <raw[], character | any => any> => raw[];
type `pem_export.cert` <raw[], symbol> => character;
type `pem_export.key` <raw[], null | character, null> => character;
type `pem_export.pubkey` <raw[], symbol> => character;
type `pem_names` <raw[]> => character;
type `print.bignum` <raw[], logical, null> => null;
type `print.cert` <raw[], null> => null;
type `print.key` <raw[], null> => null;
type `print.pubkey` <raw[], null> => null;
type `priv_decompose.ecdsa` <raw[]> => struct<`curve`:character, `x`:raw[], `y`:raw[], `secret`:raw[]>;
type `priv_decompose.ed25519` <raw[]> => raw[];
type `priv_decompose.rsa` <raw[]> => struct<`e`:raw[], `n`:raw[], `p`:raw[], `q`:raw[], `d`:raw[], `dp`:raw[], `dq`:raw[], `qi`:raw[]>;
type `priv_decompose.x25519` <raw[]> => raw[];
type `pubkey_bitsize` <raw[]> => integer;
type `pubkey_decompose.dsa` <raw[]> => struct<`p`:raw[], `q`:raw[], `g`:raw[], `y`:raw[]>;
type `pubkey_decompose.ecdsa` <raw[]> => struct<`curve`:character, `x`:raw[], `y`:raw[]>;
type `pubkey_decompose.ed25519` <raw[]> => raw[];
type `pubkey_decompose.rsa` <raw[]> => struct<`e`:raw[], `n`:raw[]>;
type `pubkey_decompose.x25519` <raw[]> => raw[];
type `pubkey_type` <raw[]> => character;
type `rand_bytes` <double> => raw[];
type `rand_num` <double> => double[];
type `rawhash` <raw[], character, null> => raw[];
type `rawstringhash` <character[] | integer | raw[], character, null | character> => character[] | raw[];
type `read_cert_bundle` <character> => list<raw[]>;
type `read_ed25519_key` <raw[]> => raw[];
type `read_ed25519_pubkey` <raw[]> => raw[];
type `read_input` <character | integer | raw[]> => raw[];
type `read_key` <raw[] | character, symbol | character | any => any, logical> => raw[];
type `read_pubkey` <character | raw[], logical> => raw[];
type `read_raw_key_ed25519` <raw[]> => raw[];
type `read_raw_pubkey_ed25519` <raw[]> => raw[];
type `rsa_decrypt` <raw[], raw[], symbol> => raw[];
type `rsa_encrypt` <raw[], raw[]> => raw[];
type `rsa_keygen` <double> => raw[];
type `sha1` <character | raw[], null | character> => character | raw[];
type `sha256` <character[] | raw[], null | character> => character[] | raw[];
type `signature_create` <character | raw[], null | any => any, raw[], symbol> => raw[];
type `signature_verify` <character | raw[], raw[], null | any => any, raw[]> => logical;
type `split_pem` <raw[]> => character[];
type `ssh_build_pubkey` <raw[]> => raw[];
type `ssh_pubkey_from_string` <character> => raw[];
type `stopifnot` <logical> => null;
type `stringhash` <character[], character, null | raw[]> => character[];
type `validate_openssh` <character> => logical;
type `write_pem` <raw[], character, character> => character;
type `write_raw_key` <raw[]> => raw[];
type `write_raw_pubkey` <raw[]> => raw[];
type `write_ssh` <raw[], character> => character;
type `x25519_diffie_hellman` <raw[], raw[]> => raw[];
type `x25519_keygen` < > => raw[];
