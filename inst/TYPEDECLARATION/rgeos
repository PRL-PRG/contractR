type `::` <null, null> => character;
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null | integer;
type `FUN` <struct<`x`:double[], `y`:double[], `hole`:logical> | double[]> => null | double;
type `get_do_poly_check` < > => logical;
type `get_RGEOS_CheckValidity` < > => integer;
type `init_RGEOS` <null, null> => null;
type `set_RGEOS_HANDLE` <null, null> => null;
type `version_GEOS` <logical> => character;
type `version_GEOS0` < > => character;
type `.local` <symbol, struct<`col`:double> | tuple<> | logical, character | symbol, character | null, double, logical, null> => ^double[] | tuple<null>;
type `append.poly` <null, null> => null;
type `area` <^double[]> => double;
type `area.poly` <null> => double;
type `asMethod` <character, logical> => ^double[];
type `bbox2SP` <double | null, double | null, double | null, null | ^double[]> => double | null;
type `coordinates` <null> => ^double[];
type `expand.poly` <double[]> => tuple<struct<`x`:double[], `y`:double[], `hole`:logical>>;
type `fn` <double[], double[], double> => double;
type `gBinarySTRtreeQuery` < > => list<integer[]> | list<null | integer[]>;
type `gContains` <logical, logical, logical, logical, logical> => ^logical[];
type `gContainsProperly` <logical, logical, logical> => logical;
type `gCoveredBy` <logical, logical, logical> => logical;
type `gCovers` <logical, logical, logical> => logical;
type `gCrosses` <logical, logical, logical> => logical;
type `gDelaunayTriangulation` <logical> => double;
type `gDisjoint` <logical, logical, logical> => logical;
type `gEquals` <logical, logical, logical> => logical;
type `gEqualsExact` <double, logical, logical, logical> => logical;
type `get_RGEOS_DENSE` < > => logical;
type `get_RGEOS_dropSlivers` < > => logical;
type `get_RGEOS_polyThreshold` < > => double;
type `get_RGEOS_STR` < > => logical;
type `get_RGEOS_warnSlivers` < > => logical;
type `get.bbox` < > => struct<`x`:double[], `y`:double[]>;
type `getDists` <^double[]> => double[];
type `gInterpolate` <logical> => double[];
type `gIntersects` <logical[], logical, logical, logical> => ^logical[];
type `gLineMerge` <null> => logical;
type `gNearestPoints` <null, null> => null;
type `gNode` <null, null> => null;
type `gOverlaps` <logical, logical, logical> => logical;
type `gProject` <logical> => double[];
type `gTopoDim` < > => integer;
type `gTouches` <logical, logical, logical> => ^logical[];
type `gUnarySTRtreeQuery` < > => list<null | integer[]> | tuple<integer[], null>;
type `gUnaryUnion` <null | integer> => character[] | integer[];
type `gWithin` <logical, logical, logical> => logical;
type `intersect` <null, null> => null;
type `labpos.maxdist` <double, double, double> => double[];
type `listifyMatrix` <integer | struct<`1`:integer[], `2`:integer[], `3`:integer>> => struct<`1`:integer> | struct<`1`:integer[], `2`:integer[], `3`:integer>;
type `makerect` <double, double, double, integer> => double;
type `overGeomGeom` <logical, null, null, double> => integer;
type `plot` <null, struct<`col`:double> | null> => null | tuple<null>;
type `plotSpatialRings` <null, null, double, double, double, logical, logical, null, logical> => null;
type `poly_findInBoxGEOS` <logical> => list<null | integer[]>;
type `polygonsLabel` <character[], symbol, double, null | logical, double, logical, character[] | null> => ^double[];
type `read.polyfile` <logical> => character;
type `set_do_poly_check` <logical> => logical;
type `set_RGEOS_DENSE` <logical> => logical;
type `set_RGEOS_dropSlivers` <logical> => logical;
type `set_RGEOS_polyThreshold` <double> => double;
type `set_RGEOS_STR` <logical> => logical;
type `set_RGEOS_warnSlivers` <logical> => logical;
type `setdiff` <null, null> => null;
type `setScale` <double> => double;
type `union` <null, null> => null;
type `version_sp_linkingTo` < > => character;
type `gUnionCascaded` < > => null;
type `over` <logical, null, null> => ^integer[];
