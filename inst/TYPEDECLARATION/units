type `%|%` <character | null, character> => character;
type `all.equal.units` <class<`units`>, class<`units`>, ...> => logical;
type `are_convertible` <character, character> => logical;
type `are_exponents_implicit` <character> => logical;
type `as.character.symbolic_units` <class<`symbolic_units`>, ..., any, logical, character> => character;
type `as.data.frame.units` <class<`units`>, null, logical, ...> => class<`data.frame`>;
type `as_difftime` <class<`units`>> => class<`difftime`>;
type `.as.mixed_units` <list<class<`units`>>> => class<`mixed_units`>;
type `.as.units` <class<`units`> | double[], class<`symbolic_units`>, any> => class<`units`>;
type `as_units` <character | class<`call`> | class<`difftime`> | class<`name`> | class<`symbolic_units`> | class<`units`> | double[] | null, ...> => (class<`units`> | null);
type `as_units.call` <class<`call`> | class<`name`>, logical, ...> => class<`units`>;
type `as_units.character` <character, logical, logical | null, logical, ...> => class<`units`>;
type `as_units.default` <double[] | null, any, ...> => (class<`units`> | null);
type `as_units.difftime` <class<`difftime`>, any, ...> => class<`units`>;
type `as_units.name` <class<`call`> | class<`name`>, logical, ...> => class<`units`>;
type `as_units.symbolic_units` <class<`symbolic_units`>, any, ...> => class<`units`>;
type `as_units.units` <class<`units`>, any, ...> => class<`units`>;
type `backtick` <character> => character;
type `boxplot.units` <class<`units`>, ..., logical> => list<class<`matrix`> | double[] | character>;
type `check_unit_format` <character> => character;
type `convert` <class<`units`>, character, character> => double[];
type `convert_implicit_to_explicit_exponents` <character> => character;
type `c.units` <..., logical, any> => class<`units`>;
type `deparse_unit` <class<`units`>> => character;
type `drop_ones` <character[]> => character[];
type `drop_units` <class<`data.frame`> | class<`units`>> => (class<`data.frame`> | double[]);
type `drop_units.data.frame` <class<`data.frame`>> => class<`data.frame`>;
type `drop_units.units` <class<`units`>> => double[];
type `%empty%` <character[], character> => character[];
type `filter` <character[]> => logical[];
type `fun` <any, any> => null | <any, any> => null;
type `FUN` <class<`data.frame`> | class<`units`>> => (class<`data.frame`> | double[]) | <character> => character | <character, logical> => class<`units`> | <class<`xml_node`>> => character[] | <character> => logical | <class<`xml_node`>> => class<`data.frame`> | <integer> => class<`data.frame`>;
type `.get_ud_db_all` < > => class<`data.frame`>;
type `.get_ud_prefixes_xml` < > => class<`xml_document`, `xml_node`>;
type `.get_ud_xml_dir` <logical> => character;
type `has` <character, logical> => logical;
type `hist.units` <class<`units`>, null, character, ...> => class<`histogram`>;
type `install_conversion_constant` <character, character, double> => null;
type `install_conversion_offset` <character, character, double> => null;
type `install_symbolic_unit` <character, logical, logical> => null;
type `is_udunits_time` <character> => logical;
type `log10.units` <class<`units`>> => class<`units`>;
type `log2.units` <class<`units`>> => class<`units`>;
type `make_unit_label` <character, class<`units`>, any, character[], logical> => (character | expression);
type `make_units` <any, logical> => class<`units`>;
type `Math.units` <class<`units`>, ...> => (class<`units`> | double[]);
type `.message_where_udunits_db` < > => null;
type `mixed_units` <class<`units`> | double[], any, ...> => class<`mixed_units`>;
type `mixed_units.numeric` <double[], character[], ...> => class<`mixed_units`>;
type `mixed_units.units` <class<`units`>, any, ...> => class<`mixed_units`>;
type `Ops.symbolic_units` <class<`symbolic_units`>, class<`symbolic_units`>> => logical;
type `Ops.units` <class<`units`> | double[], class<`units`> | double> => class<`units`>;
type `pcc` <...> => character;
type `plot.units` <class<`units`>, any, null, null, ...> => null;
type `.pretty_print_sequence` <character[], character, logical, character> => character;
type `R_convert_doubles` <externalptr, externalptr, double[]> => double[];
type `.read_ud_db` <character, character> => class<`xml_document`, `xml_node`>;
type `.read_ud_db_as_dataframe` <character> => class<`data.frame`>;
type `R_ut_are_convertible` <externalptr, externalptr> => logical;
type `R_ut_format` <externalptr, logical, logical, logical> => character;
type `R_ut_get_name` <character> => character;
type `R_ut_get_symbol` <character> => character;
type `R_ut_log` <externalptr, double> => externalptr;
type `R_ut_new_dimensionless_unit` <character> => null;
type `R_ut_offset` <character, character, double> => null;
type `R_ut_parse` <character> => any;
type `R_ut_scale` <character, character, double> => null;
type `R_ut_set_encoding` <character> => null;
type `.same_units` <class<`symbolic_units`>, class<`symbolic_units`>> => logical;
type `seq.units` <any, any, any, null | double, null, ...> => class<`units`>;
type `.setopt` <character[] | logical | null> => (character[] | logical | null);
type `set_units` <class<`mixed_units`> | class<`units`> | double[], any, ..., any> => (class<`mixed_units`> | class<`units`> | double);
type `set_units.mixed_units` <class<`mixed_units`> | list<class<`units`>>, character[], ..., character> => class<`mixed_units`>;
type `set_units.numeric` <double[] | class<`units`>, any, ..., any> => (class<`units`> | double);
type `set_units.units` <double[] | class<`units`>, any, ..., any> => (class<`units`> | double);
type `.simplify_units` <class<`units`>, class<`symbolic_units`>> => class<`units`>;
type `Summary.units` <..., logical> => class<`units`>;
type `symbolic_unit` <character, logical> => class<`units`>;
type `.symbolic_units` <character[], character[]> => class<`symbolic_units`>;
type `ud_are_convertible` <character | class<`symbolic_units`>, character | class<`symbolic_units`>> => logical;
type `ud_convert` <double[], character, character> => double[];
type `.ud_db_xml_list_as_dataframe` <class<`xml_document`, `xml_node`>> => class<`data.frame`>;
type `ud_get_symbol` <character> => character;
type `ud_is_parseable` <character> => logical;
type `ud_set_encoding` <character> => null;
type `udunits_init` <character> => null;
type `[.units` <class<`units`>, logical[], any, ..., logical> => class<`units`>;
type `.units_are_convertible` <list<class<`units`>>, class<`symbolic_units`>> => logical;
type `units<-.numeric` <double[], class<`symbolic_units`> | class<`units`> | character | class<`call`> | null> => (class<`units`> | double);
type `units_options` <..., any, any, any, any, any, any, any, any, any, any> => (character[] | logical | list<any>);
type `.units.simplify` < > => (logical | null);
type `units<-.units` <class<`units`>, character[] | class<`symbolic_units`> | class<`units`> | null> => (class<`mixed_units`> | class<`units`> | double);
type `units.units` <class<`units`>> => class<`symbolic_units`>;
type `valid_udunits` <logical> => class<`data.frame`, `tbl`, `tbl_df`>;
type `valid_udunits_prefixes` <logical> => class<`data.frame`, `tbl`, `tbl_df`>;
type `with.units database` <class<`units database`>, any, ...> => class<`units`>;
