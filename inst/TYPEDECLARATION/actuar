type `adjCoef` <any, any, any, double, any, character[], any, any, double> => (class<`adjCoef`, `function`> | double);
type `aggregateDist` <character, character | double[] | expression | null, double[] | expression | null, double | null, double, double, any, any, ..., double, double, logical> => (class<`aggregateDist`, `ecdf`, `function`, `stepfun`> | class<`aggregateDist`, `function`>);
type `aggregate.portfolio` <class<`portfolio`>, character[], class<`function`>, logical, null | character, ...> => (class<`matrix`> | double[]);
type `bayes` <double[], character, any, double, any, any, any, double, double, any, any, any, any> => class<`bayes`>;
type `bstraub` <class<`matrix`>, class<`matrix`>, character, any, any, any> => class<`bstraub`>;
type `bvar.unbiased` <double[], double[], double, integer> => double;
type `cm` <character | class<`formula`>, any, any, any, any, null | class<`formula`>, any, logical, any, any, ..., any, double, logical> => (class<`bayes`, `cm`> | class<`bstraub`, `cm`> | class<`cm`, `hache`> | class<`cm`, `hierarc`>);
type `coverage` <any, any, double, logical, double, double, double, logical> => class<`function`>;
type `CTE` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, ...> => double[];
type `CTE.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, double[], logical, ...> => double[];
type `dburr` <double, double, double, double, double, logical> => double;
type `dgenbeta` <double, double, double, double, double, double, logical> => double;
type `dgenpareto` <double, double, double, double, double, logical> => double;
type `dgumbel` <double[], double, double, logical> => double[];
type `diff.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, ...> => double[];
type `dinvburr` <double, double, double, double, double, logical> => double;
type `dinvexp` <double, double, double, logical> => double;
type `dinvgamma` <double, double, double, double, logical> => double;
type `dinvgauss` <double[], double, double, double, logical> => double[];
type `dinvparalogis` <double, double, double, double, logical> => double;
type `dinvpareto` <double, double, double, logical> => double;
type `dinvtrgamma` <double, double, double, double, double, logical> => double;
type `dinvweibull` <double, double, double, double, logical> => double;
type `discretize` <any, double, double, double, character, any, double, null> => double[];
type `dlgamma` <double, double, double, logical> => double;
type `dllogis` <double, double, double, double, logical> => double;
type `dlogarithmic` <double | integer[], double[], logical> => double[];
type `dparalogis` <double, double, double, double, logical> => double;
type `dpareto` <double, double, double, logical> => double;
type `dpareto1` <double, double, double, logical> => double;
type `dphtype` <integer[], double[], class<`matrix`>, logical> => double[];
type `dpoisinvgauss` <integer[], double, double, double, logical> => double[];
type `dtrbeta` <double, double, double, double, double, double, logical> => double;
type `dtrgamma` <double, double, double, double, double, logical> => double;
type `dzmbinom` <integer[], double, double, double, logical> => double[];
type `dzmgeom` <integer[], double, double, logical> => double[];
type `dzmlogarithmic` <integer[], double, double, logical> => double[];
type `dzmnbinom` <integer[], double, double, double, logical> => double[];
type `dzmpois` <integer[], double, double, logical> => double[];
type `dztbinom` <integer[] | double, double, double, logical> => double[];
type `dztgeom` <double[], double, logical> => double[];
type `dztnbinom` <double[], double, double, logical> => double[];
type `dztpois` <integer[] | double, double, logical> => double[];
type `elev` <class<`data.frame`, `grouped.data`> | double[], ...> => class<`elev`, `function`>;
type `elev.default` <double[], ...> => class<`elev`, `function`>;
type `elev.grouped.data` <class<`data.frame`, `grouped.data`>, ...> => class<`elev`, `function`>;
type `emm` <class<`data.frame`, `grouped.data`> | double[], integer[] | double, ...> => double[];
type `emm.default` <double[], integer[], ...> => double[];
type `emm.grouped.data` <class<`data.frame`, `grouped.data`>, integer[] | double, ...> => double[];
type `exact` <double[], double[], double> => class<`ecdf`, `function`, `stepfun`>;
type `frequency.portfolio` <class<`portfolio`>, character[], logical, character | null, ...> => class<`matrix`>;
type `FUN` <integer[], double, double, double, logical> => double[];
type `[<-.grouped.data` <class<`data.frame`, `grouped.data`>, any, double[], double[]> => class<`data.frame`, `grouped.data`>;
type `[.grouped.data` <class<`data.frame`, `grouped.data`>, any, any> => (class<`data.frame`> | class<`data.frame`, `grouped.data`> | double[]);
type `grouped.data` <..., character | double[], logical, logical, null, logical, null, logical, logical> => class<`data.frame`, `grouped.data`>;
type `hache` <class<`matrix`>, class<`matrix`>, class<`formula`>, class<`data.frame`>, logical, any, any, any, any> => class<`hache`>;
type `hache.barycenter` <class<`matrix`>, class<`matrix`>, class<`matrix`>, character, any, any, any> => list<any>;
type `hache.origin` <class<`matrix`>, class<`matrix`>, class<`matrix`>, double, double, logical> => list<null | class<`array`> | list<any>>;
type `hierarc` <class<`matrix`>, class<`matrix`>, class<`matrix`>, character[], any, any, any> => class<`hierarc`>;
type `hist.grouped.data` <class<`data.frame`, `grouped.data`>, null, any, null, double, null, null, character, double[], null, character, any, logical, logical, logical, ...> => class<`histogram`>;
type `knots.elev` <class<`elev`, `function`>, ...> => double[];
type `levbeta` <double, double, double, double> => double;
type `levburr` <double, double, double, double, double, double> => double;
type `levchisq` <double, double, double, double> => double;
type `levexp` <double, double, double> => double;
type `levgamma` <double[], double, double, double, double> => double[];
type `levgenbeta` <double, double, double, double, double, double, double> => double;
type `levgenpareto` <double, double, double, double, double, double> => double;
type `levinvburr` <double, double, double, double, double, double> => double;
type `levinvgamma` <double, double, double, double, double> => double;
type `levinvgauss` <double[], double, double, double, double> => double[];
type `levinvparalogis` <double, double, double, double, double> => double;
type `levinvtrgamma` <double, double, double, double, double, double> => double;
type `levinvweibull` <double, double, double, double, double> => double;
type `levlgamma` <double, double, double, double> => double;
type `levllogis` <double, double, double, double, double> => double;
type `levlnorm` <double[], double, double, double> => double[];
type `levparalogis` <double, double, double, double, double> => double;
type `levpareto` <double, double, double, double> => double;
type `levtrbeta` <double, double, double, double, double, double, double> => double;
type `levtrgamma` <double, double, double, double, double, double> => double;
type `levunif` <double, double, double, integer[] | double> => double[];
type `levweibull` <double, double, double, double> => double;
type `mbeta` <double, double, double> => double;
type `mburr` <double, double, double, double, double> => double;
type `mchisq` <double, double, double> => double;
type `mde` <class<`data.frame`, `grouped.data`> | double[], class<`function`>, list<double>, character, null, ...> => any;
type `mean.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, ...> => double;
type `mean.grouped.data` <class<`data.frame`, `grouped.data`>, ...> => double[];
type `mexp` <double, double> => double;
type `mgamma` <double, double, double, double> => double;
type `mgenbeta` <double, double, double, double, double, double> => double;
type `mgenpareto` <double, double, double, double, double> => double;
type `mgfchisq` <double, double, double, logical> => double;
type `mgfexp` <double, double, logical> => double;
type `mgfgamma` <double, double, double, double, logical> => double;
type `mgfinvgamma` <double, double, double, double, logical> => double;
type `mgfnorm` <integer[], double, double, logical> => double[];
type `mgfphtype` <double[], double[], class<`matrix`>, logical> => double[];
type `mgfunif` <double, double, double, logical> => double;
type `mgumbel` <double, double, double> => double;
type `minvburr` <double, double, double, double, double> => double;
type `minvexp` <double, double, double> => double;
type `minvgamma` <double, double, double, double> => double;
type `minvgauss` <integer[], double, double, double> => double[];
type `minvparalogis` <double, double, double, double> => double;
type `minvpareto` <double, double, double> => double;
type `minvtrgamma` <double, double, double, double, double> => double;
type `mlgamma` <double, double, double> => double;
type `mlgompertz` <double, double, double, double> => double;
type `mllogis` <double, double, double, double> => double;
type `mlnorm` <double, double, double> => double;
type `mnorm` <double, double, double> => double;
type `mparalogis` <double, double, double, double> => double;
type `mpareto` <double, double, double> => double;
type `mpareto1` <double, double, double> => double;
type `mphtype` <double, double[], class<`matrix`>> => double;
type `mtrbeta` <double, double, double, double, double, double> => double;
type `mtrgamma` <double, double, double, double, double> => double;
type `munif` <integer[] | double, double, double> => double[];
type `mweibull` <double, double, double> => double;
type `normal` <double, double> => class<`function`>;
type `npower` <double, double, double> => class<`function`>;
type `ogive` <class<`data.frame`, `grouped.data`> | double[], ...> => class<`function`, `ogive`>;
type `ogive.default` <double[], double[] | null, character | double[], null, ...> => class<`function`, `ogive`>;
type `.ogiveFUN` <double[], double[]> => class<`function`, `ogive`>;
type `ogive.grouped.data` <class<`data.frame`, `grouped.data`>, ...> => class<`function`, `ogive`>;
type `panjer` <double[], character, double | null, double, ..., double, double, double, logical> => class<`ecdf`, `function`, `stepfun`>;
type `pburr` <double[], double, double, double, double, logical, logical> => double[];
type `pgenbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `pgenpareto` <double[], double, double, double, double, logical, logical> => double[];
type `pgfztbinom` <double, double, double> => double;
type `pgfztpois` <double, double> => double;
type `pgumbel` <double[], double, double, logical, logical> => double[];
type `pinvburr` <double[], double, double, double, double, logical, logical> => double[];
type `pinvexp` <double[], double, double, logical, logical> => double[];
type `pinvgamma` <double[], double, double, double, logical, logical> => double[];
type `pinvgauss` <double[], double, double, double, logical, logical> => double[];
type `pinvparalogis` <double[], double, double, double, logical, logical> => double[];
type `pinvpareto` <double[], double, double, logical, logical> => double[];
type `pinvtrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `pinvweibull` <double[], double, double, double, logical, logical> => double[];
type `plgamma` <double[], double, double, logical, logical> => double[];
type `pllogis` <double[], double, double, double, logical, logical> => double[];
type `plogarithmic` <double | integer[], double[], logical, logical> => double[];
type `plot.adjCoef` <class<`adjCoef`, `function`>, character, character, character, character, character, logical, ...> => null;
type `plot.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`> | class<`aggregateDist`, `function`>, any, any, character, character, ...> => null;
type `plot.elev` <class<`elev`, `function`>, ..., null, character, character> => null;
type `plot.ogive` <class<`function`, `ogive`>, null, character, character, ...> => null;
type `plot.ruin` <class<`function`, `ruin`>, double | null, double | null, logical, character, expression, character, null | double[], ...> => list<double[]>;
type `pparalogis` <double[], double, double, double, logical, logical> => double[];
type `ppareto` <double[], double, double, logical, logical> => double[];
type `ppareto1` <double[], double, double, logical, logical> => double[];
type `pphtype` <double[], class<`matrix`> | double[], class<`matrix`>, logical, logical> => double[];
type `ppoisinvgauss` <integer[], double, double, double, logical, logical> => double[];
type `predict.bayes` <class<`bayes`, `cm`> | class<`bstraub`, `cm`>, null, any, ...> => double[];
type `predict.bstraub` <class<`bayes`, `cm`> | class<`bstraub`, `cm`>, null, any, ...> => double[];
type `predict.cm` <class<`bstraub`, `cm`> | class<`cm`, `hache`> | class<`bayes`, `cm`> | class<`cm`, `hierarc`>, null | character, any, ...> => (double[] | list<double[]>);
type `predict.hache` <class<`cm`, `hache`>, null, class<`data.frame`>, ...> => double[];
type `predict.hierarc` <class<`cm`, `hierarc`>, integer[] | null, any, ...> => list<double[]>;
type `ptrbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `ptrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `pzmbinom` <integer[], double, double, double, logical, logical> => double[];
type `pzmgeom` <integer[], double, double, logical, logical> => double[];
type `pzmlogarithmic` <integer[], double, double, logical, logical> => double[];
type `pzmnbinom` <integer[], double, double, double, logical, logical> => double[];
type `pzmpois` <integer[], double, double, logical, logical> => double[];
type `pztbinom` <integer[] | double, double, double, logical, logical> => double[];
type `pztgeom` <integer[] | double, double, logical, logical> => double[];
type `pztnbinom` <integer[] | double, double, double, logical, logical> => double[];
type `pztpois` <integer[] | double, double, logical, logical> => double[];
type `qburr` <double[], double, double, double, double, logical, logical> => double[];
type `qgenbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `qgenpareto` <double[], double, double, double, double, logical, logical> => double[];
type `qgumbel` <double[], double, double, logical, logical> => double[];
type `qinvburr` <double[], double, double, double, double, logical, logical> => double[];
type `qinvexp` <double[], double, double, logical, logical> => double[];
type `qinvgamma` <double[], double, double, double, logical, logical> => double[];
type `qinvgauss` <double[], double, double, double, logical, logical, double, double, logical, logical> => double[];
type `qinvparalogis` <double[], double, double, double, logical, logical> => double[];
type `qinvpareto` <double[], double, double, logical, logical> => double[];
type `qinvtrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `qinvweibull` <double[], double, double, double, logical, logical> => double[];
type `qlgamma` <double[], double, double, logical, logical> => double[];
type `qllogis` <double[], double, double, double, logical, logical> => double[];
type `qlogarithmic` <double[], double, logical, logical> => double[];
type `qparalogis` <double[], double, double, double, logical, logical> => double[];
type `qpareto` <double[], double, double, logical, logical> => double[];
type `qpareto1` <double[], double, double, logical, logical> => double[];
type `qpearson6` <double[], double, double, double, double, double, logical, logical> => double[];
type `qpoisinvgauss` <double[], double, double, double, logical, logical> => double[];
type `qtrbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `qtrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `quantile.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, double[], logical, logical, ...> => double[];
type `quantile.grouped.data` <class<`data.frame`, `grouped.data`>, double[], logical, ...> => double[];
type `qzmbinom` <double[], double, double, double, logical, logical> => double[];
type `qzmgeom` <double[], double, double, logical, logical> => double[];
type `qzmlogarithmic` <double[], double, double, logical, logical> => double[];
type `qzmnbinom` <double[], double, double, double, logical, logical> => double[];
type `qzmpois` <double[], double, double, logical, logical> => double[];
type `qztbinom` <double[], double, double, logical, logical> => double[];
type `qztgeom` <double[], double, logical, logical> => double[];
type `qztnbinom` <double[], double, double, logical, logical> => double[];
type `qztpois` <double[], double, logical, logical> => double[];
type `rcomphierarc` <double | list<double[]>, expression, expression | null, double[] | null> => class<`portfolio`>;
type `rcompound` <double, any, any, logical> => double[];
type `rcomppois` <double, double, any, logical> => (double[] | list<double[]>);
type `rlogarithmic` <double, double> => integer[];
type `rmixture` <double, double[], expression> => double[];
type `rphtype` <double, double[], class<`matrix`>> => double[];
type `rpoisinvgauss` <double, double, double, double> => integer[];
type `ruin` <character, list<double[] | class<`matrix`> | double[]>, character, list<double[]>, double, any, integer, logical> => class<`function`, `ruin`>;
type `rztnbinom` <double, double, double> => integer[];
type `severity` <class<`matrix`> | class<`portfolio`>, ...> => (class<`matrix`> | list<class<`matrix`> | class<`matrix`> | null>);
type `severity.default` <class<`matrix`>, logical, logical, ...> => class<`matrix`>;
type `severity.portfolio` <class<`portfolio`>, character[], character | double | logical[] | null, logical, null, ...> => list<class<`matrix`> | class<`matrix`> | null>;
type `simS` <double, expression, expression> => class<`ecdf`, `function`, `stepfun`>;
type `simul` <double | list<double[]>, expression, expression | null, double[] | null> => class<`portfolio`>;
type `summary.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, ...> => class<`aggregateDist`, `ecdf`, `function`, `stepfun`, `summary.aggregateDist`>;
type `summary.cm` <class<`bayes`, `cm`> | class<`bstraub`, `cm`> | class<`cm`, `hache`> | class<`cm`, `hierarc`>, null | character, any, ...> => (class<`bayes`, `cm`, `summary.cm`> | class<`bstraub`, `cm`, `summary.cm`> | class<`cm`, `hache`, `summary.cm`> | class<`cm`, `hierarc`, `summary.cm`>);
type `summary.elev` <class<`elev`, `function`>, ...> => class<`summaryDefault`, `table`>;
type `summary.ogive` <class<`function`, `ogive`>, ...> => class<`summary.ogive`>;
type `unroll` <class<`matrix`> | list<integer[]>, logical, logical> => (class<`matrix`> | integer[]);
type `VaR` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, ...> => double[];
type `VaR.aggregateDist` <class<`aggregateDist`, `ecdf`, `function`, `stepfun`>, double[], logical, logical, ...> => double[];
type `weights.portfolio` <class<`portfolio`>, logical, null, ...> => (class<`matrix`> | null);
