type `:::` <double, double, double> => double;
type `.ogiveFUN` <double[], double[]> => any => any;
type `[.grouped.data` <struct<`Group`:integer[], `Line.1`:double[], `Line.2`:double[]>, ???, double> => struct<`Line.1`:double[], `Line.2`:double[]> | double[];
type `[<-.grouped.data` <struct<`cj`:integer[], `nj`:integer[]>, ??? | double, double[], double[]> => struct<`cj`:integer[], `nj`:double[]>;
type `adjCoef` <??? | symbol, symbol | language, ??? | any => any, double, symbol | ???, character, double, double, double> => any => any;
type `aggregate.portfolio` <struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<? double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`cohort`:double, `contract`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression>, character[], any => any, logical, null, ???> => ^double[];
type `aggregateDist` <character, ? character | double[] | expression, ? double[] | expression, ? double, double, double, double[] | ???, ??? | double, ??? | double, double, double, logical> => any => any;
type `bayes` <double[], character, double | ???, double, double | language, ???, ???, double, double, ???, ???, ??? | double, ???> => struct<`means`:tuple<double, double>, `weights`:tuple<null, integer>, `unbiased`:double[], `iterative`:null, `cred`:double, `nodes`:integer>;
type `bstraub` <^double[], ^double[], character, symbol, symbol, symbol> => struct<`means`:tuple<double, double[]>, `weights`:tuple<double, double[]>, `unbiased`:double[], `iterative`:null, `cred`:double[], `nodes`:tuple<integer>>;
type `bvar.unbiased` <double[], double[], double, integer> => double;
type `cm` <language, symbol, language, language | ???, ???, ? language, struct<`time`:integer[]> | ???, logical, double[] | character[], ???, ???, double | language, double, logical> => struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `iterative`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `unbiased`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[], `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `iterative`:double[], `cred`:struct<`cohort`:double[], `state`:double[]>, `nodes`:struct<`cohort`:integer, `state`:integer[]>, `classification`:^double[], `ordering`:struct<`cohort`:integer[], `state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `state`:double[]>, `weights`:struct<`portfolio`:double, `state`:double[]>, `unbiased`:double[], `cred`:double[], `nodes`:struct<`state`:integer>, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `unbiased`:double[], `cred`:struct<`unit`:double[], `state`:double[]>, `nodes`:struct<`unit`:integer, `state`:integer[]>, `classification`:struct<`unit`:integer[], `state`:double[]>, `ordering`:struct<`unit`:integer[], `state`:integer[]>>;
type `coverage` <any => any | character | ???, any => any | character | ???, double, logical, double, double, double, logical> => any => any;
type `CTE.aggregateDist` <any => any, double[], logical, ???> => double[];
type `dburr` <double, double, double, double, double, logical> => double;
type `densfun` <double[], language, language, language> => double[];
type `dgammaL` <double[], double, double, language> => double[];
type `dgammaP` <double[], double, double, language> => double[];
type `dgenbeta` <double, double, double, double, double, double, logical> => double;
type `dgenpareto` <double, double, double, double, double, logical> => double;
type `dgumbel` <double[], double, double, logical> => double[];
type `diff.aggregateDist` <any => any, ???> => double[];
type `dinvburr` <double, double, double, double, double, logical> => double;
type `dinvexp` <double, double, double, logical> => double;
type `dinvgamma` <double, double, double, double, logical> => double;
type `dinvgauss` <double[], double, double, double, logical> => double[];
type `dinvparalogis` <double, double, double, double, logical> => double;
type `dinvpareto` <double, double, double, logical> => double;
type `dinvtrgamma` <double, double, double, double, double, logical> => double;
type `dinvweibull` <double, double, double, double, logical> => double;
type `dlgamma` <double, double, double, logical> => double;
type `dllogis` <double, double, double, double, logical> => double;
type `dlogarithmic` <double | integer[], double[], logical> => double[];
type `dparalogis` <double, double, double, double, logical> => double;
type `dpareto` <double, double, double, logical> => double;
type `dpareto1` <double, double, double, logical> => double;
type `dphtype` <integer[], double[], ^double[], logical> => double[];
type `dpoisinvgauss` <integer[], double, double, double, logical> => double[];
type `dtrbeta` <double, double, double, double, double, double, logical> => double;
type `dtrgamma` <double, double, double, double, double, logical> => double;
type `dzmbinom` <integer[], double, double, double, logical> => double[];
type `dzmgeom` <integer[], double, double, logical> => double[];
type `dzmlogarithmic` <integer[], double, double, logical> => double[];
type `dzmnbinom` <integer[], double, double, double, logical> => double[];
type `dzmpois` <integer[], double, double, logical> => double[];
type `dztbinom` <integer[] | double, double, double, logical> => double[];
type `dztgeom` <double[], double, logical> => double[];
type `dztnbinom` <double[], double, double, logical> => double[];
type `dztpois` <integer[] | double, double, logical> => double[];
type `e` <integer[]> => double[];
type `elev.default` <double[], ???> => any => any;
type `elev.grouped.data` <struct<`cj`:integer[], `nj`:integer[]>, ???> => any => any;
type `emm.default` <double[], integer[], ???> => double[];
type `emm.grouped.data` <struct<`cj`:integer[], `nj`:integer[]>, integer[] | double, ???> => double[];
type `exact` <double[], double[], double> => any => any;
type `f` <double[], double, double, language> => double[];
type `F` <double[], double, double, language> => double[];
type `filter` <character[]> => logical[];
type `fn` <double[], double[], ??? | double[], ???> => double[];
type `frequency.portfolio` <struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<? double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`cohort`:double, `contract`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`entity`:double, `year`:double[]>, `model.freq`:expression, `model.sev`:null> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:null>, character[], logical, ? character, ???> => ^double[];
type `Fs` <double> => double;
type `fun` <double[], double, double, logical, logical> => double[];
type `FUN` <? struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>> | character[] | list<double[]> | list<? double[]> | tuple<null, null, null, null> | ^double[] | tuple<double[]>, struct<> | ??? | double[], double, double, logical> => ? ^double[] | struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>;
type `G` <double[], double[], ???> => double[];
type `Gn` <double[]> => double[];
type `grouped.data` <double[], character | double[], logical, logical, null, logical, null, logical, logical> => struct<``:integer[], `x`:integer[]>;
type `h1` <double> => double;
type `h2` <double, double> => double;
type `hache` <^double[], ^double[], language, struct<`time`:integer[]>, logical, symbol | character, double | symbol, double | symbol, logical | symbol> => struct<`means`:tuple<double[], ^double[]>, `weights`:tuple<^double[], double[]>, `unbiased`:null, `iterative`:tuple<^double[], double>, `cred`:double[], `nodes`:tuple<integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `terms`:language> | struct<`means`:tuple<double[], ^double[]>, `weights`:tuple<^double[], double[]>, `unbiased`:tuple<^double[], double>, `iterative`:null, `cred`:double[], `nodes`:tuple<integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[], `terms`:language>;
type `hache.barycenter` <^double[], ^double[], ^double[], character, symbol, symbol, symbol> => struct<`means`:tuple<double[], ^double[]>, `weights`:tuple<^double[], double[]>, `unbiased`:tuple<^double[], double>, `iterative`:null, `cred`:double[], `nodes`:tuple<integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[]>;
type `hache.origin` <^double[], ^double[], ^double[], double, double, logical> => struct<`means`:tuple<double[], ^double[]>, `weights`:tuple<^double[], double[]>, `unbiased`:null, `iterative`:tuple<^double[], double>, `cred`:double[], `nodes`:tuple<integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>>;
type `hierarc` <^double[], ^double[], ^integer[], character[], symbol | double, symbol | double, symbol | logical> => struct<`means`:tuple<double, double[], double[]>, `weights`:tuple<double, double[], double[]>, `unbiased`:double[], `iterative`:null, `cred`:tuple<double[], double[]>, `nodes`:tuple<integer, integer[]>, `classification`:^integer[], `ordering`:tuple<integer[], integer[]>> | struct<`means`:tuple<double, double[], double[]>, `weights`:tuple<double, double[], double[]>, `unbiased`:null, `iterative`:double[], `cred`:tuple<double[], double[]>, `nodes`:tuple<integer, integer[]>, `classification`:^integer[], `ordering`:tuple<integer[], integer[]>>;
type `hist.grouped.data` <struct<`Group`:integer[], `Line.1`:double[]>, null, language, null, double, null, null, character, double[], null, character, ???, logical, logical, logical, ???> => struct<`breaks`:double[], `counts`:double[], `intensities`:double[], `density`:double[], `mids`:double[], `xname`:character, `equidist`:logical>;
type `knots.elev` <any => any, ???> => double[];
type `lev` <double[]> => double[];
type `levbeta` <double, double, double, double> => double;
type `levburr` <double, double, double, double, double, double> => double;
type `levchisq` <double, double, double, double> => double;
type `levexp` <double, double, double> => double;
type `levgamma` <double[], double, double, double, double> => double[];
type `levgenbeta` <double, double, double, double, double, double, double> => double;
type `levgenpareto` <double, double, double, double, double, double> => double;
type `levinvburr` <double, double, double, double, double, double> => double;
type `levinvgamma` <double, double, double, double, double> => double;
type `levinvgauss` <double[], double, double, double, double> => double[];
type `levinvparalogis` <double, double, double, double, double> => double;
type `levinvtrgamma` <double, double, double, double, double, double> => double;
type `levinvweibull` <double, double, double, double, double> => double;
type `levlgamma` <double, double, double, double> => double;
type `levllogis` <double, double, double, double, double> => double;
type `levlnorm` <double[], double, double, double> => double[];
type `levparalogis` <double, double, double, double, double> => double;
type `levpareto` <double, double, double, double> => double;
type `levtrbeta` <double, double, double, double, double, double, double> => double;
type `levtrgamma` <double, double, double, double, double, double> => double;
type `levunif` <double, double, double, integer[] | double> => double[];
type `levweibull` <double, double, double, double> => double;
type `mbeta` <double, double, double> => double;
type `mburr` <double, double, double, double, double> => double;
type `mchisq` <double, double, double> => double;
type `mde` <struct<`cj`:integer[], `nj`:integer[]> | double[], any => any, struct<`logshape`:double, `logscale`:double> | struct<`shape`:double, `scale`:double> | struct<`rate`:double>, character, ? pairlist, ???> => struct<`estimate`:double[], `distance`:double>;
type `mean.aggregateDist` <any => any, ???> => double;
type `mean.grouped.data` <struct<`Group`:integer[], `Line.1`:double[], `Line.2`:double[]>, ???> => double[];
type `mexp` <double, double> => double;
type `mgamma` <double, double, double, double> => double;
type `mgenbeta` <double, double, double, double, double, double> => double;
type `mgenpareto` <double, double, double, double, double> => double;
type `mgfchisq` <double, double, double, logical> => double;
type `mgfexp` <double, double, logical> => double;
type `mgfgamma` <double, double, double, double, logical> => double;
type `mgfinvgamma` <double, double, double, double, logical> => double;
type `mgfnorm` <integer[], double, double, logical> => double[];
type `mgfphtype` <double[], double[], ^double[], logical> => double[];
type `mgfunif` <double, double, double, logical> => double;
type `mgumbel` <double, double, double> => double;
type `minvburr` <double, double, double, double, double> => double;
type `minvexp` <double, double, double> => double;
type `minvgamma` <double, double, double, double> => double;
type `minvgauss` <integer[], double, double, double> => double[];
type `minvparalogis` <double, double, double, double> => double;
type `minvpareto` <double, double, double> => double;
type `minvtrgamma` <double, double, double, double, double> => double;
type `mlgamma` <double, double, double> => double;
type `mlgompertz` <double, double, double, double> => double;
type `mllogis` <double, double, double, double> => double;
type `mlnorm` <double, double, double> => double;
type `mnorm` <double, double, double> => double;
type `mparalogis` <double, double, double, double> => double;
type `mpareto` <double, double, double> => double;
type `mpareto1` <double, double, double> => double;
type `mphtype` <double, double[], ^double[]> => double;
type `mtrbeta` <double, double, double, double, double, double> => double;
type `mtrgamma` <double, double, double, double, double> => double;
type `munif` <integer[] | double, double, double> => double[];
type `mweibull` <double, double, double> => double;
type `normal` <double, double> => any => any;
type `npower` <double, double, double> => any => any;
type `numform` <double[], double> => character[];
type `ogive.default` <double[], ? double[], character | double[], null, ???> => any => any;
type `ogive.grouped.data` <struct<`cj`:integer[], `nj`:integer[]>, ???> => any => any;
type `panjer` <double[], character, ? double, double, double, double, double, double, logical> => any => any;
type `pburr` <double[], double, double, double, double, logical, logical> => double[];
type `pgammaL` <double[], double, double, language> => double[];
type `pgammaP` <double[], double, double, language> => double[];
type `pgenbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `pgenpareto` <double[], double, double, double, double, logical, logical> => double[];
type `pgfztbinom` <double, double, double> => double;
type `pgfztpois` <double, double> => double;
type `pgumbel` <double[], double, double, logical, logical> => double[];
type `pinvburr` <double[], double, double, double, double, logical, logical> => double[];
type `pinvexp` <double[], double, double, logical, logical> => double[];
type `pinvgamma` <double[], double, double, double, logical, logical> => double[];
type `pinvgauss` <double[], double, double, double, logical, logical> => double[];
type `pinvparalogis` <double[], double, double, double, logical, logical> => double[];
type `pinvpareto` <double[], double, double, logical, logical> => double[];
type `pinvtrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `pinvweibull` <double[], double, double, double, logical, logical> => double[];
type `plgamma` <double[], double, double, logical, logical> => double[];
type `pllogis` <double[], double, double, double, logical, logical> => double[];
type `plogarithmic` <double | integer[], double[], logical, logical> => double[];
type `plot.adjCoef` <any => any, character, character, character, character, character, logical, character | ???> => null;
type `plot.aggregateDist` <any => any, ??? | double[], expression | language, character, character, logical | ???> => null;
type `plot.elev` <any => any, character, null, character, character> => null;
type `plot.ogive` <any => any, null, character, character, ???> => null;
type `plot.ruin` <any => any, ? double, ? double, logical, character, expression, character, ? double[], ???> => struct<`x`:double[], `y`:double[]>;
type `pparalogis` <double[], double, double, double, logical, logical> => double[];
type `ppareto` <double[], double, double, logical, logical> => double[];
type `ppareto1` <double[], double, double, logical, logical> => double[];
type `pphtype` <double[], ^double[], ^double[], logical, logical> => double[];
type `ppoisinvgauss` <integer[], double, double, double, logical, logical> => double[];
type `predict.bayes` <struct<`means`:tuple<double, double>, `weights`:tuple<null, integer>, `unbiased`:double[], `iterative`:null, `cred`:double, `nodes`:integer>, null, ??? | symbol, ???> => double;
type `predict.bstraub` <struct<`means`:struct<`portfolio`:double, `state`:double[]>, `weights`:struct<`portfolio`:double, `state`:double[]>, `unbiased`:double[], `cred`:double[], `nodes`:struct<`state`:integer>, `classification`:^double[], `ordering`:struct<`state`:integer[]>>, null, ??? | symbol, ???> => double[];
type `predict.cm` <struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `iterative`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `unbiased`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[], `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `state`:double[]>, `weights`:struct<`portfolio`:double, `state`:double[]>, `unbiased`:double[], `cred`:double[], `nodes`:struct<`state`:integer>, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:tuple<double, double>, `weights`:tuple<null, integer>, `unbiased`:double[], `iterative`:null, `cred`:double, `nodes`:integer> | struct<`means`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `iterative`:double[], `cred`:struct<`cohort`:double[], `state`:double[]>, `nodes`:struct<`cohort`:integer, `state`:integer[]>, `classification`:^double[], `ordering`:struct<`cohort`:integer[], `state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `unbiased`:double[], `cred`:struct<`unit`:double[], `state`:double[]>, `nodes`:struct<`unit`:integer, `state`:integer[]>, `classification`:struct<`unit`:integer[], `state`:double[]>, `ordering`:struct<`unit`:integer[], `state`:integer[]>>, ? character, struct<`time`:double> | ??? | symbol, ???> => double[] | struct<`cohort`:double[]> | struct<`unit`:double[]>;
type `predict.hache` <struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `iterative`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `unbiased`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[], `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>>, null, struct<`time`:double>, ???> => double[];
type `predict.hierarc` <struct<`means`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `iterative`:double[], `cred`:struct<`cohort`:double[], `state`:double[]>, `nodes`:struct<`cohort`:integer, `state`:integer[]>, `classification`:^double[], `ordering`:struct<`cohort`:integer[], `state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `unbiased`:double[], `cred`:struct<`unit`:double[], `state`:double[]>, `nodes`:struct<`unit`:integer, `state`:integer[]>, `classification`:struct<`unit`:integer[], `state`:double[]>, `ordering`:struct<`unit`:integer[], `state`:integer[]>>, ? integer[], ???, ???> => struct<`cohort`:double[]> | struct<`unit`:double[]>;
type `psi` <integer[], logical, logical> => double[];
type `ptrbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `ptrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `pzmbinom` <integer[], double, double, double, logical, logical> => double[];
type `pzmgeom` <integer[], double, double, logical, logical> => double[];
type `pzmlogarithmic` <integer[], double, double, logical, logical> => double[];
type `pzmnbinom` <integer[], double, double, double, logical, logical> => double[];
type `pzmpois` <integer[], double, double, logical, logical> => double[];
type `pztbinom` <integer[] | double, double, double, logical, logical> => double[];
type `pztgeom` <integer[] | double, double, logical, logical> => double[];
type `pztnbinom` <integer[] | double, double, double, logical, logical> => double[];
type `pztpois` <integer[] | double, double, logical, logical> => double[];
type `qburr` <double[], double, double, double, double, logical, logical> => double[];
type `qgenbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `qgenpareto` <double[], double, double, double, double, logical, logical> => double[];
type `qgumbel` <double[], double, double, logical, logical> => double[];
type `qinvburr` <double[], double, double, double, double, logical, logical> => double[];
type `qinvexp` <double[], double, double, logical, logical> => double[];
type `qinvgamma` <double[], double, double, double, logical, logical> => double[];
type `qinvgauss` <double[], double, double, double, logical, logical, double, double, logical, logical> => double[];
type `qinvparalogis` <double[], double, double, double, logical, logical> => double[];
type `qinvpareto` <double[], double, double, logical, logical> => double[];
type `qinvtrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `qinvweibull` <double[], double, double, double, logical, logical> => double[];
type `qlgamma` <double[], double, double, logical, logical> => double[];
type `qllogis` <double[], double, double, double, logical, logical> => double[];
type `qlogarithmic` <double[], double, logical, logical> => double[];
type `qparalogis` <double[], double, double, double, logical, logical> => double[];
type `qpareto` <double[], double, double, logical, logical> => double[];
type `qpareto1` <double[], double, double, logical, logical> => double[];
type `qpearson6` <double, double, double, double, double, double, logical, logical> => double;
type `qpoisinvgauss` <double[], double, double, double, logical, logical> => double[];
type `qtrbeta` <double[], double, double, double, double, double, logical, logical> => double[];
type `qtrgamma` <double[], double, double, double, double, logical, logical> => double[];
type `quantile.aggregateDist` <any => any, double[], logical, logical, ???> => double[];
type `quantile.grouped.data` <struct<`cj`:integer[], `nj`:integer[]>, double[], logical, ???> => double[];
type `qzmbinom` <double[], double, double, double, logical, logical> => double[];
type `qzmgeom` <double[], double, double, logical, logical> => double[];
type `qzmlogarithmic` <double[], double, double, logical, logical> => double[];
type `qzmnbinom` <double[], double, double, double, logical, logical> => double[];
type `qzmpois` <double[], double, double, logical, logical> => double[];
type `qztbinom` <double[], double, double, logical, logical> => double[];
type `qztgeom` <double[], double, logical, logical> => double[];
type `qztnbinom` <double[], double, double, logical, logical> => double[];
type `qztpois` <double[], double, logical, logical> => double[];
type `rcomphierarc` <struct<`cohort`:double, `contract`:double[], `year`:double[]> | struct<`entity`:double, `year`:double>, expression, ? expression, double[]> => struct<`data`:list<? double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`cohort`:double, `contract`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`entity`:double, `year`:double[]>, `model.freq`:expression, `model.sev`:null>;
type `rcompound` <double, language, language, logical> => double[];
type `rcomppois` <double, double, language, logical> => double[] | struct<`aggregate`:double[], `frequency`:integer[], `severity`:double[]>;
type `rlogarithmic` <double, double> => integer[];
type `rmixture` <double, double[], expression> => double[];
type `rphtype` <double, double[], ^double[]> => double[];
type `rpoisinvgauss` <double, double, double, double> => integer[];
type `ruin` <character, struct<`prob`:double[], `rates`:^double[]> | struct<`rate`:double[], `w`:double> | struct<`rate`:double[], `weights`:double>, character, struct<`rate`:double[], `weights`:double[]> | struct<`rate`:double>, double, double | language, integer, logical> => any => any;
type `rztnbinom` <double, double, double> => integer[];
type `severity.default` <tuple<integer[], integer[], integer[], integer[]>, logical, logical, ???> => ^integer[];
type `severity.portfolio` <struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<? double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`cohort`:double, `contract`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:null>, character[], ? character | double | logical[], logical, null, ???> => struct<`main`:^double[], `split`:^double[]> | struct<`main`:^double[], `split`:null>;
type `simS` <double, expression, expression> => any => any;
type `simul` <struct<`y`:double> | struct<`data`:double> | struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double> | struct<`contract`:double, `year`:double> | struct<`entity`:double, `year`:double[]> | double, expression, ? expression, ? integer[]> => struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`node`:double, `y`:double>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`node`:double, `data`:double>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`contract`:double, `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:null> | struct<`data`:list<? double[]>, `weights`:^integer[], `classification`:^double[], `nodes`:struct<`entity`:double, `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`node`:double, `X`:double>, `model.freq`:expression, `model.sev`:expression>;
type `summary.aggregateDist` <any => any, ???> => any => any;
type `summary.cm` <struct<`means`:tuple<double, double>, `weights`:tuple<null, integer>, `unbiased`:double[], `iterative`:null, `cred`:double, `nodes`:integer> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `iterative`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `unbiased`:struct<`portfolio`:^double[], `state`:double>, `cred`:double[], `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[], `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `cohort`:double[], `state`:double[]>, `iterative`:double[], `cred`:struct<`cohort`:double[], `state`:double[]>, `nodes`:struct<`cohort`:integer, `state`:integer[]>, `classification`:^double[], `ordering`:struct<`cohort`:integer[], `state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `state`:double[]>, `weights`:struct<`portfolio`:double, `state`:double[]>, `unbiased`:double[], `cred`:double[], `nodes`:struct<`state`:integer>, `classification`:^double[], `ordering`:struct<`state`:integer[]>> | struct<`means`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `weights`:struct<`portfolio`:double, `unit`:double[], `state`:double[]>, `unbiased`:double[], `cred`:struct<`unit`:double[], `state`:double[]>, `nodes`:struct<`unit`:integer, `state`:integer[]>, `classification`:struct<`unit`:integer[], `state`:double[]>, `ordering`:struct<`unit`:integer[], `state`:integer[]>>, ? character, ??? | struct<>, ???> => struct<`means`:tuple<double, double>, `weights`:tuple<null, integer>, `unbiased`:double[], `iterative`:null, `cred`:tuple<double>, `nodes`:integer, `premiums`:tuple<double>> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `iterative`:struct<`portfolio`:^double[], `state`:double>, `cred`:tuple<double[]>, `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>, `premiums`:tuple<double[]>> | struct<`means`:struct<`portfolio`:double[], `state`:^double[]>, `weights`:struct<`portfolio`:^double[], `state`:double[]>, `unbiased`:struct<`portfolio`:^double[], `state`:double>, `cred`:tuple<double[]>, `nodes`:struct<`state`:integer>, `adj.models`:tuple<struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>, struct<`coefficients`:double[], `residuals`:double[], `weights`:double[], `rank`:integer, `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>>>, `transition`:^double[], `terms`:language, `classification`:^double[], `ordering`:struct<`state`:integer[]>, `premiums`:tuple<double[]>> | struct<`means`:struct<`portfolio`:double, `cohort`:double[]>, `weights`:struct<`portfolio`:double, `cohort`:double[]>, `iterative`:double[], `cred`:struct<`cohort`:double[]>, `nodes`:struct<`cohort`:integer>, `classification`:^double[], `ordering`:struct<`cohort`:integer[], `state`:integer[]>, `premiums`:struct<`cohort`:double[]>> | struct<`means`:struct<`portfolio`:double, `state`:double[]>, `weights`:struct<`portfolio`:double, `state`:double[]>, `unbiased`:double[], `cred`:tuple<double[]>, `nodes`:struct<`state`:integer>, `classification`:^double[], `ordering`:struct<`state`:integer[]>, `premiums`:tuple<double[]>> | struct<`means`:struct<`portfolio`:double, `unit`:double[]>, `weights`:struct<`portfolio`:double, `unit`:double[]>, `unbiased`:double[], `cred`:struct<`unit`:double[]>, `nodes`:struct<`unit`:integer>, `classification`:struct<`unit`:integer[]>, `ordering`:struct<`unit`:integer[], `state`:integer[]>, `premiums`:struct<`unit`:double[]>>;
type `summary.elev` <any => any, ???> => double[];
type `summary.ogive` <any => any, ???> => double[];
type `unroll` <list<double[]> | tuple<integer[], integer[]>, logical, logical> => ^double[];
type `VaR.aggregateDist` <any => any, double[], logical, logical, ???> => double[];
type `weights.portfolio` <struct<`data`:list<? double[]>, `weights`:^double[], `classification`:^double[], `nodes`:struct<`cohort`:double, `contract`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<? double[]>, `weights`:^integer[], `classification`:^double[], `nodes`:struct<`entity`:double, `year`:double[]>, `model.freq`:expression, `model.sev`:expression> | struct<`data`:list<double[]>, `weights`:null, `classification`:^double[], `nodes`:struct<`sector`:double, `unit`:double[], `employer`:double[], `year`:double[]>, `model.freq`:expression, `model.sev`:expression>, logical, null, ???> => ? ^double[];
type `x` <double[], logical, logical> => double[];
