type `DEoptim.control` <double, double, logical, null | double, double, double, double, logical, null, double, double, double, double, null, null, double, null, null, null> => struct<`VTR`:double, `strategy`:double, `NP`:double, `itermax`:double, `CR`:double, `F`:double, `bs`:logical, `trace`:logical, `initialpop`:null, `storepopfrom`:double, `storepopfreq`:double, `p`:double, `c`:double, `reltol`:double, `steptol`:double, `parallelType`:double, `cluster`:null, `packages`:null, `parVar`:null, `foreachArgs`:tuple<>> | struct<`VTR`:double, `strategy`:double, `NP`:null, `itermax`:double, `CR`:double, `F`:double, `bs`:logical, `trace`:logical, `initialpop`:null, `storepopfrom`:double, `storepopfreq`:double, `p`:double, `c`:double, `reltol`:double, `steptol`:double, `parallelType`:double, `cluster`:null, `packages`:null, `parVar`:null, `foreachArgs`:tuple<>>;
type `filter` <character[]> => logical[];
type `fun` <character | symbol, character | symbol> => null | struct<`name`:character, `path`:character, `dynamicLookup`:logical, `handle`:null, `info`:null>;
type `plot.DEoptim` <struct<`optim`:struct<`bestmem`:double[], `bestval`:double, `nfeval`:integer, `iter`:integer>, `member`:struct<`lower`:double[], `upper`:double[], `bestmemit`:^double[], `bestvalit`:double[], `pop`:^double[], `storepop`:tuple<>>>, character[], character | null> => null;
type `summary.DEoptim` <struct<`optim`:struct<`bestmem`:double[], `bestval`:double, `nfeval`:integer, `iter`:integer>, `member`:struct<`lower`:double[], `upper`:double[], `bestmemit`:^double[], `bestvalit`:double[], `pop`:^double[], `storepop`:tuple<>>>, null> => struct<`optim`:struct<`bestmem`:double[], `bestval`:double, `nfeval`:integer, `iter`:integer>, `member`:struct<`lower`:double[], `upper`:double[], `bestmemit`:^double[], `bestvalit`:double[], `pop`:^double[], `storepop`:tuple<>>>;
