type `build_W` <^integer[], integer, double, integer[], double[], symbol> => ^double[];
type `calc.groups` <^integer[], character> => struct<`hi`:logical[], `spl.nam`:character>;
type `calc.T11` <double[]> => double;
type `cmlprep` <^double[], double[], double, double[], ^double[] | language, double[]> => struct<`x_mt`:double[], `mt_ind`:integer[], `x_tmt`:struct<`1`:double[], `2`:double[], `3`:double[], `4`:double[], `5`:double[], `6`:double[]>, `rtot`:double, `nrlist`:struct<`1`:double[]>, `gind`:double[], `x_mtlist`:tuple<double[]>, `NAstruc`:struct<`1`:double[]>, `g_NA`:double, `gby`:double[]> | struct<`x_mt`:double[], `mt_ind`:integer[], `x_tmt`:struct<`1`:double[], `2`:double[], `3`:double[], `4`:double[], `5`:double[], `6`:double[], `7`:double[], `8`:double[], `9`:double[], `10`:double[], `11`:double[], `12`:double[]>, `rtot`:double, `nrlist`:struct<`1`:double[], `2`:double[]>, `gind`:integer[], `x_mtlist`:struct<`1`:double[], `2`:double[]>, `NAstruc`:struct<`1`:double[]>, `g_NA`:double, `gby`:double[]> | struct<`x_mt`:double[], `mt_ind`:integer[], `x_tmt`:struct<`1`:double, `2`:double, `3`:double>, `rtot`:double, `nrlist`:struct<`1`:double[]>, `gind`:double[], `x_mtlist`:tuple<double[]>, `NAstruc`:struct<`1`:double[]>, `g_NA`:double, `gby`:double[]>;
type `component.dist` <^double[], character> => struct<`membership`:double[], `csize`:integer, `cdist`:integer[]>;
type `confint.eRm` <struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language> | struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:^logical[], `hessian`:null, `betapar`:double[], `se.beta`:^logical[], `W`:^double[], `call`:language>, character, double, null> => ^double[];
type `covs.prep` <character[], null> => double[];
type `datprep_LLTM` <^double[], null | ^double[], double, double, symbol | logical> => struct<`X`:^double[], `X01`:^double[], `mt_vek`:double[], `W`:^double[]>;
type `datprep_LPCM` <^double[], null | ^double[], double, double[], logical | symbol> => struct<`X`:^double[], `X01`:^double[], `mt_vek`:double[], `W`:^double[]>;
type `datprep_LRSM` <^double[], null, double, double, logical> => struct<`X`:^double[], `X01`:^double[], `mt_vek`:double[], `W`:^double[]>;
type `datprep_PCM` <^double[], null, logical> => struct<`X`:^double[], `X01`:^double[], `mt_vek`:double[], `W`:^double[]>;
type `datprep_RM` <^double[], null, logical> => struct<`X`:^double[], `X01`:^double[], `mt_vek`:double[], `W`:^double[]>;
type `datprep_RSM` <^double[], null, logical> => struct<`X`:^double[], `X01`:^double[], `mt_vek`:double[], `W`:^double[]>;
type `f` <double[]> => double;
type `filter` <character[]> => logical[];
type `fitcml` <integer[], struct<`1`:double[]>, language, double, ^double[], language, double[], tuple<double[]> | struct<`1`:double[], `2`:double[]>, struct<`1`:double[]>, language, logical, double[], language> => struct<`minimum`:double, `estimate`:double[], `gradient`:double[], `code`:integer, `iterations`:integer>;
type `FUN` <struct<> | ^double[] | struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language> | character[] | tuple<integer[]>, integer, integer, double, any => any, null> => ^double[] | struct<``:double, ``:integer, ``:double[], ``:double[], ``:double[], `outobj`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>> | list<integer> | struct<> | character[] | struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language> | tuple<integer[]> | tuple<double[], double[], double[], double[]>;
type `geodist` <^double[], double> => struct<`counts`:^double[], `gdist`:^double[]>;
type `get_item_cats` <^integer[], integer, integer[]> => struct<`1`:double[], `2`:double[], `3`:double[]>;
type `IC.ppar` <struct<`X`:^double[], `X01`:^double[], `X.ex`:^double[], `W`:^double[], `model`:character, `loglik`:double[], `loglik.cml`:double, `npar`:double[], `iter`:double[], `betapar`:double[], `thetapar`:struct<`NAgroup1`:double[], `NAgroup2`:double[]>, `se.theta`:struct<`NAgroup1`:double[], `NAgroup2`:double[]>, `theta.table`:struct<`Person Parameter`:double[], `NAgroup`:integer[], `Interpolated`:logical[]>, `pred.list`:struct<`1`:struct<`x`:double[], `y`:double[]>, `2`:struct<`x`:double[], `y`:double[]>>, `hessian`:tuple<^double[], ^double[]>, `mpoints`:integer, `pers.ex`:integer[], `gmemb`:integer[]> | struct<`X`:^double[], `X01`:^double[], `X.ex`:^double[], `W`:^double[], `model`:character, `loglik`:double, `loglik.cml`:double, `npar`:double, `iter`:double, `betapar`:double[], `thetapar`:struct<`NAgroup1`:double[]>, `se.theta`:struct<`NAgroup1`:double[]>, `theta.table`:struct<`Person Parameter`:double[], `NAgroup`:integer[], `Interpolated`:logical[]>, `pred.list`:struct<`1`:struct<`x`:double[], `y`:double[]>>, `hessian`:tuple<^double[]>, `mpoints`:integer, `pers.ex`:integer, `gmemb`:integer[]>> => struct<`ICtable`:^double[]>;
type `labeling.internal` <character, ^double[], symbol, ^double[], double[], double[], double, language | double> => struct<`W`:^double[], `etapar`:double[], `betapar`:double[]>;
type `llra.datprep` <struct<`V1`:integer[], `V2`:integer[], `V3`:integer[], `V4`:integer[], `V5`:integer[], `V6`:integer[]>, double, character[], null> => struct<`X`:^integer[], `assign.vec`:double[], `grp_n`:integer[], `nitems`:double>;
type `LLTM` <struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[]>, ^double[] | null, double, double, logical, logical, null> => struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `mpoints`:double, `ngroups`:double, `groupvec`:double, `call`:language>;
type `LPCM` <struct<`I1.t1`:double[], `I2.t1`:double[], `I3.t1`:double[], `I1.t2`:double[], `I2.t2`:double[], `I3.t2`:double[]> | ^integer[], null | ^double[], double, double[], logical, logical, null> => struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `mpoints`:double, `ngroups`:double, `groupvec`:double[], `call`:language>;
type `LRSM` <struct<`I1.t1`:double[], `I2.t1`:double[], `I3.t1`:double[], `I1.t2`:double[], `I2.t2`:double[], `I3.t2`:double[]>, null, double, double, logical, logical, null> => struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:^logical[], `hessian`:null, `betapar`:double[], `se.beta`:^logical[], `W`:^double[], `mpoints`:double, `ngroups`:double, `groupvec`:double, `call`:language>;
type `NPtest` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer> | ^double[], null | double, character, null | double[] | character> => struct<`n_eff`:integer, `prop`:double[], `T1mat`:^double[]> | struct<`n_eff`:integer, `prop`:double, `idx`:double[], `gr.nam`:character, `gr.n`:integer, `T4vec`:double[], `alternative`:character> | struct<`n_eff`:integer, `prop`:double, `idx`:double[], `stat`:character, `T2vec`:double[]> | struct<`n_eff`:integer, `prop`:double, `idxt`:double, `idxs`:integer[], `Tpbisvec`:^double[]> | struct<`n_eff`:integer, `prop`:double, `spl.nam`:character, `hi.n`:integer, `low.n`:integer, `T10vec`:integer[]> | struct<`n_eff`:integer, `prop`:double, `T11r`:double[], `T11rho`:double[]>;
type `PCM` <struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[], `I6`:double[], `I7`:double[]> | ^double[], null, logical, logical, null> => struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>;
type `pifit.internal` <struct<`X`:^double[], `X01`:^double[], `X.ex`:^double[], `W`:^double[], `model`:character, `loglik`:double, `loglik.cml`:double, `npar`:double, `iter`:double, `betapar`:double[], `thetapar`:struct<`NAgroup1`:double[]>, `se.theta`:struct<`NAgroup1`:double[]>, `theta.table`:struct<`Person Parameter`:double[], `NAgroup`:integer[], `Interpolated`:logical[]>, `pred.list`:struct<`1`:struct<`x`:double[], `y`:double[]>>, `hessian`:tuple<^double[]>, `mpoints`:integer, `pers.ex`:integer[], `gmemb`:integer[]>> => struct<`Emat`:^double[], `Vmat`:^double[], `Cmat`:^double[]>;
type `plotGOF.LR` <struct<`X`:^double[], `X.list`:struct<`low`:struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[], `I6`:double[], `I7`:double[], `I8`:double[], `I9`:double[], `I10`:double[], `I11`:double[], `I12`:double[], `I13`:double[], `I14`:double[], `I15`:double[], `I16`:double[], `I17`:double[], `I18`:double[], `I19`:double[], `I20`:double[], `I21`:double[], `I22`:double[], `I23`:double[], `I24`:double[], `I25`:double[], `I26`:double[], `I27`:double[], `I28`:double[], `I29`:double[], `I30`:double[]>, `high`:struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[], `I6`:double[], `I7`:double[], `I8`:double[], `I9`:double[], `I10`:double[], `I11`:double[], `I12`:double[], `I13`:double[], `I14`:double[], `I15`:double[], `I16`:double[], `I17`:double[], `I18`:double[], `I19`:double[], `I20`:double[], `I21`:double[], `I22`:double[], `I23`:double[], `I24`:double[], `I25`:double[], `I26`:double[], `I27`:double[], `I28`:double[], `I29`:double[], `I30`:double[]>>, `model`:character, `LR`:double, `df`:integer, `pvalue`:double, `likgroup`:double[], `betalist`:struct<`low`:double[], `high`:double[]>, `etalist`:struct<`low`:double[], `high`:double[]>, `selist`:struct<`low`:double[], `high`:double[]>, `spl.gr`:character[], `call`:language, `fitobj`:struct<`low`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>, `high`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>>>, character | double[], character, null, null, character, double[] | null, null, character, double, null | tuple<>, null | struct<`gamma`:double, `col`:character, `lty`:character>, null, double, logical, logical, logical, logical, null> => null;
type `print.T1obj` <struct<`n_eff`:integer, `prop`:double[], `T1mat`:^double[]>, double, null> => double[];
type `reachability` <^double[], null> => ^double[];
type `RM` <struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[]> | ^double[], null, logical, logical, null> => struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language> | struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:^logical[], `hessian`:null, `betapar`:double[], `se.beta`:^logical[], `W`:^double[], `call`:language>;
type `rsampler` <^double[], struct<`burn_in`:double, `n_eff`:double, `step`:double, `seed`:double, `tfixed`:logical>> => struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>;
type `rsctrl` <double, double, double, double, logical> => struct<`burn_in`:double, `n_eff`:double, `step`:double, `seed`:double, `tfixed`:logical>;
type `rsextrobj` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, double, double> => struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:double, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>;
type `RSM` <struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[], `I6`:double[]>, null, logical, logical, null> => struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>;
type `rstats` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, any => any, null> => struct<`1`:double[], `2`:double[], `3`:double[], `4`:double[], `5`:double[], `6`:double[], `7`:double[], `8`:double[], `9`:double[], `10`:double[], `11`:double[], `12`:double[], `13`:double[], `14`:double[], `15`:double[], `16`:double[], `17`:double[], `18`:double[], `19`:double[], `20`:double[], `21`:double[], `22`:double[], `23`:double[], `24`:double[], `25`:double[], `26`:double[], `27`:double[], `28`:double[], `29`:double[], `30`:double[], `31`:double[], `32`:double[], `33`:double[], `34`:double[], `35`:double[], `36`:double[], `37`:double[], `38`:double[], `39`:double[], `40`:double[], `41`:double[], `42`:double[], `43`:double[], `44`:double[], `45`:double[], `46`:double[], `47`:double[], `48`:double[], `49`:double[], `50`:double[], `51`:double[], `52`:double[], `53`:double[], `54`:double[], `55`:double[], `56`:double[], `57`:double[], `58`:double[], `59`:double[], `60`:double[], `61`:double[], `62`:double[], `63`:double[], `64`:double[], `65`:double[], `66`:double[], `67`:double[], `68`:double[], `69`:double[], `70`:double[], `71`:double[], `72`:double[], `73`:double[], `74`:double[], `75`:double[], `76`:double[], `77`:double[], `78`:double[], `79`:double[], `80`:double[], `81`:double[], `82`:double[], `83`:double[], `84`:double[], `85`:double[], `86`:double[], `87`:double[], `88`:double[], `89`:double[], `90`:double[], `91`:double[], `92`:double[], `93`:double[], `94`:double[], `95`:double[], `96`:double[], `97`:double[], `98`:double[], `99`:double[], `100`:double[], `101`:double[]>;
type `simple_ellipse` <double[], double, double, integer, character> => null;
type `summary.eRm` <struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language> | struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:^logical[], `hessian`:null, `betapar`:double[], `se.beta`:^logical[], `W`:^double[], `call`:language>, null> => null;
type `summary.eRm_SepRel` <struct<`sep.rel`:double, `SSD.PS`:double, `MSE`:double>, null> => null;
type `summary.LR` <struct<`X`:^double[], `X.list`:struct<`1`:struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[], `I6`:double[], `I7`:double[], `I8`:double[], `I9`:double[], `I10`:double[], `I11`:double[], `I12`:double[], `I13`:double[], `I14`:double[], `I15`:double[], `I16`:double[], `I17`:double[], `I18`:double[], `I19`:double[], `I20`:double[], `I21`:double[], `I22`:double[], `I23`:double[], `I24`:double[], `I25`:double[], `I26`:double[], `I27`:double[], `I28`:double[], `I29`:double[], `I30`:double[]>, `2`:struct<`I1`:double[], `I2`:double[], `I3`:double[], `I4`:double[], `I5`:double[], `I6`:double[], `I7`:double[], `I8`:double[], `I9`:double[], `I10`:double[], `I11`:double[], `I12`:double[], `I13`:double[], `I14`:double[], `I15`:double[], `I16`:double[], `I17`:double[], `I18`:double[], `I19`:double[], `I20`:double[], `I21`:double[], `I22`:double[], `I23`:double[], `I24`:double[], `I25`:double[], `I26`:double[], `I27`:double[], `I28`:double[], `I29`:double[], `I30`:double[]>>, `model`:character, `LR`:double, `df`:integer, `pvalue`:double, `likgroup`:double[], `betalist`:struct<`1`:double[], `2`:double[]>, `etalist`:struct<`1`:double[], `2`:double[]>, `selist`:struct<`1`:double[], `2`:double[]>, `spl.gr`:character[], `call`:language, `fitobj`:struct<`1`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>, `2`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>>>, null> => null;
type `summary.MisfittingPersons` <struct<`PersonMisfit`:double, `count.misfit.Z`:integer, `total.persons`:integer>, null> => null;
type `summary.MLoef` <struct<`LR`:double, `df`:double, `p.value`:double, `fullModel`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>, `subModels`:struct<`1`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>, `x`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>, `0`:struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>>, `Lf`:double, `Ls`:struct<`1`:double, `x`:double, `0`:double>, `i.groups`:struct<`1`:integer[], `x`:integer[], `0`:integer[]>, `splitcr`:character[], `split.vector`:character[], `warning`:null, `call`:language>, null> => null;
type `summary.RSmpl` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, null> => null;
type `symmetrize` <^double[], character> => ^double[];
type `T1` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, null> => struct<`n_eff`:integer, `prop`:double[], `T1mat`:^double[]>;
type `T10` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, character, null> => struct<`n_eff`:integer, `prop`:double, `spl.nam`:character, `hi.n`:integer, `low.n`:integer, `T10vec`:integer[]>;
type `T11` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, null> => struct<`n_eff`:integer, `prop`:double, `T11r`:double[], `T11rho`:double[]>;
type `T2` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, double[], character, null | double> => struct<`n_eff`:integer, `prop`:double, `idx`:double[], `stat`:character, `T2vec`:double[]>;
type `T4` <struct<`n`:integer, `k`:integer, `inpmat`:integer[], `tfixed`:logical, `burn_in`:integer, `n_eff`:integer, `step`:integer, `seed`:integer, `n_tot`:double, `outvec`:integer[], `ier`:integer>, double[], logical[], character, null> => struct<`n_eff`:integer, `prop`:double, `idx`:double[], `gr.nam`:character, `gr.n`:integer, `T4vec`:double[], `alternative`:character>;
type `userfunc` <^integer[]> => double[];
type `Waldtest.Rm` <struct<`X`:^double[], `X01`:^double[], `model`:character, `loglik`:double, `npar`:integer, `iter`:integer, `convergence`:integer, `etapar`:double[], `se.eta`:double[], `hessian`:^double[], `betapar`:double[], `se.beta`:double[], `W`:^double[], `call`:language>, integer[]> => struct<`coef.table`:^double[], `betapar1`:double[], `se.beta1`:double[], `betapar2`:double[], `se.beta2`:double[], `spl.gr`:character[], `call`:language, `it.ex`:integer[]>;
