type `.mpfr.gmp.numbbits` < > => integer;
type `.mpfrVersion` < > => character;
type `cbind` <raw[] | character[] | double[], double> => raw[] | ^character[] | ^double[] | list<null>;
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null;
type `FUN` <double | raw[] | character[] | integer[] | tuple<null, null, null, null>, language> => integer[] | character;
type `mpfrVersion` < > => tuple<integer[]>;
type `outer` <double[] | raw[] | list<null>, double[], character | any => any, null> => ^double[] | raw[] | list<null>;
type `pmax` <raw[] | double, logical> => raw[] | double[];
type `pmin` <double | raw[], logical> => double | raw[];
type `rbind` <double[] | character[], double> => ^double[] | ^character[];
type `standardGeneric` <character> => ^double[] | raw[] | ^character[] | list<null>;
type `-` <tuple<> | list<null> | double, null | double[] | tuple<> | list<null>> => tuple<> | list<null>;
type `:::` < > => logical;
type `..bigq2mpfr` <raw[], null, character[]> => tuple<null, null, null>;
type `..bigz2mpfr` <raw[], null | double | integer[], character[]> => tuple<>;
type `.Arith.mpfr.num` <list<null>, double, character> => list<null>;
type `.bigq2mpfr` <raw[], null, character[]> => tuple<null, null, null>;
type `.bigz2mpfr` <raw[], null | double, character[]> => tuple<>;
type `.Compare.mpfr.num` <list<null>, double, character> => logical[];
type `.d2mpfr1` <double> => double;
type `.getPrec` <list<null> | tuple<>> => integer[];
type `.getSign` <list<null> | tuple<>> => integer[];
type `.hjexplore` <double[] | tuple<null, null, null> | list<null>, double[] | tuple<null, null, null> | list<null>, any => any, double, ^double[], double | null | tuple<>> => struct<`x`:double[], `fx`:double, `found`:logical, `numf`:double> | struct<`x`:tuple<null, null, null>, `fx`:tuple<>, `found`:logical, `numf`:double> | struct<`x`:list<null>, `fx`:tuple<>, `found`:logical, `numf`:double>;
type `.hjsearch` <double[] | tuple<null, null, null> | list<null>, any => any, double, ^double[], double | symbol, double | symbol, double | symbol> => struct<`x`:double[], `fx`:double, `found`:logical, `finc`:double> | struct<`x`:tuple<null, null, null>, `fx`:tuple<>, `found`:logical, `finc`:double> | struct<`x`:list<null>, `fx`:tuple<>, `found`:logical, `finc`:double>;
type `.local` <tuple<> | list<null> | double[], null | tuple<> | list<null> | double[] | null | character, double | null | integer[], null | null | tuple<null, null> | tuple<character[], character[]> | logical, double, logical, double, character, integer, character, integer, character, language | character, null, logical, symbol | null> => tuple<> | list<null> | double[] | ^character[];
type `.mA.subAssign` <list<null>, integer | symbol, symbol | double, null, tuple<>, integer, logical> => list<null> | list<null>;
type `.mat2ind` <^logical[], integer[], language> => logical[];
type `.matmult.R` <list<null>, ^integer[], double> => list<null>;
type `.mpfr` <double[], integer> => tuple<> | list<null>;
type `.mpfr.is.whole` <list<null> | tuple<>> => logical[];
type `.mpfr.negative` <tuple<> | list<null>> => tuple<> | list<null>;
type `.mpfr.repl` <tuple<> | list<null>, double | logical[], null, tuple<> | list<null>, logical> => tuple<> | list<null>;
type `.mpfr.sign` <list<null>> => double[];
type `.mpfr2bigz` <tuple<null, null, null>, null> => raw[];
type `.mpfr2str` <list<null> | tuple<>, null | double, logical, double> => struct<`str`:character[], `exp`:integer[], `finite`:logical[], `is.0`:logical[]>;
type `.ncharPrec` <character, double> => integer;
type `.toNum` <list<null>, character> => ^double[];
type `[` <tuple<> | list<null>, integer[] | double | ^logical[], null, null, logical> => tuple<> | list<null>;
type `[.Ncharacter` <^character[], integer[] | null | double> => ^character[];
type `[<-` <list<null> | tuple<> | list<null>, double | null | logical[], null | double, null, double | tuple<> | list<null> | integer[]> => list<null> | list<null> | tuple<>;
type `*` <double[] | tuple<> | list<null>, tuple<> | list<null>> => tuple<> | list<null>;
type `/` <tuple<> | list<null> | double[], double | tuple<> | list<null>> => tuple<> | list<null>;
type `%*%` <list<null>, ^integer[]> => list<null>;
type `^` <tuple<> | list<null> | double, double[] | tuple<> | list<null>> => list<null> | tuple<>;
type `+` <tuple<> | list<null>, double[] | tuple<> | list<null>> => tuple<> | list<null>;
type `<` <list<null> | tuple<>, double | tuple<>> => logical[];
type `<=` <list<null>, double> => logical[];
type `==` <tuple<> | list<null> | double | raw[], double | list<null> | tuple<>> => logical[];
type `>` <list<null> | tuple<>, double> => ^logical[];
type `>=` <tuple<>, tuple<>> => logical;
type `abs` <tuple<> | list<null>> => tuple<> | list<null>;
type `Ai` <double[]> => tuple<> | list<null>;
type `all.equal` <double[] | tuple<> | list<null>, list<null> | tuple<> | double[], null | double> => logical | character;
type `all.equal.numeric` <tuple<> | list<null>, tuple<> | list<null>, double, null, null, logical> => character | logical;
type `as.data.frame.Ncharacter` <^character[], logical> => struct<>;
type `as.double` <null, null> => double[];
type `as.integer` <null, null> => integer[];
type `as.numeric` <null, null> => double[];
type `as.vector` <null, null> => list<null>;
type `asMethod` <tuple<> | list<null> | raw[] | double[], symbol | character, list<null> | logical> => list<null> | tuple<>;
type `asNumeric` <list<null>> => ^double[];
type `Bernoulli` <double[], double> => tuple<> | list<null>;
type `c.mpfr` <tuple<> | list<null>> => tuple<> | list<null>;
type `chooseMpfr` <double | integer[] | tuple<>, integer[] | double, character[]> => tuple<> | list<null>;
type `chooseMpfr.all` <double, null, double, logical> => tuple<null, null> | list<null>;
type `Const` <character, double[], character[]> => tuple<>;
type `cumprod` <tuple<> | list<null>> => tuple<> | list<null>;
type `dbinom` <integer[], double, double | tuple<>, logical> => double[] | list<null>;
type `dim` <null> => integer[];
type `dim<-` <null, null> => list<null>;
type `dimnames` <null> => tuple<character[], character[]> | tuple<null, null>;
type `dnorm` <integer[] | list<null>, double, double, logical> => double[] | list<null>;
type `dpois` <double[] | list<null>, double | tuple<>, logical> => double[] | list<null>;
type `exp` <tuple<> | list<null>> => tuple<> | list<null>;
type `f` <double[] | tuple<null, null, null> | list<null>> => double | tuple<>;
type `factorial` <tuple<> | list<null>> => tuple<> | list<null>;
type `factorialMpfr` <double | integer[], double, character[]> => tuple<> | list<null>;
type `floor` <tuple<> | list<null>> => tuple<> | list<null>;
type `format` <list<null> | tuple<>, null | double | null> => ^character[];
type `formatAlign` <character[], character, character, null> => character[];
type `formatBin` <list<null>, integer, logical, character, symbol | character, character, logical> => ^character[];
type `formatDec` <list<null>, double, double, null, logical, character, logical, null> => ^character[];
type `formatHex` <list<null>, integer, character, logical | symbol> => ^character[];
type `formatMpfr` <tuple<>, null | double, logical, null, double, logical, double, character, integer, character, integer, character, language, null, logical, language | null> => character[];
type `formatN.mpfr` <tuple<null, null, null, null>, logical, double> => character[];
type `gamma` <tuple<> | list<null>> => tuple<> | list<null>;
type `getD` <list<null> | tuple<> | list<null> | ^logical[]> => list<null> | tuple<> | list<null> | logical[];
type `getPrec` <character | list<null> | double | ^integer[] | tuple<>, double, logical, null, integer> => double | integer[];
type `hjkMpfr` <double[] | tuple<null, null, null>, any => any, struct<`info`:logical>, null> => struct<`par`:double[], `value`:double, `convergence`:logical, `feval`:double, `niter`:double> | struct<`par`:tuple<null, null, null>, `value`:tuple<>, `convergence`:logical, `feval`:double, `niter`:double>;
type `initialize` <tuple<>, list<null> | null> => list<null> | tuple<>;
type `is.finite` <null> => ^logical[];
type `is.infinite` <null> => ^logical[];
type `is.na` <null> => logical[];
type `is.whole.mpfr` <list<null> | tuple<>> => logical[];
type `j1` <double[]> => list<null>;
type `jn` <double, double[], character[]> => list<null>;
type `log` <list<null>, null> => list<null>;
type `mean` <tuple<> | list<null>, null> => tuple<>;
type `mpfr.Bcharacter` <^character[], integer, null, null> => list<null>;
type `mpfr.default` <null | ^double[] | ^character[], null | double[], double, character[], null, null> => tuple<> | list<null>;
type `mpfr.Ncharacter` <^character[], integer, null> => list<null>;
type `mpfr2array` <list<null>, integer[], null, logical> => list<null>;
type `mpfrIs0` <list<null> | tuple<>> => ^logical[];
type `patch` <character[], integer[]> => character[];
type `pochMpfr` <double | integer[] | list<null>, double, character[]> => tuple<> | list<null>;
type `print.mpfr` <list<null>, null, logical, logical, integer, null> => list<null>;
type `prod` <list<null>, null, logical> => tuple<>;
type `rep.mpfr` <tuple<>, double, null, double, null> => tuple<null, null, null>;
type `rint` <tuple<> | list<null>> => tuple<> | list<null>;
type `round` <tuple<> | list<null>, null> => tuple<> | list<null>;
type `roundMpfr` <tuple<> | list<null>, double, character[]> => tuple<> | list<null>;
type `seqMpfr` <double | tuple<>, tuple<>, language | tuple<>, double, null, null> => tuple<> | list<null>;
type `sign` <list<null> | tuple<>> => ^double[];
type `sprintfMpfr` <list<null>, integer, character, symbol, logical> => character[];
type `sqrt` <tuple<>> => tuple<>;
type `str.mpfr` <tuple<>, double, logical, logical, integer, integer, logical, integer, language> => null;
type `sum` <tuple<> | list<null>, null, logical> => tuple<>;
type `toNum` <list<null>, character> => ^double[];
type `trunc` <tuple<null, null, null>> => tuple<null, null, null>;
type `validityMethod` <list<null>> => logical;
type `y0` <double[]> => list<null>;
type `yn` <double, double[], character[]> => list<null>;
type `zeta` <tuple<> | list<null> | double[]> => tuple<> | list<null>;
