type `Ai` <double[]> => class<`mpfr`>;
type `all.equal` <double[], class<`mpfr`>, ...> => logical | <class<`mpfr`>, class<`mpfr`>, ...> => (character | logical) | <class<`mpfrMatrix`>, class<`matrix`>, ...> => logical | <class<`mpfr`>, double[], ...> => (character | logical) | <class<`mpfrMatrix`>, class<`mpfrMatrix`>, ...> => logical | <class<`mpfrArray`>, class<`mpfrArray`>, ...> => logical;
type `aperm` <class<`mpfrMatrix`>, integer[], ...> => class<`mpfrMatrix`> | <class<`mpfrArray`>, any, ...> => class<`mpfrArray`>;
type `aperm.mpfrArray` <class<`mpfrMatrix`>, integer[], logical, ...> => class<`mpfrMatrix`>;
type `apply` <class<`mpfrMatrix`>, double, class<`function`>, ...> => (class<`mpfr`> | class<`mpfrMatrix`>) | <class<`mpfrArray`>, integer[] | double, class<`function`> | class<`standardGeneric`>, ...> => (class<`mpfrArray`> | class<`mpfrMatrix`>);
type `applyMpfr` <class<`mpfrArray`> | class<`mpfrMatrix`>, integer[], class<`function`> | class<`standardGeneric`>, ...> => (class<`mpfr`> | class<`mpfrMatrix`>);
type `.Arith.mpfr.num` <class<`mpfrMatrix`>, double[], character> => list<class<`mpfr1`>>;
type `.Arith.num.mpfr` <class<`matrix`> | class<`array`> | double, class<`mpfrMatrix`> | class<`mpfr`>, character> => list<class<`mpfr1`>>;
type `as.data.frame.Ncharacter` <class<`Ncharacter`, `character`>, ...> => class<`data.frame`>;
type `as.matrix.mpfr` <class<`mpfrMatrix`>, ...> => class<`mpfrMatrix`>;
type `atan2` <class<`mpfr`>, integer[]> => class<`mpfr`>;
type `Bernoulli` <double[], double> => class<`mpfr`>;
type `.bigq2mpfr` <class<`bigq`>, null, character[]> => class<`mpfr`>;
type `..bigq2mpfr` <class<`bigq`>, double | null, character[]> => class<`mpfr`>;
type `.bigz2mpfr` <class<`bigz`>, double | null, character[]> => class<`mpfr`>;
type `..bigz2mpfr` <class<`bigz`>, double | integer[] | null, character[]> => any;
type `cbind` <..., double> => class<`mpfrMatrix`> | <..., double> => class<`matrix`> | <..., double> => class<`matrix`> | <..., double> => any | <..., double> => class<`matrix`> | <..., double> => class<`mpfrMatrix`> | <..., double> => class<`matrix`> | <..., double> => any | <..., double> => class<`matrix`> | <..., double> => class<`matrix`> | <..., double> => class<`mpfrMatrix`>;
type `chooseMpfr` <class<`mpfr`> | double | integer[], integer[] | double, character[]> => class<`mpfr`>;
type `chooseMpfr.all` <double, null, double, logical> => class<`mpfr`>;
type `c.mpfr` <...> => class<`mpfr`>;
type `colMeans` <class<`mpfrMatrix`>, logical, double, ...> => class<`mpfr`>;
type `colSums` <class<`mpfrMatrix`>, logical, double, ...> => class<`mpfr`>;
type `.Compare.mpfr.num` <class<`mpfrArray`> | class<`mpfrMatrix`>, double | class<`matrix`>, character> => logical[];
type `.Compare.num.mpfr` <class<`matrix`> | double, class<`mpfrMatrix`> | class<`mpfrArray`>, character> => logical[];
type `Const` <character, double[], character[]> => any;
type `crossprod` <class<`mpfr`>, null> => class<`mpfrMatrix`> | <class<`mpfrMatrix`>, null> => class<`mpfrMatrix`> | <class<`mpfrMatrix`>, class<`mpfrMatrix`>> => class<`mpfrMatrix`> | <integer[], class<`mpfrMatrix`>> => class<`mpfrMatrix`>;
type `.d2mpfr1` <double, double> => class<`mpfr1`>;
type `dbinom` <integer[], double, class<`mpfr`> | double, logical> => (class<`mpfr`> | double[]);
type `determinant.mpfrMatrix` <class<`mpfrMatrix`>, logical, logical, any, ...> => class<`det`>;
type `diff.mpfr` <class<`mpfr`>, integer, integer, ...> => class<`mpfr`>;
type `.dimCheck` <class<`matrix`> | class<`mpfrMatrix`>, class<`mpfrMatrix`> | class<`matrix`>> => integer[];
type `dnorm` <class<`mpfr`> | integer[], double, double, logical> => (class<`mpfr`> | double[]);
type `dpois` <class<`mpfr`> | double[], double | class<`mpfr`>, logical> => (class<`mpfr`> | double[]);
type `Ei` <double[]> => class<`mpfr`>;
type `erf` <double[]> => double[];
type `erfc` <double[]> => double[];
type `factorial` <class<`mpfr`>> => class<`mpfr`>;
type `factorialMpfr` <double | integer[], double, character[]> => class<`mpfr`>;
type `format` <class<`mpfrMatrix`>, ...> => class<`matrix`> | <class<`mpfr`>, ...> => character[];
type `formatAlign` <character[], character, any, ...> => character[];
type `formatBin` <class<`mpfr`> | double[] | class<`matrix`> | class<`mpfrMatrix`>, double, logical, character, any, character, logical> => class<`Ncharacter`, `character`>;
type `formatDec` <class<`mpfr`> | double[] | class<`matrix`> | class<`mpfrMatrix`>, double, double, null, logical, character, logical, ...> => class<`Ncharacter`, `character`>;
type `formatHex` <class<`mpfr`> | double[] | class<`matrix`> | class<`mpfrMatrix`>, any, character, any> => class<`Ncharacter`, `character`>;
type `formatMpfr` <class<`mpfr`> | class<`mpfrArray`>, double | null, logical, null | logical, logical, double, logical, double> => (character[] | class<`array`>);
type `formatN.mpfr` <class<`mpfr`>, logical, ...> => character[];
type `getD` <class<`mpfr`> | class<`mpfrMatrix`> | class<`mpfrArray`> | list<class<`mpfr1`>> | class<`matrix`>> => (list<any> | logical[]);
type `getPrec` <character[] | class<`mpfr`> | class<`mpfrMatrix`> | class<`matrix`> | double[] | raw[], any, logical, null, integer> => double[];
type `.getPrec` <class<`mpfr`> | class<`mpfrArray`> | class<`mpfrMatrix`> | list<class<`mpfr1`>>> => integer[];
type `.getSign` <class<`mpfr`>> => integer[];
type `igamma` <class<`mpfr`>, double[], character[]> => class<`mpfr`>;
type `integrateR` <class<`function`>, class<`mpfr`> | double, double | class<`mpfr`>, ..., double | null, double, any, double> => class<`integrate`, `integrateR`>;
type `is.whole.mpfr` <class<`mpfr`>> => logical[];
type `j1` <double[]> => class<`mpfr`>;
type `jn` <double, double[], character[]> => class<`mpfr`>;
type `Li2` <double[]> => class<`mpfr`>;
type `.mA.subAssign` <class<`mpfrArray`> | class<`mpfrMatrix`>, any, any, ..., class<`mpfr`> | class<`mpfrMatrix`> | double, integer, logical> => (class<`mpfrArray`> | class<`mpfrMatrix`>);
type `.mat2ind` <class<`matrix`>, integer[], any> => double[];
type `.matmult.R` <class<`mpfr`> | class<`mpfrMatrix`> | integer[], class<`matrix`> | class<`mpfr`> | class<`mpfrMatrix`> | double[], double> => class<`mpfrMatrix`>;
type `matrix.mpfr` <class<`mpfr`>, double, double, logical, ...> => class<`mpfrMatrix`>;
type `mean` <class<`mpfr`>, ...> => class<`mpfr`>;
type `mkDet` <class<`mpfr`>, logical, class<`mpfr`>, integer> => class<`det`>;
type `mpfr` <character[] | class<`bigq`> | class<`bigz`> | class<`mpfr`> | class<`Ncharacter`, `character`> | ^double[] | null | raw[] | class<`matrix`>, any, ...> => any;
type `.mpfr` <double[], integer> => class<`mpfr`>;
type `mpfr2array` <class<`mpfr`> | class<`mpfrArray`> | class<`mpfrMatrix`>, double[], null | list<character[]>, logical> => (class<`mpfrArray`> | class<`mpfrMatrix`>);
type `.mpfr2bigz` <class<`mpfr`>, null> => class<`bigz`>;
type `.mpfr2exp` <class<`mpfr`>> => double[];
type `.mpfr2list` <class<`mpfr`>, logical> => list<list<^integer[]>>;
type `.mpfr2str` <class<`mpfr`> | class<`mpfrArray`> | class<`mpfrMatrix`>, null | double, logical, double> => (list<character[] | double[]> | list<character[] | integer[]> | list<character | integer>);
type `mpfrArray` <integer[] | null, double, double[], null | list<null | character[]>, character[]> => (class<`mpfrArray`> | class<`mpfrMatrix`>);
type `mpfr.Bcharacter` <character[] | class<`matrix`>, double, logical | null, ...> => (class<`mpfr`> | class<`mpfrMatrix`>);
type `mpfr.bigq` <class<`bigq`>, double, ...> => class<`mpfr`>;
type `mpfr.bigz` <class<`bigz`>, any, ...> => any;
type `mpfr.default` <character[] | ^double[] | null | raw[] | class<`matrix`>, any, double, character[], null, ...> => any;
type `mpfr_default_prec` <any> => integer;
type `.mpfr_erange` <character[], logical> => double[];
type `.mpfr_erange_is_int` < > => logical;
type `.mpfr_erange_set` <character, double> => integer;
type `.mpfr_formatinfo` <class<`mpfr`>> => list<integer[]>;
type `.mpfr_gmp_numbbits` < > => integer;
type `mpfrImport` <class<`mpfrXport`>> => class<`mpfr`>;
type `mpfr.is.0` <class<`mpfr`>> => logical[];
type `mpfrIs0` <class<`mpfrArray`> | class<`mpfrMatrix`> | class<`mpfr`>> => (class<`array`> | class<`matrix`> | logical[]);
type `mpfr.is.integer` <class<`mpfr`>> => logical[];
type `.mpfr.is.whole` <class<`mpfr`>> => logical[];
type `.mpfr_maxPrec` < > => double;
type `.mpfr_minPrec` < > => double;
type `mpfr.mpfr` <class<`mpfr`>, double | integer[], character[], ...> => class<`mpfr`>;
type `.mpfr.mrepl` <class<`mpfrArray`> | class<`mpfrMatrix`>, class<`matrix`>, ..., class<`mpfr`>, logical> => (class<`mpfrArray`> | class<`mpfrMatrix`>);
type `mpfr.Ncharacter` <class<`Ncharacter`, `character`>, double, ...> => (class<`mpfr`> | class<`mpfrMatrix`>);
type `.mpfr_negative` <class<`mpfr`> | class<`mpfrMatrix`>> => (class<`mpfr`> | class<`mpfrMatrix`>);
type `mpfr.NULL` <null, ...> => class<`mpfr`>;
type `.mpfr.repl` <class<`mpfr`>, any, ..., class<`mpfr`>, logical> => class<`mpfr`>;
type `.mpfr_sign` <class<`mpfrArray`> | class<`mpfrMatrix`>> => double[];
type `mpfrVersion` < > => class<`numeric_version`>;
type `.mpfrVersion` < > => character;
type `mpfrXport` <class<`mpfr`>, logical> => class<`mpfrXport`>;
type `[.Ncharacter` <class<`Ncharacter`, `character`>, ...> => class<`Ncharacter`, `character`>;
type `.ncharPrec` <character[], double> => integer[];
type `norm` <class<`mpfrMatrix`>, character, ...> => class<`mpfr`> | <class<`mpfrMatrix`>, any, ...> => class<`mpfr`>;
type `outer` <double[] | class<`mpfr`>, double[], character, ...> => (class<`matrix`> | class<`mpfrMatrix`>);
type `pbetaI` <double[], double, double, double, logical, logical, double | null, character[]> => class<`mpfr`>;
type `pmax` <..., logical> => (class<`matrix`> | class<`mpfr`> | double[]) | <..., logical> => double[] | <..., logical> => class<`mpfr`> | <..., logical> => integer[];
type `pmin` <..., logical> => double[] | <..., logical> => (class<`matrix`> | class<`mpfr`> | double[]) | <..., logical> => class<`mpfr`> | <..., logical> => double | <..., logical> => class<`mpfr`>;
type `pnorm` <double[], double, double, logical, logical> => double[];
type `pochMpfr` <class<`mpfr`> | double | integer[], double, character[]> => class<`mpfr`>;
type `print.mpfr` <class<`mpfr`>, null, logical, logical, any, any, ...> => class<`mpfr`>;
type `print.mpfrArray` <class<`mpfrArray`>, null, logical, logical, integer, any, ...> => class<`mpfrArray`>;
type `print.Ncharacter` <class<`Ncharacter`, `character`>, ...> => class<`Ncharacter`, `character`>;
type `rbind` <..., double> => class<`mpfrMatrix`> | <..., double> => class<`matrix`> | <..., double> => class<`matrix`> | <..., double> => class<`mpfrMatrix`> | <..., double> => (class<`matrix`> | class<`mpfrMatrix`>);
type `rep.mpfr` <class<`mpfr`>, double, null, double, ...> => class<`mpfr`>;
type `roundMpfr` <class<`mpfr`>, double | integer[], character[]> => class<`mpfr`>;
type `rowSums` <class<`mpfrMatrix`>, logical, double, ...> => class<`mpfr`>;
type `sapplyMpfr` <integer[], class<`function`>, ...> => class<`mpfr`>;
type `scale.mpfrMatrix` <class<`mpfrMatrix`>, logical, logical> => class<`mpfrMatrix`>;
type `seqMpfr` <class<`mpfr`> | double, class<`mpfr`> | double, any, double | null | class<`mpfr`>, null, ...> => class<`mpfr`>;
type `sprintfMpfr` <class<`mpfr`> | class<`mpfrMatrix`>, double, character, any, logical> => character[];
type `str.mpfr` <class<`mpfr`>, any, logical, logical, double | null, integer | null, logical, any> => null;
type `sumBinomMpfr` <double, class<`function`>, double, logical, double, class<`mpfr`>> => class<`mpfr`>;
type `summary` <class<`mpfr`>, ...> => class<`summaryMpfr`>;
type `t` <class<`mpfrMatrix`>> => class<`mpfrMatrix`> | <class<`mpfr`>> => class<`mpfrMatrix`>;
type `tcrossprod` <integer[], class<`mpfrMatrix`>> => class<`mpfrMatrix`> | <integer[], class<`mpfr`>> => class<`mpfrMatrix`> | <class<`mpfr`>, null> => class<`mpfrMatrix`> | <class<`mpfrMatrix`>, class<`mpfrMatrix`>> => class<`mpfrMatrix`>;
type `toNum` <class<`mpfrArray`> | class<`mpfrMatrix`> | class<`mpfr`>, character> => (class<`array`> | class<`matrix`> | double);
type `.toNum` <class<`mpfrArray`> | class<`mpfrMatrix`> | class<`mpfr`>, character> => (class<`array`> | class<`matrix`> | double);
type `unique` <class<`mpfr`>, logical, ...> => class<`mpfr`>;
type `unique.mpfr` <class<`mpfr`>, logical, ...> => class<`mpfr`>;
type `unlistMpfr` <list<class<`mpfr`>>, logical, logical> => class<`mpfr`>;
type `y0` <double[]> => class<`mpfr`>;
type `yn` <double, double[], character[]> => class<`mpfr`>;
type `zeta` <class<`mpfr`> | double[]> => class<`mpfr`>;
