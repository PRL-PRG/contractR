type `^` <class<`mpfr`>, integer[]> => class<`mpfr`> | <class<`mpfr`>, double[]> => class<`mpfr`> | <double[], class<`mpfr`>> => class<`mpfr`> | <class<`mpfr`>, class<`mpfr`>> => class<`mpfr`>;
type `<` <class<`mpfr`>, double> => ^logical[] | <class<`mpfr`>, integer> => logical[];
type `<=` <class<`mpfr`>, double> => ^logical[];
type `==` <class<`mpfr`>, double> => ^logical[] | <class<`mpfr`>, class<`mpfr`>> => logical[] | <double, class<`mpfr`>> => logical | <class<`bigz`>, class<`mpfr`>> => logical[];
type `>` <class<`mpfr`>, double> => ^logical[] | <class<`mpfrMatrix`>, double> => class<`matrix`>;
type `-` <class<`mpfr`>, integer[]> => class<`mpfr`> | <class<`mpfr`>, double[]> => class<`mpfr`> | <double[], class<`mpfr`>> => class<`mpfr`> | <class<`mpfr`>, class<`mpfr`>> => class<`mpfr`> | <class<`mpfr`>, any> => class<`mpfr`>;
type `:::` < > => logical;
type `/` <class<`mpfr`>, integer[]> => class<`mpfr`> | <class<`mpfr`>, double[]> => class<`mpfr`> | <double[], class<`mpfr`>> => class<`mpfr`> | <class<`mpfr`>, class<`mpfr`>> => class<`mpfr`> | <class<`mpfrMatrix`>, double> => class<`mpfrMatrix`>;
type `[` <class<`mpfr`>, logical[], any, ..., logical> => class<`mpfr`> | <class<`mpfr`>, integer[], any, ..., logical> => class<`mpfr`> | <class<`mpfr`>, double, any, ..., logical> => class<`mpfr`> | <class<`mpfrMatrix`>, logical[], any, ..., logical> => class<`mpfr`> | <class<`mpfrMatrix`>, class<`matrix`>, any, ..., logical> => class<`mpfr`>;
type `[<-` <class<`mpfrMatrix`>, any, double, ..., class<`mpfr`>> => class<`mpfrMatrix`> | <class<`mpfr`>, double, any, ..., double> => class<`mpfr`> | <class<`mpfrMatrix`>, integer, any, ..., class<`mpfr`>> => class<`mpfrMatrix`> | <class<`mpfr`>, logical[], any, ..., class<`mpfr`>> => class<`mpfr`> | <class<`mpfr`>, logical[], any, ..., integer[]> => class<`mpfr`>;
type `*` <double[], class<`mpfr`>> => class<`mpfr`> | <class<`mpfr`>, class<`mpfr`>> => class<`mpfr`> | <integer[], class<`mpfr`>> => class<`mpfr`>;
type `%*%` <class<`mpfr`>, class<`matrix`>> => class<`mpfrMatrix`>;
type `+` <class<`mpfr`>, double[]> => class<`mpfr`> | <class<`mpfr`>, class<`mpfr`>> => class<`mpfr`>;
type `abs` <class<`mpfr`>> => class<`mpfr`>;
type `Ai` <double[]> => class<`mpfr`>;
type `all.equal` <double[], class<`mpfr`>, ...> => logical | <class<`mpfr`>, class<`mpfr`>, ...> => (character | logical) | <class<`mpfr`>, double[], ...> => logical | <class<`mpfrMatrix`>, class<`mpfrMatrix`>, ...> => logical;
type `all.equal.numeric` <class<`mpfr`> | class<`mpfrMatrix`>, class<`mpfr`> | class<`mpfrMatrix`>, double, null, ..., logical> => (character | logical);
type `.Arith.mpfr.num` <class<`mpfrMatrix`>, double, character> => list<class<`mpfr1`>>;
type `as.data.frame.Ncharacter` <class<`Ncharacter`, `character`>, ...> => class<`data.frame`>;
type `as.double` <any, ...> => double[] | <any, ...> => double[];
type `as.integer` <any, ...> => integer[];
type `asMethod` <class<`mpfrMatrix`>, any, list<class<`mpfr1`>>> => class<`mpfrMatrix`> | <class<`mpfrMatrix`>, character, logical> => class<`mpfrArray`> | <class<`mpfrMatrix`>, character, logical> => class<`mpfr`> | <class<`bigq`>, character, logical> => class<`mpfr`> | <integer[], character, logical> => class<`mpfr`> | <class<`mpfrArray`>, any, list<class<`mpfr1`>>> => class<`mpfrArray`> | <double[], character, logical> => class<`mpfr`> | <class<`mpfrArray`>, character, logical> => class<`mpfr`>;
type `as.numeric` <any, ...> => double[];
type `asNumeric` <class<`mpfr`>> => double[] | <class<`mpfrMatrix`>> => class<`matrix`>;
type `as.vector` <any, any> => class<`mpfr`>;
type `Bernoulli` <double[], double> => class<`mpfr`>;
type `.bigq2mpfr` <class<`bigq`>, null, character[]> => class<`mpfr`>;
type `..bigq2mpfr` <class<`bigq`>, null, character[]> => class<`mpfr`>;
type `.bigz2mpfr` <class<`bigz`>, double | null, character[]> => class<`mpfr`>;
type `..bigz2mpfr` <class<`bigz`>, double | integer[] | null, character[]> => class<`mpfr`>;
type `cbind` <..., double> => class<`matrix`> | <..., double> => (class<`matrix`> | class<`mpfrMatrix`>) | <..., double> => class<`matrix`> | <..., double> => class<`mpfrMatrix`>;
type `chooseMpfr` <class<`mpfr`> | double | integer[], integer[] | double, character[]> => class<`mpfr`>;
type `chooseMpfr.all` <double, null, double, logical> => class<`mpfr`>;
type `c.mpfr` <...> => class<`mpfr`>;
type `.Compare.mpfr.num` <class<`mpfrMatrix`>, double, character> => logical[];
type `Const` <character, double[], character[]> => class<`mpfr`>;
type `cumprod` <class<`mpfr`>> => class<`mpfr`>;
type `.d2mpfr1` <double, double> => class<`mpfr1`>;
type `dbinom` <integer[], double, class<`mpfr`> | double, logical> => (class<`mpfr`> | double[]);
type `dim` <any> => integer[];
type `dim<-` <any, any> => class<`mpfrMatrix`>;
type `dimnames` <any> => list<character[] | null>;
type `dnorm` <class<`mpfr`> | integer[], double, double, logical> => (class<`mpfr`> | double[]);
type `dpois` <class<`mpfr`> | double[], double | class<`mpfr`>, logical> => (class<`mpfr`> | double[]);
type `exp` <class<`mpfr`>> => class<`mpfr`>;
type `factorial` <class<`mpfr`>> => class<`mpfr`>;
type `factorialMpfr` <double | integer[], double, character[]> => class<`mpfr`>;
type `filter` <character[]> => logical[];
type `floor` <class<`mpfr`>> => class<`mpfr`>;
type `format` <class<`mpfrMatrix`>, ...> => class<`matrix`> | <class<`mpfr`>, ...> => character[];
type `formatAlign` <character[], character, character, ...> => character[];
type `formatBin` <class<`mpfr`> | class<`mpfrMatrix`>, integer, logical, character, any, character, logical> => class<`Ncharacter`, `character`>;
type `formatDec` <class<`mpfr`> | class<`mpfrMatrix`>, double, double, null, logical, character, logical, ...> => class<`Ncharacter`, `character`>;
type `formatHex` <class<`mpfr`> | class<`mpfrMatrix`>, integer, character, any> => class<`Ncharacter`, `character`>;
type `formatMpfr` <class<`mpfr`> | class<`mpfrMatrix`>, double | null, logical, null | logical, logical, double, logical, double, character, integer, character, integer> => (character[] | class<`matrix`>);
type `formatN.mpfr` <class<`mpfr`>, logical, ...> => character[];
type `fun` <any, any> => null | <any, any> => null;
type `FUN` <character[]> => character | <double | integer[], any> => logical | <class<`mpfr`> | double | integer[]> => integer | <class<`mpfr`> | double | integer[]> => integer;
type `gamma` <class<`mpfr`>> => class<`mpfr`>;
type `getD` <class<`mpfr`> | class<`mpfrMatrix`> | class<`matrix`>> => (logical[] | list<class<`mpfr1`> | class<`mpfr1`> | null | null>);
type `getPrec` <character | class<`mpfr`> | class<`mpfrMatrix`> | class<`matrix`> | double | integer[], double, logical, null, integer> => (double | integer[]);
type `.getPrec` <class<`mpfr`>> => integer[];
type `.getSign` <class<`mpfr`>> => integer[];
type `initialize` <class<`mpfrMatrix`>, ...> => class<`mpfrMatrix`> | <class<`mpfrMatrix`>, ...> => class<`mpfrMatrix`>;
type `is.finite` <any> => logical[] | <any> => class<`matrix`>;
type `is.infinite` <any> => logical[] | <any> => class<`matrix`>;
type `is.na` <any> => logical[];
type `is.whole.mpfr` <class<`mpfr`>> => logical[];
type `j1` <double[]> => class<`mpfr`>;
type `jn` <double, double[], character[]> => class<`mpfr`>;
type `lFormat` <class<`mpfr`>, any, any, any, any, ...> => character[];
type `.local` <class<`mpfr`> | class<`mpfrMatrix`>, double | null, logical, null | logical, logical, double, logical, double, character, integer, character, integer> => (character[] | class<`matrix`>) | <class<`mpfr`> | class<`mpfrMatrix`>, class<`mpfr`> | class<`mpfrMatrix`>, double, ...> => (character | logical) | <class<`mpfr`>, double[], double, ...> => logical | <class<`mpfrMatrix`>, ..., any, any> => class<`mpfrMatrix`> | <class<`mpfrMatrix`>> => class<`mpfr`> | <class<`mpfr`>, character> => integer[] | <class<`mpfr`> | class<`mpfrMatrix`>, character> => double[] | <class<`mpfr`>, any> => class<`mpfr`> | <class<`mpfr`>, double, logical, ...> => class<`mpfr`> | <double[], class<`mpfr`>, double, ...> => logical;
type `log` <class<`mpfr`>, ...> => class<`mpfr`>;
type `.mA.subAssign` <class<`mpfrMatrix`>, any, any, ..., class<`mpfr`>, integer, logical> => class<`mpfrMatrix`>;
type `.mat2ind` <class<`matrix`>, integer[], any> => logical[];
type `.matmult.R` <class<`mpfr`>, class<`matrix`>, double> => class<`mpfrMatrix`>;
type `mean` <class<`mpfr`>, ...> => class<`mpfr`>;
type `mpfr` <character | ^double[] | null | class<`matrix`> | class<`Ncharacter`, `character`>, any, ...> => (class<`mpfr`> | class<`mpfrMatrix`>);
type `.mpfr` <double[], integer> => class<`mpfr`>;
type `mpfr2array` <class<`mpfrMatrix`>, integer[], null, logical> => class<`mpfrMatrix`>;
type `.mpfr2bigz` <class<`mpfr`>, null> => class<`bigz`>;
type `.mpfr2str` <class<`mpfr`> | class<`mpfrMatrix`>, double | null, logical, double> => list<character[] | integer[] | character | integer>;
type `mpfr.Bcharacter` <class<`matrix`>, integer, null, ...> => class<`mpfrMatrix`>;
type `mpfr.default` <character | ^double[] | null | class<`matrix`>, any, double, character[], null, ...> => (class<`mpfr`> | class<`mpfrMatrix`>);
type `.mpfr_gmp_numbbits` < > => integer;
type `mpfrIs0` <class<`mpfrMatrix`> | class<`mpfr`>> => (class<`matrix`> | logical[]);
type `.mpfr.is.whole` <class<`mpfr`>> => logical[];
type `mpfr.Ncharacter` <class<`Ncharacter`, `character`>, integer, ...> => class<`mpfrMatrix`>;
type `.mpfr_negative` <class<`mpfr`>> => class<`mpfr`>;
type `.mpfr.repl` <class<`mpfr`>, double | logical[], ..., class<`mpfr`>, logical> => class<`mpfr`>;
type `.mpfr_sign` <class<`mpfrMatrix`>> => double[];
type `mpfrVersion` < > => class<`numeric_version`>;
type `.mpfrVersion` < > => character;
type `[.Ncharacter` <class<`Ncharacter`, `character`>, ...> => class<`Ncharacter`, `character`>;
type `.ncharPrec` <character, double> => integer;
type `outer` <class<`mpfr`>, integer[], character, ...> => class<`mpfrMatrix`>;
type `patch` <character[], integer[]> => character[];
type `pmax` <..., logical> => double[] | <..., logical> => double[] | <..., logical> => integer[];
type `pochMpfr` <class<`mpfr`> | double | integer[], double, character[]> => class<`mpfr`>;
type `print.mpfr` <class<`mpfr`>, null, logical, logical, integer, logical, ...> => class<`mpfr`>;
type `prod` <class<`mpfr`>, ..., logical> => class<`mpfr`>;
type `rbind` <..., double> => class<`matrix`> | <..., double> => class<`matrix`>;
type `rint` <class<`mpfr`>> => class<`mpfr`>;
type `round` <class<`mpfr`>, any> => class<`mpfr`>;
type `roundMpfr` <class<`mpfr`>, double, character[]> => class<`mpfr`>;
type `seqMpfr` <class<`mpfr`> | double, class<`mpfr`>, any, double, null, ...> => class<`mpfr`>;
type `sign` <class<`mpfr`>> => double[] | <class<`mpfrMatrix`>> => class<`matrix`>;
type `sprintfMpfr` <class<`mpfr`> | class<`mpfrMatrix`>, integer, character, any, logical> => character[];
type `sqrt` <class<`mpfr`>> => class<`mpfr`>;
type `standardGeneric` <character> => class<`matrix`> | <character> => double[] | <character> => (class<`matrix`> | class<`mpfrMatrix`>);
type `sum` <class<`mpfr`>, ..., logical> => class<`mpfr`>;
type `toNum` <class<`mpfrMatrix`>, character> => class<`matrix`>;
type `.toNum` <class<`mpfrMatrix`>, character> => class<`matrix`>;
type `trunc` <class<`mpfr`>> => class<`mpfr`>;
type `validityMethod` <class<`mpfrMatrix`>> => logical | <class<`mpfr`> | class<`mpfrMatrix`>> => logical | <class<`mpfr`>> => logical | <class<`mpfrArray`>> => logical;
type `y0` <double[]> => class<`mpfr`>;
type `yn` <double, double[], character[]> => class<`mpfr`>;
type `zeta` <class<`mpfr`> | double[]> => class<`mpfr`>;
