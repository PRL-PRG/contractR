type `$` <...> => (character | class<`boot`> | class<`data.frame`> | class<`integrate`> | class<`matrix`> | class<`trellis`> | class<`ts`> | double[] | null | list<any>);
type `as.function.formula` <class<`formula`>, ...> => class<`function`>;
type `f` <any, double[], double[], double[]> => class<`data.frame`>;
type `filter` <character[]> => logical[];
type `$.fn` <class<`fn`>, character> => class<`function`>;
type `fun` <any, any> => null;
type `FUN` <character | class<`data.frame`> | class<`data.frame`, `groupedData`, `nfGroupedData`, `nfnGroupedData`> | class<`factor`> | class<`factor`, `ordered`> | class<`formula`> | class<`function`> | class<`matrix`> | class<`ts`> | double[] | list<integer[]>> => logical | <character> => (character[] | ^double[] | list<character[]>) | <character | class<`data.frame`> | class<`data.frame`, `groupedData`, `nfGroupedData`, `nfnGroupedData`> | class<`factor`> | class<`factor`, `ordered`> | class<`formula`> | class<`matrix`> | class<`ts`> | double[] | list<integer[]>> => logical | <integer> => (character[] | double | null | list<character[]>) | <integer> => character[] | <double> => character | <character, ...> => (character[] | list<list<character | double>>) | <character> => (character | double[]) | <character | class<`data.frame`> | class<`data.frame`, `groupedData`, `nfGroupedData`, `nfnGroupedData`> | class<`factor`> | class<`factor`, `ordered`> | class<`formula`> | class<`matrix`> | class<`ts`> | double[] | list<integer[]>> => logical | <character> => character;
type `gsubfn` <any, any, character[], any, logical, logical, null | character, environment, ...> => character[];
type `match.funfn` <character | class<`formula`> | class<`function`> | class<`result`> | class<`protoMethod`>, logical> => (class<`function`> | class<`protoMethod`>);
type `ostrapply` <character[], character, class<`environment`, `proto`> | class<`function`>, logical, ..., any, class<`formula`> | logical, logical, class<`function`>> => (class<`matrix`> | list<character[]>);
type `read.pattern` <any, character, logical, character, character, character, ...> => class<`data.frame`>;
type `repl` <double, double> => character;
type `res` <class<`environment`, `proto`>, ...> => logical | <class<`environment`, `proto`>, ...> => logical | <class<`environment`, `proto`>, ...> => logical | <class<`environment`, `proto`>> => null | <class<`environment`, `proto`>> => null | <class<`environment`, `proto`>> => null | <class<`environment`, `proto`>> => (null | list<any>);
type `[<-.result` <class<`result`>, ..., class<`eigen`> | class<`lm`> | class<`matrix`> | class<`qr`> | list<double>> => class<`result`>;
type `strapply` <character[], character, class<`function`> | class<`result`> | class<`environment`, `proto`>, any, ..., any, logical, logical, any, class<`function`> | logical | class<`formula`>, any, class<`function`> | class<`result`>> => (character[] | class<`matrix`> | list<character[] | list<character[]>>);
type `strapply1` <character, character, null, logical> => class<`matrix`>;
type `strapplyc` <character[], character, null, logical, logical, any, any> => list<character[]>;
type `tclList2R` <character, class<`function`>> => list<character[]>;
type `transform2` <any, ...> => class<`data.frame`>;
