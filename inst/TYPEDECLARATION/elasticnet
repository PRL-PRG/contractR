type `cv.enet` <^double[], double[], double, double, double[], character, logical, logical, logical, double | null> => struct<`s`:double[], `cv`:double[], `cv.error`:double[]>;
type `enet` <^double[], double[], double, double | null, logical, logical, logical, double> => struct<`call`:language, `actions`:list<integer>, `allset`:integer[], `beta.pure`:^double[], `vn`:character[], `mu`:double, `normx`:double[], `meanx`:double[], `lambda`:double, `L1norm`:double[], `penalty`:double[], `df`:double[], `Cp`:double[], `sigma2`:double> | struct<`call`:language, `actions`:list<null | integer>, `allset`:integer[], `beta.pure`:^double[], `vn`:character[], `mu`:double, `normx`:double[], `meanx`:double[], `lambda`:double, `L1norm`:double[], `penalty`:double[], `df`:double[], `Cp`:double[], `sigma2`:double>;
type `filter` <character[]> => logical[];
type `plot.enet` <struct<`call`:language, `actions`:list<integer>, `allset`:integer[], `beta.pure`:^double[], `vn`:character[], `mu`:double, `normx`:double[], `meanx`:double[], `lambda`:double, `L1norm`:double[], `penalty`:double[], `df`:double[], `Cp`:double[], `sigma2`:double> | struct<`call`:language, `actions`:list<null | integer>, `allset`:integer[], `beta.pure`:^double[], `vn`:character[], `mu`:double, `normx`:double[], `meanx`:double[], `lambda`:double, `L1norm`:double[], `penalty`:double[], `df`:double[], `Cp`:double[], `sigma2`:double>, character[], logical, null> => null;
type `predict.enet` <struct<`call`:language, `actions`:list<integer>, `allset`:integer[], `beta.pure`:^double[], `vn`:character[], `mu`:double, `normx`:double[], `meanx`:double[], `lambda`:double, `L1norm`:double[], `penalty`:double[], `df`:double[], `Cp`:double[], `sigma2`:double>, ^double[] | null, null | double[], character[], character[], logical, null> => struct<`s`:double[], `fraction`:double[], `mode`:character, `fit`:^double[]> | struct<`s`:double, `fraction`:double, `mode`:character, `coefficients`:double[]>;
type `spca` <^double[], double, double[], character, character, logical, double, double, logical, double> => struct<`call`:language, `type`:character, `K`:double, `loadings`:^double[], `pev`:double[], `var.all`:double, `vn`:character[], `para`:double[], `lambda`:double>;
type `updateRR` <double[], ^double[], ^double[], double, double> => ^double[];
