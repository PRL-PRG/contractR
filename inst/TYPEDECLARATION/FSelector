type `as.simple.formula` <character[], character> => class<`formula`>;
type `attach_children` <list<class<`matrix`> | double[]>, list<double>> => list<class<`matrix`> | ^double[]>;
type `best.first.search` <character[], class<`function`>, double> => character[];
type `cfs` <class<`formula`>, class<`data.frame`>> => character[];
type `chi.squared` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `correlation.body` <class<`formula`>, class<`data.frame`>, character> => class<`data.frame`>;
type `create.children` <double[], character, null | class<`function`>> => class<`matrix`>;
type `cutoff.biggest.diff` <class<`data.frame`>> => character[];
type `cutoff.k` <class<`data.frame`>, double> => character[];
type `cutoff.k.percent` <class<`data.frame`>, double> => character[];
type `discretize.all` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `entropyHelper` <class<`data.frame`> | class<`factor`>, character> => double;
type `eval.fun` <character[]> => double;
type `eval_state` <double[], list<class<`matrix`> | double[] | class<`matrix`> | double>> => list<double>;
type `exhaustive.search` <character[], class<`function`>> => character;
type `field_distance` <double, class<`data.frame`>, class<`data.frame`>> => double;
type `filter` <character[]> => logical[];
type `find.best` <double[], logical[]> => list<double>;
type `find_neighbours` <integer> => null;
type `find.subset` <class<`matrix`>, double[]> => integer[];
type `forward.search` <character[], class<`function`>> => character[];
type `FUN` <class<`data.frame`> | class<`factor`>, character> => double | <double[]> => double | <integer> => double | <class<`factor`>> => double | <double[]> => null | <double[]> => list<double> | <integer> => double | <integer> => double | <class<`factor`>> => double | <list<double>> => double | <character> => double | <integer> => double | <double[]> => double | <list<double>> => logical | <integer> => double | <double[]> => double | <integer> => null | <class<`factor`>> => double | <double[]> => null | <...> => logical;
type `gain.ratio` <class<`formula`>, class<`data.frame`>, character> => class<`data.frame`>;
type `get_correlation` <character, character | double, any, any, any> => double;
type `get.data.frame.from.formula` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `greedy.search` <character[], class<`function`>, logical> => character[];
type `hill.climbing.search` <character[], class<`function`>> => character[];
type `information.gain` <class<`formula`>, class<`data.frame`>, character> => class<`data.frame`>;
type `information.gain.body` <class<`formula`>, class<`data.frame`>, character, character> => class<`data.frame`>;
type `instance_distance` <class<`data.frame`>, class<`data.frame`>> => double;
type `linear.correlation` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `normalize.min.max` <class<`data.frame`>> => class<`data.frame`>;
type `oneR` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `random.forest.importance` <class<`formula`>, class<`data.frame`>, double> => class<`data.frame`>;
type `rank.correlation` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `relief` <class<`formula`>, class<`data.frame`>, double, double> => class<`data.frame`>;
type `supervised.discretization` <class<`formula`>, class<`data.frame`>> => class<`data.frame`>;
type `symmetrical.uncertainty` <class<`formula`>, class<`data.frame`>, character> => class<`data.frame`>;
type `update_weights` <integer> => null;
