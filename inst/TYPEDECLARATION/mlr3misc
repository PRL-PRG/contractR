type `$` <character, ...> => class<`Item`, `R6`> | <character[], ...> => list<class<`Item`, `R6`>> | <null> => character[] | <character, class<`Item`, `R6`> | class<`R6ClassGenerator`>, ..., character[]> => class<`Dictionary`, `R6`>;
type `as_factor` <class<`factor`>, character[], logical> => class<`factor`>;
type `as_short_string` <list<any>, integer, character> => character;
type `check_packages_installed` <character[], logical, character> => any;
type `chunk` <integer, double, null, logical> => integer[];
type `chunk_vector` <integer[], double, null, logical> => list<integer[]>;
type `cite_bib` <character, character> => character;
type `compute_mode` <double[], character, logical> => double;
type `cross_join` <list<integer[] | character[]>, logical, logical> => class<`data.frame`, `data.table`>;
type `dictionary_get` <class<`Dictionary`, `R6`>, character, ...> => class<`Item`, `R6`>;
type `dictionary_initialize_item` <any, list<class<`R6ClassGenerator`> | character[] | list<any>>, list<any>> => class<`Item`, `R6`>;
type `dictionary_retrieve_item` <class<`Dictionary`, `R6`>, character> => list<class<`R6ClassGenerator`> | character[] | list<any>>;
type `dictionary_sugar_get` <class<`Dictionary`, `R6`>, character, ...> => class<`Item`, `R6`>;
type `did_you_mean` <character, character[]> => character;
type `distinct_values` <class<`factor`> | integer[], logical, logical> => (^character[] | integer[]);
type `distinct_values.default` <integer[], logical, logical> => integer[];
type `distinct_values.factor` <class<`factor`>, logical, logical> => ^character[];
type `distinct_values.logical` <logical, logical, logical> => logical[];
type `encapsulate` <character, class<`function`>, list<double>, list<any>, character[], double> => list<double | class<`data.frame`, `data.table`>>;
type `enframe` <integer[], character, character> => class<`data.frame`, `data.table`>;
type `extract_vars` <class<`formula`>> => list<character[]>;
type `filter` <character[]> => logical[];
type `formulate` <character | null, character[], null> => class<`formula`>;
type `fun` <any, character> => logical;
type `FUN` <character, ...> => class<`Item`, `R6`> | <character> => logical | <list<double>> => list<double> | <character[]> => character[] | <class<`condition`, `message`, `simpleMessage`>> => list<character> | <integer> => (character[] | double[] | list<character[]>) | <character | double | integer[] | null> => character | <class<`formula`>> => character;
type `get_constructor_formals` <class<`R6ClassGenerator`>> => character[];
type `get_seed` < > => integer[];
type `has_element` <list<double>, double> => logical;
type `ids` <list<list<character | double>>> => character[];
type `insert_named` <list<any>, list<any>> => list<any>;
type `insert_named.default` <list<double>, list<double>> => list<double>;
type `invoke` <any, ..., list<integer[] | character[] | integer[] | double>, list<any>, null | double> => (class<`data.frame`, `data.table`> | double);
type `keep_in_bounds` <integer[], double, double> => integer[];
type `load_dataset` <character, character, logical> => class<`data.frame`>;
type `map` <class<`data.frame`> | list<character[] | class<`condition`, `message`, `simpleMessage`>>, class<`function`>, ...> => list<character[] | double[] | list<character>>;
type `map_chr` <character[] | list<class<`formula`>>, class<`function`>, ...> => character[];
type `map_dtr` <list<class<`condition`, `message`, `simpleMessage`>>, class<`function`>, ..., logical, null> => class<`data.frame`, `data.table`>;
type `map_int` <list<character[]>, class<`function`>, ...> => integer[];
type `map_lgl` <character[] | class<`data.frame`> | list<double>, class<`function`>, ...> => logical[];
type `map_mold` <character[] | class<`data.frame`> | list<class<`formula`> | character[] | double>, class<`function`>, null, ...> => (character[] | integer[]);
type `map_values` <character[], character[], character[]> => character[];
type `messagef` <character, ..., double> => null;
type `modify_at` <class<`data.frame`>, character | double, class<`function`>, ...> => class<`data.frame`>;
type `modify_at.default` <class<`data.frame`>, character | double, class<`function`>, ...> => class<`data.frame`>;
type `modify_if` <class<`data.frame`>, class<`function`>, class<`function`>, ...> => class<`data.frame`>;
type `modify_if.default` <class<`data.frame`>, class<`function`>, class<`function`>, ...> => class<`data.frame`>;
type `named_list` <character[], double | null> => list<double | null>;
type `named_vector` <character[], null> => ^logical[];
type `names2` <integer[] | character[] | list<any>, null | character> => ^character[];
type `%nin%` <character[], null | character> => logical[];
type `parse_callr` <character> => class<`data.frame`, `data.table`>;
type `parse_evaluate` <list<class<`source`> | class<`condition`, `message`, `simpleMessage`>>> => class<`data.frame`, `data.table`>;
type `probe` <class<`data.frame`>, class<`function`>, ...> => logical[];
type `rbindlist2` <list<list<double>>> => class<`data.frame`, `data.table`>;
type `rcbind` <class<`data.frame`, `data.table`>, class<`data.frame`, `data.table`>> => class<`data.frame`, `data.table`>;
type `remove_named` <class<`data.frame`, `data.table`> | list<double>, character> => (class<`data.frame`, `data.table`> | list<double>);
type `remove_named.data.table` <class<`data.frame`, `data.table`>, character> => class<`data.frame`, `data.table`>;
type `remove_named.default` <list<double>, character> => list<double>;
type `require_namespaces` <character[], character> => any;
type `rowwise_table` <..., null> => class<`data.frame`, `data.table`>;
type `seq_len0` <double> => integer[];
type `set_class` <list<any>, character[]> => class<`foo1`, `foo2`>;
type `set_names` <character[] | double[] | ^logical[] | list<class<`Item`, `R6`>>, character[] | class<`function`>, ...> => (character[] | double[] | ^logical[] | list<class<`Item`, `R6`>>);
type `shuffle` <double | integer[], integer, ...> => (double | integer[]);
type `str_collapse` <character[], character, character, double, character> => character;
type `str_indent` <character, character, double, integer, ...> => character[];
type `str_trunc` <character, double, character> => character;
type `str_wrap` <character, double> => character;
type `.subset2` < > => environment;
type `topo_sort` <class<`data.frame`, `data.table`>> => class<`data.frame`, `data.table`>;
type `transpose_list` <class<`data.frame`> | list<list<double>>> => list<list<double | class<`factor`> | double>>;
type `unnest` <class<`data.frame`, `data.table`>, character, null> => class<`data.frame`, `data.table`>;
type `which_max` <^double[] | null, character, logical> => (integer[] | null);
type `which_min` <double[], character, logical> => integer;
