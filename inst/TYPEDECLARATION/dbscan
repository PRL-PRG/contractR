type `::` <class<`dist`> | class<`matrix`> | class<`data.frame`> | class<`NN`, `frNN`>, any, double, null, logical, ...> => any | <class<`matrix`> | class<`data.frame`> | class<`data.frame`, `data.table`> | class<`dist`> | class<`NN`, `kNN`>, double, null | class<`data.frame`>, logical, character, any, any, any> => any;
type `adjacencylist` <class<`NN`, `frNN`> | class<`NN`, `kNN`> | class<`NN`, `kNN`, `sNN`>, ...> => list<integer[]>;
type `adjacencylist.frNN` <class<`NN`, `frNN`>, ...> => list<integer[]>;
type `adjacencylist.kNN` <class<`NN`, `kNN`> | class<`NN`, `kNN`, `sNN`>, ...> => list<integer[]>;
type `all_children` <list<integer[]>, double, logical> => integer[];
type `as.dendrogram.optics` <class<`optics`>, ...> => any;
type `as.dendrogram.reachability` <class<`reachability`>, ...> => class<`dendrogram`>;
type `as.reachability` <class<`dendrogram`> | class<`optics`>, ...> => class<`reachability`>;
type `as.reachability.dendrogram` <class<`dendrogram`>, ...> => class<`reachability`>;
type `as.reachability.optics` <class<`optics`>, ...> => class<`reachability`>;
type `buildDendrogram` <class<`hclust`>> => class<`dendrogram`>;
type `computeStability` <class<`hclust`>, double, logical> => list<list<double[]>>;
type `dbscan` <class<`dist`> | class<`matrix`> | class<`data.frame`> | class<`NN`, `frNN`>, any, double, null, logical, ...> => any;
type `dbscan_density_int` <class<`matrix`>, double, integer, integer, integer, double> => integer[];
type `dbscan_int` <class<`matrix`>, double, integer, double[], integer, integer, integer, integer, double, list<any>> => integer[];
type `dendrogram_to_reach` <class<`dendrogram`>> => class<`reachability`>;
type `distToAdjacency` <double[], integer> => list<integer[]>;
type `extractClusterLabels` <class<`data.frame`>, integer[], logical> => double[];
type `extractDBSCAN` <class<`optics`>, double> => class<`optics`>;
type `extractFOSC` <class<`data.frame`> | class<`hclust`>, null | class<`matrix`> | double[] | list<double[]>, double, double, logical, logical> => any;
type `extractSemiSupervised` <list<list<double[]>>, list<double[]>, double, logical> => list<list<double[]>>;
type `extractUnsupervised` <list<list<double[]>>, logical> => list<list<double[]>>;
type `extractXi` <class<`optics`>, double, logical, logical> => class<`optics`>;
type `frNN` <class<`data.frame`> | class<`dist`> | class<`matrix`> | class<`NN`, `frNN`>, double, class<`data.frame`> | null, logical, character, double, character, double> => any;
type `frNN_int` <class<`matrix`>, double, integer, integer, integer, double> => list<double | list<double[]>>;
type `frNN_query_int` <class<`matrix`>, class<`matrix`>, double, integer, integer, integer, double> => list<double | list<double[]>>;
type `glosh` <class<`hclust`> | class<`matrix`>, double, ...> => double[];
type `hclustMergeOrder` <class<`matrix`>, integer[]> => class<`hclust`>;
type `hdbscan` <class<`data.frame`> | class<`data.frame`, `data.table`> | class<`matrix`>, double, null, logical, logical> => class<`hdbscan`>;
type `hullplot` <class<`matrix`>, class<`dbscan`, `dbscan_fast`> | class<`kmeans`> | class<`optics`> | integer[], null | character, double, double, double, logical, double, character, ...> => null;
type `jpclust` <class<`data.frame`, `data.table`> | class<`NN`, `kNN`>, double, double, ...> => class<`general_clustering`>;
type `JP_int` <class<`matrix`>, integer> => integer[];
type `kNN` <class<`matrix`> | class<`data.frame`> | class<`data.frame`, `data.table`> | class<`dist`> | class<`NN`, `kNN`>, double, null | class<`data.frame`>, logical, character, any, any, any> => any;
type `kNNdist` <class<`matrix`> | class<`data.frame`> | class<`dist`>, double, logical, ...> => (class<`matrix`> | double[]);
type `kNNdistplot` <class<`matrix`>, double, ...> => null;
type `kNN_int` <class<`matrix`>, integer, integer, integer, integer, double> => list<class<`matrix`> | integer>;
type `kNN_query_int` <class<`matrix`>, class<`matrix`>, integer, integer, integer, integer, double> => list<class<`matrix`> | integer>;
type `lof` <class<`dist`> | class<`matrix`>, double, ...> => any;
type `.matrixlike` <class<`data.frame`> | class<`data.frame`, `data.table`> | class<`dist`> | class<`matrix`>> => logical;
type `.memberDend` <class<`dendrogram`>> => integer;
type `.midcache.dendrogram` <class<`dendrogram`>, character, logical> => class<`dendrogram`>;
type `mrd` <class<`dist`>, double[]> => double[];
type `node_xy` <list<list<double[]>>, list<integer[]>, integer> => class<`matrix`>;
type `optics` <class<`data.frame`> | class<`dist`> | class<`matrix`>, double | null, double, ...> => any;
type `optics_int` <class<`matrix`>, double, integer, integer, integer, integer, double, class<`NN`, `frNN`> | list<any>> => list<double[] | ^integer[]>;
type `plot.hdbscan` <class<`hdbscan`>, character | double, character[], logical, ...> => class<`hdbscan`>;
type `plot.NN` <class<`NN`, `frNN`> | class<`NN`, `kNN`> | class<`NN`, `kNN`, `sNN`>, class<`data.frame`>, null, ...> => null;
type `plot.optics` <class<`optics`>, logical, logical, ...> => (null | list<character | double[] | null>);
type `plot.reachability` <class<`reachability`>, logical, character | null, character, character, ...> => null;
type `pointdensity` <class<`matrix`> | class<`data.frame`, `data.table`>, double, character, character, double, character, double> => double[];
type `predict.dbscan_fast` <class<`dbscan`, `dbscan_fast`>, class<`matrix`>, class<`matrix`>, ...> => integer[];
type `.predict_frNN` <class<`matrix`>, class<`matrix`>, integer[], double, ...> => integer[];
type `prims` <double[], integer> => class<`matrix`>;
type `reach_to_dendrogram` <class<`reachability`>, double[]> => class<`dendrogram`>;
type `simplifiedTree` <list<list<double[]>>> => class<`dendrogram`>;
type `sNN` <class<`data.frame`> | class<`data.frame`, `data.table`> | class<`NN`, `kNN`, `sNN`>, any, null | double, logical, logical, character, double, character, double> => class<`NN`, `kNN`, `sNN`>;
type `sNNclust` <class<`data.frame`, `data.table`>, double, double, double, logical, ...> => class<`general_clustering`>;
type `SNN_sim_int` <class<`matrix`>, logical> => class<`matrix`>;
type `sort.frNN` <class<`NN`, `frNN`>, logical, ...> => class<`NN`, `frNN`>;
type `sort.kNN` <class<`NN`, `kNN`, `sNN`> | class<`NN`, `kNN`>, logical, ...> => (class<`NN`, `kNN`, `sNN`> | class<`NN`, `kNN`>);
type `sort.sNN` <class<`NN`, `kNN`, `sNN`>, logical, ...> => class<`NN`, `kNN`, `sNN`>;
type `steepDown` <double, class<`optics`>, double> => logical;
type `steepUp` <double, class<`optics`>, any> => logical;
type `updateFilterSDASet` <any, list<any>, any> => list<any>;
type `valid` <double, class<`optics`>> => logical;
type `validateConstraintList` <list<double>, integer> => list<double>;
