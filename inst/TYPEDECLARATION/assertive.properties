type `are_same_length` <double[], tuple<double, integer[], integer[], integer[], integer[]>, language, language> => logical;
type `assert_has_all_attributes` <double, character[], character> => double;
type `assert_has_any_attributes` <double, character[], character> => double;
type `assert_has_colnames` <struct<`x`:integer[]>, character> => struct<`x`:integer[]>;
type `assert_has_cols` <^logical[], character> => ^logical[];
type `assert_has_dimnames` <struct<`x`:integer[]>, character> => struct<`x`:integer[]>;
type `assert_has_duplicates` <integer[], character> => integer[];
type `assert_has_elements` <struct<`x`:integer[], `y`:integer[]> | integer[] | struct<`a`:integer[], `b`:struct<`b.a`:integer[], `b.b`:integer[]>>, double, character> => struct<`x`:integer[], `y`:integer[]> | integer[] | struct<`a`:integer[], `b`:struct<`b.a`:integer[], `b.b`:integer[]>>;
type `assert_has_names` <double[], character> => double[];
type `assert_has_rownames` <struct<`x`:integer[]>, character> => struct<`x`:integer[]>;
type `assert_has_rows` <struct<`x`:integer[]>, character> => struct<`x`:integer[]>;
type `assert_is_atomic` <? character[] | complex[] | ^logical[] | raw[], character> => ? character[] | complex[] | ^logical[] | raw[];
type `assert_is_nested` <struct<`a`:double, `b`:tuple<integer[]>>, character> => struct<`a`:double, `b`:tuple<integer[]>>;
type `assert_is_non_nested` <double | tuple<integer[]>, character> => double | tuple<integer[]>;
type `assert_is_not_null` <null, language> => null;
type `assert_is_null` <null, character> => null;
type `assert_is_of_length` <struct<`x`:integer[], `y`:integer[]> | integer[] | struct<`a`:integer[], `b`:struct<`b.a`:integer[], `b.b`:integer[]>>, double, character> => struct<`x`:integer[], `y`:integer[]> | integer[] | struct<`a`:integer[], `b`:struct<`b.a`:integer[], `b.b`:integer[]>>;
type `assert_is_recursive` <any => any | struct<> | expression | language | tuple<>, character> => any => any | struct<> | expression | language | tuple<>;
type `assert_is_unsorted` <double[], logical, logical, character> => double[];
type `assert_is_vector` <character[] | complex[] | expression | tuple<> | raw[], character> => character[] | complex[] | expression | tuple<> | raw[];
type `check_n` <double> => null;
type `DIM` <? struct<`extra`:double[], `group`:integer[], `ID`:integer[]> | double[] | struct<`x`:integer[]>> => integer[];
type `filter` <character[]> => logical[];
type `FUN` <double[] | tuple<integer[]> | struct<`b.a`:integer[], `b.b`:integer[]> | character> => integer;
type `get_dim_string` <? integer[]> => character;
type `get_metric` <character> => any => any;
type `has_any_attributes` <^logical[], language> => logical;
type `has_attributes` <struct<`extra`:double[], `group`:integer[], `ID`:integer[]>, character[], language> => logical[];
type `has_elements` <integer[], double, language> => logical;
type `has_slot` <character, language> => logical;
type `have_same_dims` <^integer[], struct<`x`:integer[], `y`:integer[], `y.1`:integer[]>, language, language> => logical;
type `is_empty` <character[] | struct<`dim`:integer[]>, character[], character> => logical;
type `is_non_empty` <integer[], character[], language | symbol> => logical;
type `is_not_null` <character[] | double[], language> => logical;
type `is_null` <null, language> => logical;
type `is_of_length` <integer[] | language, double, language | symbol> => logical;
type `is_recursive` <struct<`a`:double, `b`:tuple<integer[]>>, symbol> => logical;
type `n_elements` <? struct<`x`:integer[], `y`:double[]> | expression | integer[] | tuple<integer[], tuple<integer[], tuple<integer[]>>> | struct<`a`:integer[], `b`:struct<`b.a`:integer[], `b.b`:integer[]>>> => integer;
type `predicate` <? struct<`x`:integer[]> | any => any | expression | language | tuple<> | struct<`a`:integer[], `b`:struct<`b.a`:integer[], `b.b`:integer[]>> | character[] | complex[] | raw[] | struct<`a`:double, `b`:tuple<integer[]>> | tuple<integer[]> | ^logical[], character[] | double, language | character | logical, character> => logical[];
type `is_scalar` <? complex[] | raw[], character[], symbol | character> => logical;
type `metric_fn` <? complex | raw, integer, symbol> => logical;
