type `::` <double[], double[], double[] | class<`matrix`>, double[], double[], double, double, character, character, double[], character, character> => list<class<`matrix`> | double[]>;
type `arcs` <class<`triSht`>> => class<`matrix`>;
type `area` <class<`triSht`>> => double[];
type `circles` <double[], double[], double[], ...> => null;
type `convex.hull` <class<`triSht`>, logical, logical, ...> => list<double[]>;
type `dummy.node` <double, double, double, double, double, double, double> => list<double>;
type `filter` <character[]> => logical[];
type `franke.data` <double, double, list<class<`data.frame`>>> => list<double[]>;
type `franke.fn` <double[], double[], double> => double[];
type `FUN` <class<`matrix`>> => double[] | <class<`matrix`>> => double[] | <class<`matrix`>> => double[];
type `in.convex.hull` <class<`triSht`>, class<`matrix`> | double[], class<`matrix`> | double[], double, logical> => logical[];
type `inHull` <class<`triSht`>, class<`matrix`> | double[], class<`matrix`> | double[], double> => logical[];
type `interp` <double[], double[], double[], double[], double[], any, any, any, any, any, double, character> => list<double[] | class<`matrix`> | ^double[]>;
type `interpp` <double[], double[], double[], double[], double[], logical, logical, character, null, character> => list<^double[]>;
type `interpShull` <double[], double[], double[], double[], double[], logical, character, character> => list<double[] | class<`matrix`>>;
type `left` <double, double, double, double, double, double, double> => logical;
type `locpoly` <double[], double[], double[] | class<`matrix`>, double[], double[], double, double, character, character, double[], character, character> => list<class<`matrix`> | double[]>;
type `locpoly.partderiv.grid` <double[], double[], class<`matrix`> | double[], class<`matrix`> | double[], class<`matrix`> | double[], character, double[], character, double, logical, logical, integer> => list<class<`matrix`>>;
type `nearest.neighbours` <double[], double[]> => list<class<`matrix`>>;
type `on` <double, double, double, double, double, double, double> => logical;
type `on.convex.hull` <class<`triSht`>, double[], double[], double> => logical[];
type `onHull` <class<`triSht`>, double[], double[], double> => logical[];
type `outer.convhull` <double[], double[], double[], double[], class<`function`>, character, ...> => class<`matrix`>;
type `plot.triSht` <class<`triSht`>, logical, any, any, logical, logical, logical, logical, character, character, ...> => null;
type `plot.voronoi` <class<`voronoi`>, logical, double[], double[], logical, logical, character, any, logical, ...> => null;
type `plot.voronoi.polygons` <class<`voronoi.polygons`>, any, logical, logical, ...> => null;
type `shull.deltri` <double[], double[]> => list<double[] | class<`matrix`>>;
type `summary.triSht` <class<`triSht`>, ...> => class<`summary.triSht`>;
type `summary.voronoi` <class<`voronoi`>, ...> => class<`summary.voronoi`>;
type `triangles` <class<`triSht`>> => class<`matrix`>;
type `tri.find` <class<`triSht`>, double, double> => list<double | class<`matrix`>>;
type `triFind` <integer, double[], double[], integer[], integer[], integer[], double, double> => list<double | class<`matrix`>>;
type `tri.mesh` <class<`data.frame`> | class<`triSht`> | double[], null | double[], character> => class<`triSht`>;
type `voronoi.area` <class<`voronoi`>> => ^double[];
type `voronoi.findvertices` <integer, class<`voronoi`>> => integer[];
type `voronoi.mosaic` <class<`triSht`> | double[], null | double[], character> => class<`voronoi`>;
type `voronoi.polyarea` <double[], double[]> => double;
type `voronoi.polygons` <class<`voronoi`>> => class<`voronoi.polygons`>;
