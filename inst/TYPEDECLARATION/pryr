type `%||%` <character[], any> => character[];
type `%.%` <class<`function`>, class<`function`>> => class<`function`>;
type `%<a-%` <any, any> => null;
type `address` <any> => character;
type `address2` <class<`name`>, environment> => character;
type `all_named` <pairlist> => logical;
type `as.envlist` <list<environment>> => class<`envlist`>;
type `ast` <any> => null;
type `binary_repr` <character | null> => character;
type `bits` <character | null, logical> => character;
type `bytes` <character | double | null, logical> => character;
type `%<c-%` <any, double> => double;
type `call_tree` <class<`call`> | class<`if`> | expression, integer> => null;
type `check_name` <class<`name`>> => class<`name`>;
type `compact` <list<character[] | null | null | character[]>> => list<character[]>;
type `compare_size` <class<`formula`> | list<integer[]>> => double[];
type `compose` <...> => double | <...> => class<`function`>;
type `%<d-%` <any, any> => null;
type `dots` <...> => list<double | class<`name`>>;
type `enclosing_env` <character> => environment;
type `[.envlist` <class<`envlist`>, double | integer[]> => class<`envlist`>;
type `extract` <any> => (character[] | null) | <class<`function`>> => character[];
type `f` <..., environment> => class<`function`>;
type `fget` <character, environment> => class<`function`>;
type `find_funs` <character, class<`function`>, character, ...> => character[];
type `find_generic` <character, any> => (character[] | null);
type `find_uses` <character[], character[], logical> => list<character[]>;
type `ftype` <class<`function`>> => character[];
type `FUN` <any> => (character[] | null) | <class<`{`> | class<`call`> | class<`name`> | double | null | pairlist | class<`if`>, double, double, character> => character | <class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>, class<`function`>, ...> => (class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>);
type `fun_body` <class<`function`>> => character[];
type `fun_calls` <any> => (character[] | null);
type `hex_repr` <character | double | null> => character;
type `internal_generics` < > => character[];
type `internal_name` <class<`function`>> => character;
type `is_active_binding` <any> => logical;
type `is_internal` <class<`function`>> => logical;
type `is_internal_generic` <character> => logical;
type `is_promise` <any> => logical;
type `is_promise2` <class<`name`>, environment> => logical;
type `is_s3_generic` <character, environment> => logical;
type `is_s3_method` <character, any> => logical;
type `make_call` <character | class<`call`> | class<`name`>, ..., list<any>> => class<`call`>;
type `make_function` <pairlist | list<class<`name`> | class<`name`> | double>, class<`call`> | class<`{`>, environment> => class<`function`>;
type `matched_calls` <class<`function`> | class<`selfStart`> | character[] | class<`simple.list`> | class<`SweaveSyntax`> | double, any, any> => (character[] | null);
type `mem_change` <any> => class<`bytes`>;
type `mem_used` < > => class<`bytes`>;
type `method_from_call` <any, environment> => (class<`function`> | class<`MethodDefinition`>);
type `modify_call` <class<`call`>, list<class<`name`> | null | double>> => class<`call`>;
type `modify_lang` <class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>, class<`function`>, ...> => (class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>);
type `named2` <class<`name`>, environment> => integer;
type `named_dots` <...> => list<double | class<`name`>>;
type `names_c` < > => class<`data.frame`>;
type `node_size` < > => integer;
type `object_size` <..., environment> => class<`bytes`>;
type `object_sizes` <list<any>, environment> => double;
type `otype` <class<`data.frame`> | integer[]> => character;
type `parent_promise` <any> => class<`call`>;
type `parenv` <class<`function`>, double> => environment;
type `parenvs` <class<`function`> | environment, logical> => class<`envlist`>;
type `partial` <class<`function`>, ..., environment, logical> => class<`function`>;
type `primitive_name` <class<`function`>> => character;
type `print.envlist` <class<`envlist`>, logical, logical, ...> => class<`envlist`>;
type `promise_code` <class<`name`>, environment> => (class<`call`> | class<`name`>);
type `rebind` <character, double, environment> => double;
type `refs` <any> => integer;
type `show_bytes` <class<`bytes`> | double> => class<`bytes`>;
type `show_c_source` <any> => null;
type `slice` <character, integer, character> => character;
type `standardise_call` <class<`call`>, environment> => class<`call`>;
type `stop_list` < > => character[];
type `str_trunc` <character, double> => character;
type `subs` <any, environment> => class<`call`>;
type `substitute_q` <class<`call`>, environment | list<double | double | character[]>> => class<`call`>;
type `to_env` <character | class<`function`> | environment | list<double | double | character[]>, logical> => environment;
type `track_copy` <any, environment, logical> => class<`function`>;
type `tree` <class<`{`> | class<`call`> | class<`name`> | double | null | pairlist | class<`if`>, double, double, character> => character;
type `typename` <any> => character;
type `typename2` <class<`name`>, environment> => character;
type `unenclose` <class<`function`>> => class<`function`>;
type `uneval` <any> => class<`call`>;
type `where` <character, environment> => environment;
