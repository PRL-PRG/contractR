type `%||%` <character[], any> => character[];
type `%.%` <class<`function`>, class<`function`>> => class<`function`>;
type `%<a-%` <any, any> => null;
type `address2` <class<`name`>, environment> => character;
type `all_named` <pairlist> => logical;
type `as.envlist` <list<environment>> => class<`envlist`>;
type `ast` <any> => null;
type `%<c-%` <any, double> => double;
type `call_tree` <class<`call`> | class<`if`> | expression, integer> => null;
type `compact` <list<character[] | null | null | character[]>> => list<character[]>;
type `compose` <...> => double | <...> => class<`function`>;
type `%<d-%` <any, any> => any;
type `enclosing_env` <character> => environment;
type `[.envlist` <class<`envlist`>, double | integer[]> => class<`envlist`>;
type `extract` <class<`function`> | class<`selfStart`>> => character[] | <any> => (character[] | null) | <class<`function`>> => character[];
type `f` <..., environment> => class<`function`>;
type `fget` <character, environment> => class<`function`>;
type `filter` <character[]> => logical[];
type `find_funs` <character, class<`function`>, character, ...> => character[];
type `find_generic` <character, any> => (character[] | null);
type `find_uses` <character[], character[], logical> => list<character[]>;
type `ftype` <class<`function`>> => character[];
type `FUN` <any> => (character[] | null) | <class<`{`> | class<`call`> | class<`name`> | double | null | pairlist | class<`if`>, double, double, character> => character | <character | class<`function`> | environment | list<any>, logical> => environment | <environment> => list<character[]> | <character> => (character[] | null) | <environment> => character | <environment> => character | <character> => logical | <class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>, class<`function`>, ...> => (class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>);
type `fun_body` <class<`function`>> => character[];
type `fun_calls` <any> => (character[] | null);
type `internal_call` <class<`{`> | class<`call`> | class<`if`>> => class<`call`>;
type `internal_generics` < > => character[];
type `internal_name` <class<`function`>> => character;
type `is_internal` <class<`function`>> => logical;
type `is_internal_generic` <character> => logical;
type `is_promise2` <class<`name`>, environment> => logical;
type `is_s3_generic` <character, environment> => logical;
type `is_s3_method` <character, any> => logical;
type `make_call` <character | class<`call`> | class<`name`>, ..., list<any>> => class<`call`>;
type `make_function` <pairlist | list<class<`name`> | class<`name`> | double>, class<`call`> | class<`{`>, environment> => class<`function`>;
type `matched_calls` <class<`function`> | class<`selfStart`> | character[] | class<`simple.list`> | class<`SweaveSyntax`> | double, any, any> => (character[] | null);
type `mem_change` <any> => any;
type `mem_used` < > => class<`bytes`>;
type `modify_call` <class<`call`>, list<class<`name`> | null | double>> => class<`call`>;
type `modify_lang` <class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>, class<`function`>, ...> => (class<`<-`> | class<`call`> | class<`function`> | class<`name`> | double | expression | pairlist | list<any>);
type `names_c` < > => class<`data.frame`>;
type `node_size` < > => integer;
type `not_null` <...> => logical;
type `otype` <class<`data.frame`> | integer[]> => character;
type `parent_promise` <any> => class<`call`>;
type `parenv` <class<`function`>, double> => environment;
type `parenvs` <class<`function`> | environment, logical> => class<`envlist`>;
type `partial` <class<`function`> | class<`standardGeneric`>, ..., environment, logical> => class<`function`>;
type `primitive_name` <class<`function`>> => character;
type `print.envlist` <class<`envlist`>, logical, logical, ...> => class<`envlist`>;
type `promise_code` <class<`name`>, environment> => (class<`call`> | class<`name`>);
type `rebind` <character, double, environment> => double;
type `recurse` <expression | class<`<-`> | class<`call`> | pairlist | list<any>> => list<any>;
type `show_bytes` <double> => class<`bytes`>;
type `show_c_source` <any> => null;
type `standardise_call` <class<`call`>, environment> => class<`call`>;
type `stop_list` < > => character[];
type `str_trunc` <character, double> => character;
type `subs` <any, environment> => class<`call`>;
type `substitute_q` <class<`call`>, environment | list<any>> => class<`call`>;
type `to_env` <character | class<`function`> | environment | list<any>, logical> => environment;
type `track_a` < > => logical;
type `track_copy` <any, environment, logical> => class<`function`>;
type `tree` <class<`{`> | class<`call`> | class<`name`> | double | null | pairlist | class<`if`>, double, double, character> => character;
type `unenclose` <class<`function`>> => class<`function`>;
type `uneval` <any> => class<`call`>;
