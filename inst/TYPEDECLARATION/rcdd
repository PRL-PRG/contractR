type `addHeq` <integer[], character | double, ^character[] | ^double[]> => ^character[] | ^double[];
type `addHin` <double[], double, ^character[] | ^double[]> => ^character[] | ^double[];
type `allfaces` <^character[] | ^double[]> => struct<`dimension`:list<integer>, `active.set`:list<integer[]>, `relative.interior.point`:list<character[]>> | struct<`dimension`:list<integer>, `active.set`:list<integer[]>, `relative.interior.point`:list<double[]>>;
type `d2q` <^double[]> => ^character[];
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => null;
type `FUN` <^character[], ^character[]> => double[] | ^character[];
type `lpcdd` <^character[] | ^double[], character[] | double[], character | double, logical, character[]> => struct<`solution.type`:character, `dual.direction`:character[]> | struct<`solution.type`:character, `dual.direction`:double[]> | struct<`solution.type`:character, `primal.direction`:character[]> | struct<`solution.type`:character, `primal.direction`:double[]> | struct<`solution.type`:character, `primal.solution`:character[], `dual.solution`:character[], `optimal.value`:character> | struct<`solution.type`:character, `primal.solution`:double[], `dual.solution`:double[], `optimal.value`:double>;
type `q2d` <^character[]> => ^double[];
type `q2q` <^character[]> => ^character[];
type `qabs` <^character[]> => ^character[];
type `qdq` <^double[] | character[], double[] | character[]> => ^character[];
type `qmatmult` <^character[] | ^double[], ^character[] | ^double[]> => ^character[];
type `qmax` <character[]> => character;
type `qmin` <character[]> => character;
type `qmq` <^character[] | ^double[], ^double[] | ^character[]> => ^character[];
type `qneg` <^character[] | integer[]> => ^character[];
type `qpq` <character[] | double[], ^character[]> => character[];
type `qprod` <character[]> => character;
type `qsign` <character[] | integer[]> => integer[];
type `qsum` <character[]> => character;
type `qxq` <^character[], double[] | character[]> => ^character[];
type `redundant` <^character[] | ^double[], character[]> => struct<`output`:^character[], `implied.linearity`:integer[], `new.position`:integer[]> | struct<`output`:^character[], `redundant`:integer[], `new.position`:integer[]> | struct<`output`:^double[], `new.position`:integer[]>;
