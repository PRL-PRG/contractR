type `act.deriv.fct` <^double[]> => ^double[];
type `act.deriv2.fct` <^double[]> => ^double[];
type `act.fct` <^double[]> => ^double[];
type `calculate.gradients` <tuple<^double[], ^double[]>, integer, tuple<^double[], ^double[]>, tuple<^double[], ^double[]>, ^double[], double, logical> => double[];
type `compute.net` <tuple<^double[], ^double[]>, integer, ^double[], any => any, any => any, any => any, any => any, logical> => struct<`neurons`:tuple<^double[], ^double[]>, `neuron.deriv`:tuple<^double[], ^double[]>, `net.result`:^double[]>;
type `confidence.interval` <struct<`call`:language, `response`:^double[], `covariate`:^double[], `model.list`:struct<`response`:character, `variables`:character[]>, `err.fct`:any => any, `act.fct`:any => any, `linear.output`:logical, `data`:struct<`education`:integer[], `age`:double[], `parity`:double[], `induced`:double[], `case`:double[], `spontaneous`:double[], `stratum`:integer[], `pooled.stratum`:double[]>, `exclude`:null, `net.result`:tuple<^double[]>, `weights`:tuple<tuple<^double[], ^double[]>>, `generalized.weights`:tuple<^double[]>, `startweights`:tuple<tuple<^double[], ^double[]>>, `result.matrix`:^double[]>, double> => struct<`lower.ci`:tuple<tuple<^double[], ^double[]>>, `upper.ci`:tuple<tuple<^double[], ^double[]>>, `nic`:double>;
type `convert.activation.function` <character> => struct<`fct`:any => any, `deriv.fct`:any => any>;
type `convert.error.function` <character> => struct<`fct`:any => any, `deriv.fct`:any => any>;
type `err.deriv.fct` <^double[], ^double[]> => ^double[];
type `err.deriv2.fct` <^double[], ^double[]> => ^double[];
type `err.fct` <^double[], ^double[]> => ^double[];
type `filter` <character[]> => logical[];
type `FUN` <struct<`generalized.weights`:^double[], `weights`:tuple<^double[], ^double[]>, `startweights`:tuple<^double[], ^double[]>, `net.result`:^double[], `output.vector`:double[]> | ^double[]> => tuple<^double[], ^double[]> | ^double[] | character[] | struct<`generalized.weights`:^double[], `weights`:tuple<^double[], ^double[]>, `startweights`:tuple<^double[], ^double[]>, `net.result`:^double[], `output.vector`:double[]>;
type `gwplot` <struct<`call`:language, `response`:^double[], `covariate`:^double[], `model.list`:struct<`response`:character, `variables`:character[]>, `err.fct`:any => any, `act.fct`:any => any, `linear.output`:logical, `data`:struct<`education`:integer[], `age`:double[], `parity`:double[], `induced`:double[], `case`:double[], `spontaneous`:double[], `stratum`:integer[], `pooled.stratum`:double[]>, `exclude`:null, `net.result`:tuple<^double[]>, `weights`:tuple<tuple<^double[], ^double[]>>, `generalized.weights`:tuple<^double[]>, `startweights`:tuple<tuple<^double[], ^double[]>>, `result.matrix`:^double[]>, null, null, null, null, character, double, logical, character, character, null> => null;
type `neuralnet` <language, struct<`education`:integer[], `age`:double[], `parity`:double[], `induced`:double[], `case`:double[], `spontaneous`:double[], `stratum`:integer[], `pooled.stratum`:double[]>, double, double, double, double, null, symbol, double, null, character, double, character, character, double, logical, null, null, logical> => struct<`call`:language, `response`:^double[], `covariate`:^double[], `model.list`:struct<`response`:character, `variables`:character[]>, `err.fct`:any => any, `act.fct`:any => any, `linear.output`:logical, `data`:struct<`education`:integer[], `age`:double[], `parity`:double[], `induced`:double[], `case`:double[], `spontaneous`:double[], `stratum`:integer[], `pooled.stratum`:double[]>, `exclude`:null, `net.result`:tuple<^double[]>, `weights`:tuple<tuple<^double[], ^double[]>>, `generalized.weights`:tuple<^double[]>, `startweights`:tuple<tuple<^double[], ^double[]>>, `result.matrix`:^double[]>;
type `output.act.deriv.fct` <^double[]> => ^double[];
type `output.act.deriv2.fct` <^double[]> => ^double[];
type `output.act.fct` <^double[]> => ^double[];
type `plus` <double[], double[], tuple<^double[], ^double[]>, integer[], integer[], double[], struct<`minus`:double, `plus`:double> | symbol, struct<`min`:double, `max`:double> | symbol, double> => struct<`gradients.old`:double[], `weights`:tuple<^double[], ^double[]>, `learningrate`:double[]>;
type `relist` <double[], double[], double[]> => tuple<^double[], ^double[]>;
