type `act.deriv2.fct` <class<`matrix`>> => class<`matrix`>;
type `act.deriv.fct` <class<`matrix`>> => class<`matrix`> | <class<`matrix`>> => class<`matrix`>;
type `act.fct` <class<`matrix`>> => class<`matrix`>;
type `calculate.generalized.weights` <list<class<`matrix`>>, list<class<`matrix`>>, class<`matrix`>> => class<`matrix`>;
type `calculate.gradients` <list<class<`matrix`>>, integer, list<class<`matrix`>>, list<class<`matrix`>>, class<`matrix`>, double, logical> => double[];
type `calculate.information.matrices` <class<`matrix`>, class<`matrix`>, list<class<`matrix`>>, class<`function`>, class<`function`>, null, logical> => list<double | class<`matrix`>>;
type `calculate.neuralnet` <any, list<character[]>, double, double, integer, double, list<double>, list<double>, character, class<`matrix`>, class<`matrix`>, any> => list<class<`matrix`> | double[] | list<class<`matrix`>>>;
type `compute.net` <list<class<`matrix`>>, integer, class<`matrix`>, class<`function`>, class<`function`>, class<`function`>, class<`function`>, logical> => list<class<`matrix`> | list<class<`matrix`>>>;
type `confidence.interval` <class<`nn`>, double> => list<double | list<list<class<`matrix`>>>>;
type `convert.activation.function` <character> => list<class<`function`>>;
type `convert.error.function` <character> => list<class<`function`>>;
type `err.deriv2.fct` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `err.deriv.fct` <class<`matrix`>, class<`matrix`>> => class<`matrix`> | <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `err.fct` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `filter` <character[]> => logical[];
type `FUN` <list<class<`matrix`> | double[] | list<class<`matrix`>>>> => list<class<`matrix`>> | <class<`matrix`>> => class<`matrix`> | <list<class<`matrix`> | double[] | list<class<`matrix`>>>> => class<`matrix`> | <integer> => character[] | <list<class<`matrix`> | double[] | list<class<`matrix`>>>> => list<class<`matrix`>> | <list<class<`matrix`> | double[] | list<class<`matrix`>>>> => class<`matrix`> | <integer> => list<class<`matrix`> | double[] | list<class<`matrix`>>> | <list<class<`matrix`> | double[] | list<class<`matrix`>>>> => double[] | <integer> => character;
type `generate.output` <class<`matrix`>, class<`call`>, any, any, class<`matrix`>, any, list<character[]>, class<`matrix`>, class<`function`>, class<`function`>, class<`data.frame`>, list<list<class<`matrix`> | double[] | list<class<`matrix`>>>>> => class<`nn`>;
type `generate.startweights` <list<character[]>, double, null, integer, null, any> => list<null | list<class<`matrix`>>>;
type `get_weight_names` <list<class<`matrix`>>, list<character[]>> => character[];
type `gwplot` <class<`nn`>, null, null, null, null, character, double, logical, character, character, ...> => null;
type `neuralnet` <class<`formula`>, class<`data.frame`>, double, double, double, double, null, null, list<double>, null, character, double> => class<`nn`>;
type `output.act.deriv2.fct` <class<`matrix`>> => class<`matrix`>;
type `output.act.deriv.fct` <class<`matrix`>> => class<`matrix`> | <class<`matrix`>> => class<`matrix`>;
type `output.act.fct` <class<`matrix`>> => class<`matrix`>;
type `plus` <double[], double[], list<class<`matrix`>>, integer[], integer[], double[], any, any, double> => list<double[] | list<class<`matrix`>>>;
type `relist` <double[], class<`array`> | integer[], class<`array`> | integer[]> => list<class<`matrix`>>;
type `rprop` <list<class<`matrix`>>, class<`matrix`>, class<`matrix`>, double, list<double>, list<double>, double, character, any, class<`function`>, class<`function`>, class<`function`>> => list<double | class<`matrix`> | list<class<`matrix`>>>;
