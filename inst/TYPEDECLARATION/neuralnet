type `calculate.data.result` <class<`matrix`>, class<`matrix`>, any> => class<`matrix`>;
type `calculate.delta` <double[], double[], double> => double[];
type `calculate.generalized.weights` <list<class<`matrix`>>, list<class<`matrix`>>, class<`matrix`>> => class<`matrix`>;
type `calculate.gradients` <any, integer, list<class<`matrix`>>, any, class<`matrix`>, double, logical> => double[];
type `calculate.information.matrices` <class<`matrix`>, class<`matrix`>, list<class<`matrix`>>, class<`function`>, class<`function`>, null, logical> => list<double | class<`matrix`>>;
type `calculate.neuralnet` <any, list<character[]>, double[], double, integer, double, list<double>, list<double>, character, class<`matrix`>, class<`matrix`>, any, null, character, class<`function`>, class<`function`>, class<`function`>, any, logical, logical> => list<class<`matrix`> | double[] | list<class<`matrix`>>>;
type `calculate.predictions` <class<`matrix`>, class<`matrix`>, null | list<class<`glm`, `lm`>>, class<`matrix`>, list<class<`matrix`>>, list<character[]>> => list<class<`matrix`>>;
type `compute.net` <list<class<`matrix`>>, integer, class<`matrix`>, any, any, class<`function`>, class<`function`>, logical> => list<class<`matrix`> | list<class<`matrix`>>>;
type `confidence.interval` <class<`nn`>, double> => list<double | list<list<class<`matrix`>>>>;
type `convert.activation.function` <character> => list<class<`function`>>;
type `convert.error.function` <character> => list<class<`function`>>;
type `draw.text` <character | double, double[], double[], double[] | class<`matrix`>, character, character[], ...> => class<`gDesc`, `grob`, `text`>;
type `generate.output` <class<`matrix`>, class<`call`>, any, any, class<`matrix`>, any, list<character[]>, class<`matrix`>, class<`function`>, class<`function`>, class<`data.frame`>, list<list<class<`matrix`> | double[] | list<class<`matrix`>>>>, logical, null> => class<`nn`>;
type `generate.startweights` <list<character[]>, double[], null, integer, null, any> => list<null | list<class<`matrix`>>>;
type `get_weight_names` <list<class<`matrix`>>, list<character[]>> => character[];
type `gwplot` <class<`nn`>, null, null, null, null, character, double, logical, character, character, ...> => null;
type `neuralnet` <class<`formula`>, class<`data.frame`>, double[], double, double, double, null, null, list<double>, null, character, double, character, character, class<`function`> | character, logical, null, null, logical> => class<`nn`>;
type `plot.nn` <class<`nn`>, character, null, null, double, double, logical, double, logical, double, character, character, character, character, character, character, character, double, double, logical> => null;
type `plus` <double[], double[], list<class<`matrix`>>, integer[], integer[], double[], any, any, double> => list<double[] | list<class<`matrix`>>>;
type `prediction` <class<`nn`>, null | list<class<`glm`, `lm`>>> => list<class<`matrix`>>;
type `predict.nn` <class<`nn`>, class<`data.frame`>, double, logical, ...> => class<`matrix`>;
type `relist` <double[], class<`array`> | integer[], class<`array`> | integer[]> => list<class<`matrix`>>;
type `rprop` <list<class<`matrix`>>, class<`matrix`>, class<`matrix`>, double, list<double>, list<double>, double, character, any, class<`function`>, class<`function`>, any, any, character, logical, null, any> => list<double | class<`matrix`> | list<class<`matrix`>>>;
