type `%*%` <class<`bigq`> | class<`bigz`> | class<`matrix`> | double[], class<`bigq`> | class<`matrix`> | class<`bigz`>> => (class<`bigq`> | class<`bigz`> | class<`matrix`>);
type `abs.bigq` <class<`bigq`>> => class<`bigq`>;
type `abs.bigz` <class<`bigz`>> => class<`bigz`>;
type `all.equal.bigq` <class<`bigq`>, double[] | class<`matrix`>, double, null, logical, logical, ...> => logical;
type `all.equal.bigz` <class<`bigz`>, double[], ...> => logical;
type `apply` <class<`bigq`> | class<`bigz`>, double, class<`function`>, ...> => (class<`bigq`> | class<`bigz`>);
type `apply.bigq` <class<`bigq`>, double, class<`function`>, ...> => class<`bigq`>;
type `apply.bigz` <class<`bigz`>, double, class<`function`>, ...> => class<`bigz`>;
type `as.bigq` <class<`bigz`> | ^double[] | null | class<`matrix`> | character | class<`bigq`>, class<`bigz`> | character | class<`bigq`> | null | double[]> => any;
type `as.bigz` <character | class<`bigq`> | class<`bigz`> | ^double[] | null | class<`matrix`>, null | ^logical[] | character | class<`bigq`> | class<`bigz`> | double[]> => any;
type `as.bigz.bigq` <class<`bigq`>, any> => any;
type `as.character.bigq` <class<`bigq`>, integer, ...> => character[];
type `as.character.bigz` <class<`bigz`>, double, ...> => character[];
type `as.double.bigq` <class<`bigq`>, ...> => (^double[] | null);
type `as.double.bigz` <class<`bigz`>, ...> => (^double[] | null);
type `as.integer.bigq` <class<`bigq`>, ...> => ^integer[];
type `as.integer.bigz` <class<`bigz`>, ...> => (^integer[] | null);
type `as.matrix.bigq` <class<`bigq`>, ...> => class<`bigq`>;
type `as.matrix.bigz` <class<`bigz`>, ...> => class<`bigz`>;
type `asNumeric` <class<`bigq`>> => (class<`matrix`> | ^double[]) | <class<`bigz`>> => (class<`matrix`> | ^double[]) | <class<`matrix`>> => class<`matrix`> | <class<`bigq`> | class<`bigz`> | class<`matrix`>> => (class<`matrix`> | ^double[]);
type `as.vector.bigq` <class<`bigq`>, character> => (class<`bigq`> | list<class<`bigq`>>);
type `as.vector.bigz` <class<`bigz`>, character> => (class<`bigz`> | list<class<`bigz`>>);
type `^.bigq` <any, double | class<`bigq`>> => any;
type `<=.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => (class<`matrix`> | ^logical[]);
type `<.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => ^logical[];
type `==.bigq` <class<`bigq`> | class<`matrix`> | ^double[] | null, class<`matrix`> | class<`bigq`> | ^double[]> => (class<`matrix`> | ^logical[]);
type `>=.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => ^logical[];
type `>.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => ^logical[];
type `-.bigq` <class<`bigq`> | ^double[] | null, class<`bigq`> | ^double[] | class<`matrix`>> => class<`bigq`>;
type `!=.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => ^logical[];
type `/.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => class<`bigq`>;
type `[<-.bigq` <class<`bigq`>, double | integer[], null | double, double[] | null | list<double>> => any;
type `[.bigq` <class<`bigq`>, double[], null | integer[] | double, logical> => any;
type `*.bigq` <class<`bigq`> | double | null, class<`bigq`> | ^double[]> => class<`bigq`>;
type `%*%.bigq` <class<`bigq`>, class<`bigq`> | class<`matrix`>> => class<`bigq`>;
type `+.bigq` <class<`bigq`> | ^double[] | null, class<`bigq`> | ^double[]> => class<`bigq`>;
type `^.bigz` <class<`bigz`> | double | null | integer[], class<`bigz`> | ^double[], ...> => (class<`bigq`> | class<`bigz`>);
type `<=.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => ^logical[];
type `<.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => (class<`matrix`> | ^logical[]);
type `==.bigz` <class<`bigz`> | ^double[] | null, class<`bigz`> | class<`matrix`> | ^double[]> => (class<`matrix`> | ^logical[]);
type `>=.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => ^logical[];
type `>.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => (class<`matrix`> | ^logical[]);
type `-.bigz` <class<`bigz`> | ^double[] | null, class<`bigz`> | ^double[]> => class<`bigz`>;
type `!=.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => ^logical[];
type `/.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => (class<`bigq`> | class<`bigz`>);
type `[<-.bigz` <class<`bigz`>, double | integer[] | class<`matrix`>, null | double, class<`bigz`> | double[] | list<double> | null> => any;
type `[.bigz` <class<`bigz`>, double[] | ^logical[] | null, null | integer[] | double, logical> => any;
type `[[<-.bigz` <class<`bigz`>, double, class<`bigz`>> => class<`bigz`>;
type `*.bigz` <class<`bigz`> | double | null, class<`bigz`> | ^double[]> => class<`bigz`>;
type `%/%.bigz` <class<`bigz`> | double | integer[] | null | character | class<`bigq`>, class<`bigz`> | ^double[] | character | class<`bigq`> | null> => class<`bigz`>;
type `%*%.bigz` <class<`bigz`>, class<`bigq`> | class<`bigz`> | class<`matrix`>> => (class<`bigq`> | class<`bigz`>);
type `%%.bigz` <class<`bigz`> | double | integer[] | null, class<`bigz`> | ^double[] | character> => class<`bigz`>;
type `+.bigz` <class<`bigz`> | ^double[] | null, class<`bigz`> | ^double[]> => class<`bigz`>;
type `c.bigq` <..., logical> => class<`bigq`>;
type `c.bigz` <..., logical> => class<`bigz`>;
type `chooseZ` <class<`bigz`> | double[], double[] | class<`bigz`>> => class<`bigz`>;
type `crossprod` <class<`bigq`> | class<`bigz`>, class<`bigq`> | null | class<`bigz`>> => (class<`bigq`> | class<`bigz`>);
type `crossprod.bigq` <class<`bigq`>, class<`bigq`> | null> => class<`bigq`>;
type `crossprod.bigz` <class<`bigz`>, class<`bigq`> | class<`bigz`> | null> => (class<`bigq`> | class<`bigz`>);
type `cumsum.bigq` <class<`bigq`>> => class<`bigq`>;
type `cumsum.bigz` <class<`bigz`>> => class<`bigz`>;
type `%*%.default` <class<`matrix`> | double[], class<`bigq`> | class<`bigz`> | class<`matrix`>> => (class<`bigq`> | class<`bigz`> | class<`matrix`>);
type `denominator` <class<`bigq`>> => class<`bigz`>;
type `dim<-.bigq` <class<`bigq`> | class<`bigz`>, double[]> => (class<`bigq`> | class<`bigz`>);
type `dim.bigq` <class<`bigq`> | class<`bigz`>> => (double[] | null);
type `dim<-.bigz` <class<`bigq`> | class<`bigz`>, double[]> => (class<`bigq`> | class<`bigz`>);
type `dim.bigz` <class<`bigq`> | class<`bigz`>> => (double[] | null);
type `divq.bigz` <class<`bigz`> | double | integer[] | null | character | class<`bigq`>, class<`bigz`> | ^double[] | character | class<`bigq`> | null> => class<`bigz`>;
type `duplicated.bigq` <class<`bigq`> | class<`bigz`>, logical, ...> => logical[];
type `duplicated.bigz` <class<`bigq`> | class<`bigz`>, logical, ...> => logical[];
type `Eulerian.all` <double> => class<`bigz`>;
type `factorialZ` <class<`bigz`> | double[]> => class<`bigz`>;
type `factorize` <character | class<`bigz`> | double | class<`bigq`> | null> => any;
type `fibnum` <class<`bigz`> | double | integer[]> => class<`bigz`>;
type `fibnum2` <class<`bigz`> | double | integer[]> => class<`bigz`>;
type `formatN` <class<`bigq`> | class<`bigz`> | double[], ...> => character[];
type `formatN.bigq` <class<`bigq`>, ...> => character[];
type `formatN.bigz` <class<`bigz`>, ...> => character[];
type `formatN.default` <character | null, ...> => character;
type `formatN.double` <double[], ...> => character[];
type `formatN.integer` <integer[], ...> => character[];
type `frexpZ` <class<`bigz`> | double[]> => list<double[]>;
type `gcd` <class<`bigz`>, class<`bigz`>> => class<`bigz`>;
type `gcd.bigz` <character | class<`bigq`> | class<`bigz`> | null | double[], character | class<`bigq`> | class<`bigz`> | null | double[]> => class<`bigz`>;
type `gcd.default` <double[] | null, double[] | null> => (integer[] | null);
type `gcdex` <double, double> => class<`bigz`>;
type `gmpVersion` < > => class<`numeric_version`>;
type `.gmpVersion` < > => character;
type `inv.bigz` <double | integer[], double, ...> => class<`bigz`>;
type `is.bigq` <class<`bigq`> | class<`bigz`> | double> => logical;
type `is.bigz` <class<`bigq`> | class<`bigz`> | double> => logical;
type `is.finite.bigq` <class<`bigq`>> => logical[];
type `is.finite.bigz` <class<`bigz`>> => logical[];
type `is.infinite.bigq` <class<`bigq`> | class<`bigz`>> => logical[];
type `is.infinite.bigz` <class<`bigq`> | class<`bigz`>> => logical[];
type `is.matrixZQ` <class<`bigz`> | double> => logical;
type `is.na.bigq` <class<`bigq`>> => logical[];
type `is.na.bigz` <class<`bigz`>> => logical[];
type `isprime` <integer[] | class<`bigz`> | double, double> => integer[];
type `is.whole` <class<`bigq`> | class<`bigz`> | complex[] | null | character> => logical[];
type `is.whole.bigq` <class<`bigq`>> => logical[];
type `is.whole.bigz` <class<`bigz`>> => logical[];
type `is.whole.default` <complex[] | null | character> => logical[];
type `lcm.bigz` <class<`bigz`> | double, class<`bigz`> | double> => class<`bigz`>;
type `length.bigq` <class<`bigq`>> => integer;
type `length.bigz` <class<`bigz`>> => integer;
type `ln.bigz` <class<`bigz`> | null | character | class<`bigq`> | double> => double[];
type `log2.bigz` <class<`bigz`>> => double[];
type `log.bigz` <class<`bigz`>, any> => double[];
type `lucnum` <class<`bigz`> | double | integer[]> => class<`bigz`>;
type `lucnum2` <class<`bigz`> | double | integer[]> => class<`bigz`>;
type `matrix` <class<`bigq`> | class<`bigz`> | double[] | character, double, double, logical, ...> => (class<`bigq`> | class<`bigz`> | class<`matrix`>);
type `matrix.bigq` <class<`bigq`>, double, double, logical, null, null, ...> => class<`bigq`>;
type `matrix.bigz` <integer[] | class<`bigz`>, double, double, logical, null, null, ...> => class<`bigz`>;
type `matrix.default` <...> => class<`matrix`>;
type `max.bigq` <..., logical> => class<`bigq`>;
type `max.bigz` <..., logical> => class<`bigz`>;
type `mean.bigq` <class<`bigq`>, double, logical, ...> => class<`bigq`>;
type `min.bigq` <..., logical> => class<`bigq`>;
type `min.bigz` <..., logical> => class<`bigz`>;
type `mod.bigz` <class<`bigz`> | double | integer[] | null, class<`bigz`> | ^double[] | character> => class<`bigz`>;
type `modulus` <class<`bigz`>> => (class<`bigz`> | null);
type `modulus<-` <class<`bigz`>, null | class<`bigz`> | double> => class<`bigz`>;
type `modulus<-.bigz` <class<`bigz`>, null | class<`bigz`> | double> => class<`bigz`>;
type `modulus.bigz` <class<`bigz`>> => (class<`bigz`> | null);
type `nextprime` <double> => class<`bigz`>;
type `numerator` <class<`bigq`>> => class<`bigz`>;
type `numerator<-` <class<`bigq`>, class<`bigz`>> => class<`bigq`>;
type `outer` <class<`bigz`> | double[], double[], class<`function`> | character, ...> => (class<`bigz`> | class<`matrix`>);
type `pow.bigz` <class<`bigz`> | double | null | integer[], class<`bigz`> | ^double[], ...> => (class<`bigq`> | class<`bigz`>);
type `powm` <double, double, double> => class<`bigz`>;
type `prod.bigq` <..., logical> => class<`bigq`>;
type `prod.bigz` <..., logical> => class<`bigz`>;
type `rep.bigq` <class<`bigq`>, double, double | null, double, ...> => class<`bigq`>;
type `rep.bigz` <class<`bigz`>, double, double | null, double, ...> => class<`bigz`>;
type `sign.bigq` <class<`bigq`>> => integer[];
type `sign.bigz` <class<`bigz`>> => integer[];
type `sizeinbase` <class<`bigz`> | double, double> => integer[];
type `solve.bigq` <class<`bigq`>, any, ...> => class<`bigq`>;
type `solve.bigz` <class<`bigz`>, any, ...> => any;
type `Stirling1` <double, double> => class<`bigz`>;
type `Stirling1.all` <double> => class<`bigz`>;
type `Stirling2` <double, double, character[]> => class<`bigz`>;
type `Stirling2.all` <double> => class<`bigz`>;
type `sum.bigq` <..., logical> => class<`bigq`>;
type `sum.bigz` <..., logical> => class<`bigz`>;
type `t.bigq` <class<`bigq`>> => class<`bigq`>;
type `t.bigz` <class<`bigz`>> => class<`bigz`>;
type `tcrossprod` <class<`bigq`> | class<`bigz`> | class<`matrix`>, class<`bigq`> | null | class<`bigz`>> => (class<`bigq`> | class<`bigz`>);
type `tcrossprod.bigq` <class<`bigq`>, class<`bigq`> | null> => class<`bigq`>;
type `tcrossprod.bigz` <class<`bigz`>, class<`bigz`> | null> => class<`bigz`>;
type `tcrossprod.default` <class<`matrix`>, class<`bigz`>> => class<`bigz`>;
type `unique.bigq` <class<`bigq`> | class<`bigz`>, logical, ...> => (class<`bigq`> | class<`bigz`>);
type `unique.bigz` <class<`bigq`> | class<`bigz`>, logical, ...> => (class<`bigq`> | class<`bigz`>);
type `urand.bigz` <double, double, character | double> => class<`bigz`>;
type `which.max` <class<`bigq`>> => integer | <class<`bigz`>> => integer;
type `which.min` <class<`bigz`>> => integer | <class<`bigq`>> => integer;
