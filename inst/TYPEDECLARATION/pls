type `::` <any, any, any, any, any, any, character, logical, logical, character[], logical, logical> => class<`mvr`>;
type `cancorr` <class<`matrix`>, class<`AsIs`> | class<`matrix`>, null, logical> => list<class<`matrix`> | double>;
type `coef.mvr` <class<`mvr`>, any, any, logical, ...> => class<`array`>;
type `compnames` <class<`mvr`>, any, logical, ...> => character[];
type `cppls` <..., any, any, character> => class<`mvr`>;
type `crossval` <class<`mvr`>, double, character[], any, logical, double, ...> => class<`mvr`>;
type `cvsegments` <double, any, double, double, character[]> => list<double[]>;
type `delete.intercept` <class<`matrix`>> => class<`matrix`>;
type `explvar` <class<`mvr`> | class<`scores`>> => double[];
type `filter` <character[]> => logical[];
type `fitFunc` <class<`matrix`>, class<`matrix`> | class<`AsIs`>, double, logical, logical, any, double, ...> => list<any> | <class<`matrix`>, class<`AsIs`> | class<`matrix`>, double, logical, logical, ...> => list<any> | <class<`matrix`>, class<`AsIs`> | class<`matrix`>, double, class<`matrix`> | null, logical, logical, double, double, logical, null, ...> => list<any> | <class<`matrix`>, class<`matrix`> | class<`AsIs`>, double, logical, logical, ...> => list<any> | <class<`matrix`>, class<`matrix`> | class<`AsIs`>, double, logical, logical, ...> => list<any>;
type `fitted.mvr` <class<`mvr`>, ...> => class<`array`>;
type `FUN` <class<`matrix`>> => double[] | <integer> => double | <double[] | ^integer[]> => double[] | <integer> => list<class<`matrix`> | class<`array`> | null> | <integer> => list<any>;
type `jack.test` <class<`mvr`>, double, logical> => class<`jacktest`>;
type `lapplyFunc` <null, integer[], class<`function`>, any> => list<list<any>>;
type `loadings` <class<`mvr`>, ...> => class<`loadings`>;
type `loadings.default` <class<`mvr`>, ...> => class<`loadings`>;
type `makepredictcall.msc` <class<`matrix`, `msc`>, class<`call`>> => class<`call`>;
type `makepredictcall.stdized` <class<`matrix`, `stdized`>, class<`call`>> => class<`call`>;
type `model.frame.mvr` <class<`mvr`>, ...> => class<`data.frame`>;
type `model.matrix.mvr` <class<`mvr`>, ...> => class<`matrix`>;
type `msc` <class<`matrix`>, double[] | null> => class<`matrix`, `msc`>;
type `MSEP` <class<`mvr`>, ...> => class<`mvrVal`>;
type `MSEP.mvr` <class<`mvr`>, any, any, any, any, any, logical, ...> => class<`mvrVal`>;
type `mvr` <any, any, any, any, any, any, character, logical, logical, character[], logical, logical> => class<`mvr`>;
type `mvrCv` <class<`matrix`>, class<`AsIs`> | class<`matrix`>, double, null, null, character, logical, double | list<integer>, any, any, logical, logical> => list<any>;
type `mvrValstats` <class<`mvr`>, character[], any, integer[], any, logical, logical, ...> => list<any>;
type `norm` <class<`matrix`>> => double;
type `pcr` <..., character> => class<`mvr`>;
type `pls.options` <...> => list<character | null | double | character>;
type `plsr` <..., character> => class<`mvr`>;
type `predict.msc` <class<`matrix`, `msc`>, class<`matrix`>, ...> => class<`matrix`, `msc`>;
type `predict.mvr` <class<`mvr`>, any, any, any, character[], any, ...> => (class<`array`> | class<`matrix`>);
type `predict.stdized` <class<`matrix`, `stdized`>, class<`matrix`>, ...> => class<`matrix`, `stdized`>;
type `print.mvrVal` <class<`mvrVal`>, double, double, ...> => class<`mvrVal`>;
type `R2` <class<`mvr`>, ...> => class<`mvrVal`>;
type `R2.mvr` <class<`mvr`>, character, any, any, any, logical, logical, ...> => class<`mvrVal`>;
type `randomiz.test` <double[], double[], double> => double;
type `Rcal` <class<`matrix`>, class<`matrix`>, class<`AsIs`> | class<`matrix`>, null> => list<class<`matrix`> | double[] | class<`matrix`> | double>;
type `residuals.mvr` <class<`mvr`>, ...> => class<`array`>;
type `respnames` <class<`mvr`>> => character;
type `RMSEP` <class<`mvr`>, ...> => class<`mvrVal`>;
type `RMSEP.mvr` <class<`mvr`>, ...> => class<`mvrVal`>;
type `scores` <class<`mvr`>, ...> => class<`scores`>;
type `scores.default` <class<`mvr`>, ...> => class<`scores`>;
type `selectNcomp` <class<`mvr`>, character, double, double, double, logical, ...> => double;
type `stdize` <class<`matrix`>, double[], double[]> => class<`matrix`, `stdized`>;
type `summary.mvr` <class<`mvr`>, character[], double, double, ...> => null;
type `var.jack` <class<`mvr`>, double, logical, logical> => class<`array`>;
