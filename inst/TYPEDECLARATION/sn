type `affineTransSECdistr` <class<`SECdistrMv`>, double[], class<`matrix`>, any, any, logical> => class<`SECdistrMv`>;
type `coef` <class<`mselm`>, ...> => (double[] | list<class<`matrix`> | double[]>) | <class<`selm`>, ...> => double[];
type `conditionalSECdistr` <class<`SECdistrMv`>, double, double, any, logical> => class<`SECdistrMv`>;
type `cp2dpUv` <double[], character, logical, double> => double[];
type `delta.etc` <double[], class<`matrix`>> => list<double[] | class<`matrix`>>;
type `dp2cpMv` <list<class<`matrix`> | double[]>, character, character, null, logical, null> => list<class<`matrix`> | double[]>;
type `dp2cpUv` <double[], character, character, null> => double[];
type `dsn` <double[], double[], double, double, double, null, logical> => double[];
type `duplicationMatrix` <integer> => class<`matrix`>;
type `filter` <character[]> => logical[];
type `force.symmetry` <class<`matrix`>, double> => class<`matrix`>;
type `fun` <any, any> => null;
type `gradient` <double[], class<`matrix`>, class<`matrix`>, double[], logical> => double[] | <double[], class<`matrix`>, double[], double[], null, logical, logical> => double[];
type `hessian` <double[], class<`matrix`>, double[], double[], null, logical> => class<`matrix`>;
type `.local` <class<`mselm`>, character, logical, ...> => (double[] | list<class<`matrix`> | double[]>) | <class<`selm`>, character, ...> => double[];
type `makeSECdistr` <list<double[] | class<`matrix`> | class<`matrix`> | double[]>, character, any, any> => class<`SECdistrMv`>;
type `marginalSECdistr` <class<`SECdistrMv`>, double[], character, logical> => class<`SECdistrMv`>;
type `msn.dev` <double[], class<`matrix`>, class<`matrix`>, double[], logical> => double;
type `msn.dp2cp` <list<class<`matrix`> | double[]>, logical> => list<class<`matrix`> | double[]>;
type `msn.mle` <class<`matrix`>, class<`matrix`>, null, double[], logical, character, list<any>> => list<class<`call`> | double | list<class<`matrix`> | double[] | double | double[] | character>>;
type `msn.moment.fit` <class<`matrix`>> => list<double[] | class<`matrix`>>;
type `objective` <double[], class<`matrix`>, class<`matrix`>, double[], logical> => double | <double[], class<`matrix`>, double[], double[], null, logical> => double;
type `param.names` <character, character, double, character[] | null, any> => character[];
type `selm` <class<`formula`>, character, any, any, any, any, null, list<any>, character, null, logical, logical> => (class<`mselm`> | class<`selm`>);
type `selm.fit` <class<`matrix`>, double[] | class<`matrix`>, character, null, double[], list<any>, null, list<any>> => list<any>;
type `show` <class<`SECdistrMv`>> => null;
type `sn.infoMv` <list<class<`matrix`> | double[]>, class<`matrix`>, class<`matrix`>, double[], null, double, logical> => list<character | class<`matrix`> | list<class<`matrix`> | double[] | class<`matrix`> | double[] | null>>;
type `sn.infoUv` <double[], null, class<`matrix`>, double[], double[], null, double> => list<any>;
type `sn.mple` <class<`matrix`>, double[], null, double[], null, logical, character, null> => list<class<`call`> | double[] | list<double[] | character>>;
type `sn.pdev.gh` <double[], class<`matrix`>, double[], double[], null, logical, logical> => double[];
type `validityMethod` <class<`mselm`>> => logical | <class<`SECdistrMv`>> => logical | <class<`selm`>> => logical;
type `vech` <class<`matrix`>> => double[];
type `zeta` <double, class<`matrix`> | double[]> => (class<`matrix`> | double[]);
