type `affineTransSECdistr` <class<`SECdistrMv`>, double[], class<`matrix`>, any, any, logical> => class<`SECdistrMv`>;
type `b` <double | null> => (double | null);
type `conditionalSECdistr` <class<`SECdistrMv`>, double, double, any, logical> => class<`SECdistrMv`>;
type `cp2dp` <double[] | list<double[] | class<`matrix`>>, character> => (double[] | list<double[] | class<`matrix`>>);
type `cp2dpMv` <list<double[] | class<`matrix`>>, character, logical, double> => list<double[] | class<`matrix`>>;
type `cp2dpUv` <double[], character, logical, double> => double[];
type `delta.etc` <double[], null | class<`matrix`>> => (double[] | list<double[] | class<`matrix`>>);
type `dmsn` <class<`matrix`>, double[], class<`matrix`>, double[], double, null, logical> => double[];
type `dmst` <any, any, any, any, double, list<double[] | class<`matrix`>> | null, logical> => (double[] | null);
type `dp2cp` <any, any, null | class<`SECdistrUv`> | class<`SECdistrMv`>, character, null | double> => (double[] | list<double[] | class<`matrix`>> | list<double[]>);
type `dp2cpMv` <list<class<`matrix`> | double[]> | list<double[] | class<`matrix`>>, character, character, null, logical, null | double> => (list<class<`matrix`> | double[]> | list<double[]> | list<double[] | class<`matrix`>> | list<double[] | class<`matrix`> | list<double[] | class<`matrix`>>> | list<double[] | class<`matrix`> | list<null | double[] | class<`matrix`>>>);
type `dp2cpUv` <double[], character, character, null | double> => double[];
type `dp2op` <list<class<`matrix`> | double[]>, character> => list<class<`matrix`> | double[]>;
type `dplist2optpar` <list<class<`matrix`> | double[]>, null> => double[];
type `dsc` <double[], double, double, double, null, logical> => double[];
type `dsn` <class<`matrix`> | double[], double[], double, double, double, double[] | null, logical> => double[];
type `dst` <double[], double[], double, double, double, double[] | null, logical> => double[];
type `dSymmModulated` <double[], double, double, character, character, class<`function`>, any, any, character, logical, ...> => double[];
type `duplicationMatrix` <integer> => class<`matrix`>;
type `extractSECdistr` <class<`mselm`> | class<`selm`>, any, any> => (class<`SECdistrMv`> | class<`SECdistrUv`>);
type `fitted` <class<`mselm`>, ...> => class<`matrix`> | <class<`selm`>, ...> => double[];
type `force.symmetry` <class<`matrix`>, double> => class<`matrix`>;
type `makeSECdistr` <list<class<`matrix`> | double[]> | list<double[] | class<`matrix`>> | double[], character, any, any> => (class<`SECdistrMv`> | class<`SECdistrUv`>);
type `marginalSECdistr` <class<`SECdistrMv`>, double[], any, logical> => (class<`SECdistrMv`> | class<`SECdistrUv`>);
type `mean` <class<`SECdistrMv`>, ...> => double[] | <class<`SECdistrUv`>, ...> => double;
type `modeSECdistr` <any, any, class<`SECdistrMv`> | null> => double[];
type `modeSECdistrMv` <list<double[] | class<`matrix`>> | list<class<`matrix`> | double[]>, character> => double[];
type `modeSECdistrUv` <double[], character> => double;
type `msn.cp2dp` <list<double[] | class<`matrix`>>, any> => list<double[] | class<`matrix`>>;
type `msn.dev` <double[], class<`matrix`>, class<`matrix`>, double[], logical> => double;
type `msn.dp2cp` <list<class<`matrix`> | double[]> | list<double[] | class<`matrix`>>, logical> => (list<class<`matrix`> | double[]> | list<double[] | class<`matrix`> | list<double[] | class<`matrix`>>> | list<double[] | class<`matrix`>>);
type `msn.mle` <class<`matrix`>, class<`matrix`>, null, any, logical, character, list<any>> => (list<class<`call`> | double | list<class<`matrix`> | double[] | double | double[] | null | character>> | list<class<`call`> | double | list<class<`matrix`> | double[] | double | double[] | character>>);
type `msn.moment.fit` <class<`matrix`>> => list<double[] | class<`matrix`>>;
type `mst.cp2dp` <list<double[] | class<`matrix`>>, any, any, logical> => list<double[] | class<`matrix`>>;
type `mst.dp2cp` <list<class<`matrix`> | double[]> | list<class<`matrix`> | double>, character, null, any, logical, null | double> => (null | list<class<`matrix`>> | list<class<`matrix`> | double[]> | list<class<`matrix`> | double> | list<double[]> | list<double[] | class<`matrix`>> | list<double[] | class<`matrix`> | list<null | double[] | class<`matrix`>>>);
type `mst.gamma2M` <double, double, integer> => double;
type `mst.mardia` <double, double, integer> => double[];
type `mst.mple` <class<`matrix`>, class<`matrix`>, null, double[], null, logical, null, logical, character, list<any>> => (list<class<`call`> | double | list<class<`matrix`> | double[] | null | double | double[] | character>> | list<class<`call`> | double | list<any>>);
type `mst.theta.jacobian` <double[], integer, integer, character> => list<class<`matrix`>>;
type `op2dp` <list<double[] | class<`matrix`>> | list<class<`matrix`> | double[]>, character> => (list<double[] | class<`matrix`>> | list<class<`matrix`> | double[]>);
type `optpar2dplist` <double[], integer, integer, null | character[], null | character[]> => list<class<`matrix`> | double[] | list<class<`matrix`> | double[]>>;
type `param.names` <character, character, double, character[] | null, any> => character[];
type `plot2D.SymmModulated` <class<`matrix`>, double[], double[], class<`matrix`>, character, character, class<`function`>, null, null, character, ...> => list<double[] | class<`matrix`>>;
type `plot.SECdistrBv` <class<`SECdistrMv`>, class<`matrix`>, double[], double[], character[], expression | character[], character, class<`matrix`> | null, any, character, ...> => list<any>;
type `pmsn` <class<`matrix`> | double[], double[], class<`matrix`>, double[], double, null, ...> => double[];
type `pmst` <double[], double[], class<`matrix`>, double[], double, null, ...> => double;
type `profile.selm` <class<`selm`>, character, character[], double[] | list<double[]>, any, list<any>, logical, logical, any, logical, ...> => list<any>;
type `psc` <double[], double, double, double, null> => double[];
type `psn` <double[], double, double, double, double, double[] | null, any, ...> => double[];
type `pst` <double[], double, double, double, double, double[] | null, double, ...> => double[];
type `pst_int` <double[], double, double, double, double> => double[];
type `qsc` <double[], double, double, double, null> => double[];
type `qsn` <double[], double, double, double, double, null, double, character, ...> => double[];
type `qst` <double[], double, double, double, double, double, null, double, ...> => double[];
type `qst_bounds` <double[], double, double> => class<`matrix`>;
type `residuals` <class<`mselm`>, ...> => class<`matrix`> | <class<`selm`>, ...> => double[];
type `residuals.mselm` <class<`mselm`>, character, ...> => class<`matrix`>;
type `rmsn` <double, any, any, any, double, list<double[] | class<`matrix`>> | null> => class<`matrix`>;
type `rmst` <double, double[], class<`matrix`>, double[], double, null> => class<`matrix`>;
type `rsc` <double, double, double, double, null> => double[];
type `rsn` <double, double, double, double, double, double[] | null> => double[];
type `rst` <double, double, double, double, double, null> => double[];
type `rSymmModulated` <double, double, double, character, character, class<`function`>, double, double, character, ...> => double[];
type `sd` <class<`SECdistrUv`>, ...> => double | <class<`SECdistrUv`>, ...> => double;
type `selm` <class<`formula`>, character, any, any, any, any, null, list<any>, character, null | character, logical, logical, logical, null, any, ...> => (class<`mselm`> | class<`selm`>);
type `selm.fit` <class<`matrix`>, double[] | class<`matrix`>, character, null, double[], list<any>, null, list<any>> => list<any>;
type `seqLog` <double, double, double, logical> => double[];
type `sn.cumulants` <double, double, double[], double, null | double[], double> => (class<`matrix`> | double[]);
type `sn.infoMv` <list<class<`matrix`> | double[]>, class<`matrix`>, class<`matrix`>, double[], null, double, logical> => list<character | class<`matrix`> | list<class<`matrix`> | double[] | class<`matrix`> | double[] | null>>;
type `sn.infoUv` <double[] | null, null | double[], null | class<`matrix`>, any, any, null | character, double> => list<any>;
type `sn.mple` <class<`matrix`>, double[], null, any, character | null, logical, character[], null | list<any>> => list<class<`call`> | double[] | list<double[] | character>>;
type `sn.pdev.gh` <double[], class<`matrix`>, double[], double[], class<`function`> | null, logical, logical> => double[];
type `st.cp2dp` <double[], character, null, any, double, logical> => (double[] | null);
type `st.cumulants` <double, double, double, double, double[] | null, double> => ^double[];
type `st.dp2cp` <double[], character, null | double, logical, double | null> => double[];
type `st.gamma1` <double[], double> => double[];
type `st.gamma2` <double, double> => double;
type `st.infoMv` <list<class<`matrix`> | double[]> | list<class<`matrix`> | double>, class<`matrix`>, class<`matrix`>, double[], null, logical, null, double> => list<any>;
type `st.infoUv` <double[], null, class<`matrix`>, double[], double[], null | double, logical, null, double> => list<any>;
type `st.mple` <class<`matrix`>, double[], null, any, null | double, logical, null | character, logical, character[], null | list<any>> => list<any>;
type `st.pdev.gh` <double[], class<`matrix`>, double[], double[], null | double, logical, null, logical, logical> => double[];
type `T.Owen` <double[], double, double, double> => double[];
type `vech` <class<`matrix`>> => double[];
type `vech2mat` <double[]> => class<`matrix`>;
type `weights.mselm` <class<`mselm`> | class<`selm`>, ...> => null;
type `weights.selm` <class<`mselm`> | class<`selm`>, ...> => null;
type `zeta` <double, class<`matrix`> | double[]> => (class<`matrix`> | double[]);
