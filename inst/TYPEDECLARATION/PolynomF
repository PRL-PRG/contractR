type `.accumulate` <any, class<`polynom`>, class<`polylist`>, logical> => class<`polynom`>;
type `as.character.polynom` <class<`polynom`>, character, logical, ...> => character;
type `as.function.polylist` <class<`polylist`>, ...> => class<`function`>;
type `as.function.polynom` <class<`polynom`>, character, ...> => class<`function`>;
type `as_polylist` <class<`polylist`> | class<`polynom`> | list<class<`polynom`>>> => class<`polylist`>;
type `coef.polynom` <class<`polynom`>, ...> => double[];
type `c.polylist` <..., logical> => class<`polylist`>;
type `.degree` <class<`polynom`>> => double;
type `deriv` <class<`polynom`> | double[]> => (class<`polynom`> | double[]);
type `deriv.polynom` <class<`polynom`>, ...> => class<`polynom`>;
type `.effectively_zero` <class<`polynom`>, double> => logical;
type `f` <class<`polynom`>, class<`polynom`>> => class<`polynom`> | <class<`polynom`>, class<`polynom`>> => class<`polynom`> | <double[]> => double[];
type `filter` <character[]> => logical[];
type `FUN` <class<`polynom`>, character, ...> => class<`function`> | <class<`polylist`> | class<`polynom`> | list<class<`polynom`>>> => class<`polylist`> | <double, class<`polynom`>> => class<`polynom`> | <class<`polynom`> | double> => class<`polynom`> | <class<`polynom`>, double[]> => double[] | <class<`polynom`>, ...> => class<`summary.polynom`> | <class<`polynom`>, integer> => class<`polynom`> | <class<`function`>> => double[];
type `.GCD2` <class<`polynom`>, class<`polynom`>> => class<`polynom`>;
type `GCD.polynom` <...> => class<`polynom`>;
type `greatest_common_divisor` <...> => class<`polynom`>;
type `inner_product` <class<`polynom`>, class<`polynom`>, integer[], class<`function`>, ...> => double | <class<`polynom`>, class<`polynom`>, double, double> => double | <class<`polynom`>, class<`polynom`>> => double;
type `integral` <class<`polynom`>, ...> => (class<`polynom`> | double);
type `integral.polynom` <class<`polynom`>, null | double[], ...> => (class<`polynom`> | double);
type `is_polylist` <class<`polylist`> | class<`polynom`> | list<class<`polynom`>>> => logical;
type `is_polynom` <class<`polynom`> | double> => logical;
type `LCM.polynom` <...> => class<`polynom`>;
type `lines.polylist` <class<`polylist`>, ..., double, class<`matrix`>, character, character> => null;
type `lines.polynom` <class<`polynom`>, ..., double, double[]> => null;
type `lowest_common_multiple` <...> => class<`polynom`>;
type `.monic` <class<`polynom`>> => class<`polynom`>;
type `Ops.polylist` <double | class<`polylist`>, class<`polylist`>> => class<`polylist`>;
type `Ops.polynom` <class<`polynom`> | double, class<`polynom`> | double> => class<`polynom`>;
type `p` <class<`polynom`> | double[]> => (class<`polynom`> | double[]) | <double[]> => double[] | <double[]> => double[] | <double[]> => double[] | <double[]> => double[] | <double[]> => double[];
type `Pf` <double[], ...> => class<`matrix`>;
type `Pi` <class<`polynom`> | double[]> => (class<`polynom`> | double[]);
type `plot.polylist` <class<`polylist`>, any, double[], character, character, character, ..., integer[], character, double, logical> => null;
type `plot.polynom` <class<`polynom`>, any, double[], character, character | expression, character | expression, ..., double, double[]> => null;
type `poly_calc` <double[], any, any, any> => class<`polynom`>;
type `poly_divide` <double[], double[]> => list<double[]>;
type `poly_from_roots` <...> => class<`polynom`>;
type `poly_from_zeros` <...> => class<`polynom`>;
type `polylist` <...> => class<`polylist`>;
type `[.polylist` <class<`polylist`>, double> => class<`polylist`>;
type `.polylist_from_list` <list<any>> => class<`polylist`>;
type `.poly.mult` <double[], double[]> => double[];
type `polynomial` <double[], ..., double> => class<`polynom`>;
type `poly_orth` <double[], double, logical> => class<`polylist`>;
type `poly_orth_general` <class<`function`>, double, logical, ...> => class<`polylist`>;
type `poly_product` <double[], double[]> => double[];
type `.poly.quo` <double[], double[]> => double[];
type `.poly.rem` <double[], double[]> => double[];
type `q` <class<`polynom`> | double[]> => (class<`polynom`> | double[]);
type `solve.polynom` <class<`polynom`>, any, ...> => complex[];
type `Summary.polylist` <..., logical> => class<`polynom`>;
type `summary.polynom` <class<`polynom`>, ...> => class<`summary.polynom`>;
type `tangent` <class<`polynom`>, double[]> => class<`polylist`>;
type `w` <any, ...> => double;
type `zap` <class<`matrix`> | class<`polylist`>, any> => (class<`matrix`> | class<`polylist`>);
type `zap.polylist` <class<`polylist`>, integer> => class<`polylist`>;
