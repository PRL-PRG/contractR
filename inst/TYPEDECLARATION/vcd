type `cellport` <character> => struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:struct<`nrow`:integer, `ncol`:integer, `widths`:double, `heights`:tuple<double, struct<`fname`:character, `arg1`:double, `arg2`:double>>, `respect`:logical, `valid.respect`:integer, `respect.mat`:^integer[], `just`:character, `valid.just`:double[]>, `layout.pos.row`:null, `layout.pos.col`:null, `valid.just`:double[], `valid.pos.row`:null, `valid.pos.col`:null, `name`:character>;
type `core` <symbol, ^integer[], language, tuple<struct<`fname`:character, `arg1`:double[], `arg2`:double[]>, double[]> | tuple<double, double[]>, struct<`fill`:^character[]>, logical[], character> => null;
type `cotabplot.default` <integer[], null, any => any, struct<`margins`:double[]>, double[], null, struct<`fontsize`:double>, struct<`fill`:character>, logical, logical, logical, logical> => integer[];
type `filter` <character[]> => logical[];
type `FUN` <^character[] | ^double[]> => ^character[] | struct<`fname`:character, `arg1`:double[], `arg2`:double[]> | ^double[];
type `is.structable` <struct<`Income`:character[], `Job.Satisfaction`:character[]> | ^character[] | struct<> | ^double[] | struct<`Treatment`:character[], `Improved`:character[]>> => logical;
type `labeling` <struct<`Income`:character[], `Job.Satisfaction`:character[]> | logical | struct<`Treatment`:character[], `Improved`:character[]>, logical[] | symbol, null | symbol, null | character, null, logical, null, language, struct<`fontsize`:double, `fontface`:double, `font`:integer>, double[], double[], character, character, character[], character[], logical, logical, double[], double[]> => struct<`path`:null, `name`:character, `n`:integer> | any => any;
type `mosaic.default` <^integer[], null, logical | character[] | language, null, any => any | character | symbol, tuple<>, struct<`fill`:character[]> | any => any, null, null, null, symbol, null, double, logical, null | double | symbol, language, null, null, null> => ^integer[];
type `panel` <integer[], character, double[]> => any => any | ^integer[];
type `pexpand` <character[] | double[] | tuple<struct<`fontsize`:double>>, double, character[] | language | symbol | logical, character[], null | character[]> => character[] | double[] | struct<`Income`:struct<`fontsize`:double>, `Job.Satisfaction`:struct<`fontsize`:double>> | struct<`top`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `right`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `bottom`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `left`:struct<`fontsize`:double, `fontface`:double, `font`:integer>> | struct<`Treatment`:struct<`fontsize`:double>, `Improved`:struct<`fontsize`:double>>;
type `remove_trailing_comma` <character> => character;
type `spacing` <integer[] | double, symbol | double> => tuple<struct<`fname`:character, `arg1`:double[], `arg2`:double[]>, double[]> | any => any | tuple<double, double[]>;
type `spacing_dimequal` <integer[] | struct<`fname`:character, `arg1`:double[], `arg2`:double>, symbol> => tuple<struct<`fname`:character, `arg1`:double[], `arg2`:double[]>, struct<`fname`:character, `arg1`:double[], `arg2`:double[]>> | any => any;
type `spacing_increase` <double | integer[], symbol> => any => any | tuple<struct<`fname`:character, `arg1`:double[], `arg2`:double[]>, struct<`fname`:character, `arg1`:double[], `arg2`:double[]>>;
type `split` <double | ^integer[], character | double, logical | character | language, language | double, language | double, language | logical, null | ^integer[]> => null;
type `struc_mosaic` <symbol, symbol, symbol, symbol, symbol> => any => any;
type `strucplot` <^integer[], null | pairlist | struct<`label`:character, `x`:struct<`fname`:character, `arg1`:double, `arg2`:struct<`fname`:character, `arg1`:double, `arg2`:double>>, `y`:double, `just`:character, `hjust`:null, `vjust`:null, `rot`:double, `check.overlap`:logical, `name`:character, `gp`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `vp`:null>, null, null, null, null | character[] | struct<`label`:character, `x`:struct<`fname`:character, `arg1`:double, `arg2`:struct<`fname`:character, `arg1`:double, `arg2`:double>>, `y`:double, `just`:character, `hjust`:null, `vjust`:null, `rot`:double, `check.overlap`:logical, `name`:character, `gp`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `vp`:null>, null | character, null | character | struct<`label`:character, `x`:struct<`fname`:character, `arg1`:double, `arg2`:struct<`fname`:character, `arg1`:double, `arg2`:double>>, `y`:double, `just`:character, `hjust`:null, `vjust`:null, `rot`:double, `check.overlap`:logical, `name`:character, `gp`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `vp`:null>, logical[], any => any, tuple<>, struct<`fill`:character[]> | any => any, language | tuple<>, any => any, struct<`rot_labels`:double, `varnames`:logical, `just_labels`:character[]> | tuple<>, any => any, language, null | environment | struct<`label`:character, `x`:struct<`fname`:character, `arg1`:double, `arg2`:struct<`fname`:character, `arg1`:double, `arg2`:double>>, `y`:double, `just`:character, `hjust`:null, `vjust`:null, `rot`:double, `check.overlap`:logical, `name`:character, `gp`:struct<`fontsize`:double, `fontface`:double, `font`:integer>, `vp`:null>, language | tuple<>> => ^integer[];
type `structable.default` <^integer[] | double[], null, logical[]> => ^double[];
type `vcdViewport` <double[], null, null, logical, logical, logical, logical, character> => struct<`parent`:struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:struct<`nrow`:integer, `ncol`:integer, `widths`:double[], `heights`:tuple<struct<`fname`:character, `arg1`:double, `arg2`:double>, double, double, double, struct<`fname`:character, `arg1`:double, `arg2`:double>>, `respect`:logical, `valid.respect`:integer, `respect.mat`:^integer[], `just`:character, `valid.just`:double[]>, `layout.pos.row`:null, `layout.pos.col`:null, `valid.just`:double[], `valid.pos.row`:null, `valid.pos.col`:null, `name`:character>, `children`:list<struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:null, `layout.pos.row`:integer[], `layout.pos.col`:integer[], `valid.just`:double[], `valid.pos.row`:integer[], `valid.pos.col`:integer[], `name`:character> | tuple<struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:null, `layout.pos.row`:integer[], `layout.pos.col`:integer[], `valid.just`:double[], `valid.pos.row`:integer[], `valid.pos.col`:integer[], `name`:character>, struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:null, `layout.pos.row`:null, `layout.pos.col`:null, `valid.just`:double[], `valid.pos.row`:null, `valid.pos.col`:null, `name`:character>>>> | struct<`parent`:struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:struct<`nrow`:integer, `ncol`:integer, `widths`:double[], `heights`:tuple<struct<`fname`:character, `arg1`:tuple<double, struct<`fname`:character, `arg1`:double, `arg2`:struct<`fname`:character, `arg1`:struct<`fname`:character, `arg1`:struct<`fname`:character, `arg1`:struct<`fname`:character, `arg1`:double, `arg2`:double>, `arg2`:double>, `arg2`:double>, `arg2`:double>>>, `arg2`:null>, double, double, double, struct<`fname`:character, `arg1`:tuple<double, struct<`fname`:character, `arg1`:double, `arg2`:struct<`fname`:character, `arg1`:struct<`fname`:character, `arg1`:struct<`fname`:character, `arg1`:struct<`fname`:character, `arg1`:double, `arg2`:double>, `arg2`:double>, `arg2`:double>, `arg2`:double>>>, `arg2`:null>>, `respect`:logical, `valid.respect`:integer, `respect.mat`:^integer[], `just`:character, `valid.just`:double[]>, `layout.pos.row`:null, `layout.pos.col`:null, `valid.just`:double[], `valid.pos.row`:null, `valid.pos.col`:null, `name`:character>, `children`:list<struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:null, `layout.pos.row`:integer[], `layout.pos.col`:integer[], `valid.just`:double[], `valid.pos.row`:integer[], `valid.pos.col`:integer[], `name`:character> | tuple<struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:null, `layout.pos.row`:integer[], `layout.pos.col`:integer[], `valid.just`:double[], `valid.pos.row`:integer[], `valid.pos.col`:integer[], `name`:character>, struct<`x`:double, `y`:double, `width`:double, `height`:double, `justification`:character, `gp`:tuple<>, `clip`:logical, `xscale`:double[], `yscale`:double[], `angle`:double, `layout`:null, `layout.pos.row`:null, `layout.pos.col`:null, `valid.just`:double[], `valid.pos.row`:null, `valid.pos.col`:null, `name`:character>>>>;
type `zeros` <struct<`col`:character>, character> => struct<`x`:double, `y`:double, `pch`:integer, `size`:double, `name`:character, `gp`:tuple<>, `vp`:null>;
type `$` <double[]> => double[];
type `distplot` <integer[], character[], null, null, logical, null, null, logical, double, null, character, character, struct<`cex`:double>, double, struct<`lty`:double>, character, logical, logical, logical> => struct<`Counts`:double[], `Freq`:double[], `Metameter`:double[], `CI.center`:double[], `CI.width`:double[], `CI.lower`:double[], `CI.upper`:double[]>;
type `ff` <^integer[]> => double;
type `fitted.goodfit` <struct<`observed`:double[], `count`:integer[], `fitted`:double[], `type`:character, `method`:character, `df`:double, `par`:struct<`lambda`:double>>, null> => double[];
type `goodfit` <integer[], character[], character[], null> => struct<`observed`:double[], `count`:integer[], `fitted`:double[], `type`:character, `method`:character, `df`:double, `par`:struct<`lambda`:double>>;
type `gp` <^integer[], ^double[], ^double[], double, double[], integer[], double[], double, character, null> => any => any;
type `grid_barplot` <double[], double, double[], integer[], null, double[], character, character, character, struct<`fill`:character>, character, logical, logical, logical> => integer[];
type `hcl2hex` <double[], double[], double[], logical> => character[];
type `indepfun` <^double[]> => double;
type `legend` <^double[], any => any | character, character | double, double, double, double, double, logical, null, double, double, logical, null> => null | struct<`label`:character, `x`:double, `y`:struct<`fname`:character, `arg1`:double, `arg2`:double>, `just`:character[], `hjust`:null, `vjust`:null, `rot`:double, `check.overlap`:logical, `name`:character, `gp`:struct<`fontsize`:double, `fontfamily`:character, `lineheight`:double>, `vp`:null> | any => any;
type `Ord_estimate` <double[], null, double> => struct<`estimate`:double, `type`:character>;
type `Ord_plot` <integer[], logical, logical, double, null, null, null, character, character, character, struct<`cex`:double>, double[], double[], character[], character, logical, logical, logical, null> => double[];
type `Pearson` <^integer[]> => ^double[];
type `phi` <double[], double[], integer, null | symbol> => double[];
type `plot.goodfit` <struct<`observed`:double[], `count`:integer[], `fitted`:double[], `type`:character, `method`:character, `df`:double, `par`:struct<`lambda`:double>>, null> => null;
type `rootogram.default` <double[], double[], integer[], character[], character[], logical, logical, language, language, null, language, struct<`col`:character, `lwd`:double>, struct<`col`:character>, double, null, null, null, null, null> => null;
type `rootogram.goodfit` <struct<`observed`:double[], `count`:integer[], `fitted`:double[], `type`:character, `method`:character, `df`:double, `par`:struct<`lambda`:double>>, null> => null;
type `summary.goodfit` <struct<`observed`:double[], `count`:integer[], `fitted`:double[], `type`:character, `method`:character, `df`:double, `par`:struct<`lambda`:double>>, null> => ^double[];
