type `AIC.DRMod` <class<`DRMod`>, ..., double> => double;
type `betaMod` <double[], double, class<`AsIs`> | double, double, double, double> => double[];
type `betaModGrad` <double[], double, double, double, double, ...> => class<`matrix`>;
type `bFitMod` <double[], double[], character, class<`matrix`>, logical, character[], any, null | list<double[]>> => class<`bFitMod`>;
type `bFitMod.Bayes` <double[], double[], class<`matrix`>, character, logical, double[] | null, list<double[]>, double> => double[];
type `bFitMod.bootstrap` <double[], double[], class<`matrix`>, character, logical, double, any, any> => class<`matrix`>;
type `calcCrit` <class<`matrix`> | double[], class<`Mods`>, double[], double[], character, any, logical, any> => ^double[];
type `calcED` <character, double[], any, any, character[], any, any, any> => (double | null);
type `calcGrads` <class<`Mods`>, double[], double[], any, any, any, any, character> => (list<double[]> | list<double[] | null>);
type `calcResp` <class<`Mods`> | list<double[] | class<`matrix`>>, double[], any, any, any> => class<`matrix`>;
type `calcTD` <character, double[], double, character[], character[], any, any, any> => (double | null);
type `calcTDgrad` <character, double[], double, character, any, any, any> => double[];
type `callOptim` <class<`function`>, character, integer, list<any>, any, any> => list<any>;
type `checkAnalyArgs` <any, any, null | class<`data.frame`>, class<`matrix`> | null, character, class<`formula`>, logical, class<`function`>> => list<any>;
type `checkEntries` <list<class<`matrix`>> | list<double[]> | list<null> | list<class<`matrix`> | null> | list<double[] | class<`matrix`>> | list<null | double[]> | list<null | double> | list<double[] | null> | list<null | class<`matrix`> | double> | list<null | double[] | class<`matrix`>>, any, logical> => list<null>;
type `checkPrior` <list<double[]>> => null;
type `coef.DRMod` <class<`DRMod`>, logical, ...> => double[];
type `critVal` <class<`matrix`>, double, double, character, class<`GenzBretz`>> => double;
type `defBnds` <double, double[], double[], class<`matrix`>, class<`matrix`>, class<`matrix`>> => list<double[] | class<`matrix`>>;
type `ED` <class<`bFitMod`> | class<`DRMod`> | class<`Mods`>, double, character[], any> => ^double[];
type `emax` <double[], double, double, double> => double[];
type `emaxGrad` <double[], double, double, ...> => class<`matrix`>;
type `exponential` <double[], double, double, double> => double[];
type `exponentialGrad` <double[], double, double, ...> => class<`matrix`>;
type `fit.control` <null> => list<double | list<any>>;
type `fitMod` <any, any, class<`data.frame`> | null, character, null | class<`matrix`>, character[], class<`formula`>, logical> => class<`DRMod`>;
type `fitModel.bndnls` <class<`data.frame`>, character, class<`formula`>, character, double[] | class<`matrix`>, null, null | double[], any> => list<double[]>;
type `fitModel.lin` <class<`data.frame`>, character, class<`formula`>, any, character, any, logical, any> => (list<double[] | null> | list<double[]> | list<double | null>);
type `fitMod.raw` <any, any, any, character, any, character, class<`formula`>, logical> => class<`DRMod`>;
type `fullMod` <list<class<`matrix`>> | list<double[]> | list<double[] | null> | list<null | double[]> | list<null | double[] | class<`matrix`>> | list<null | double> | list<null> | list<null | class<`matrix`> | double> | list<class<`matrix`> | null>, double[], double, double, any, any> => (list<class<`matrix`>> | list<double[]> | list<class<`matrix`> | double[]> | list<double[] | class<`matrix`>>);
type `gAIC` <class<`DRMod`>, ..., double> => double;
type `gAIC.DRMod` <class<`DRMod`>, ..., double> => double;
type `getAddArgs` <null | list<double>, double[]> => list<double>;
type `getCompositions` <double, integer> => class<`matrix`>;
type `getDesMat` <double, integer, double[], double[], double, double, double> => class<`matrix`>;
type `getGrid` <double, class<`matrix`>, double> => class<`matrix`>;
type `getLinPars` <character, any, double[] | null, double, double, any, any> => double[];
type `getPrBnds` <list<double[]>> => class<`matrix`>;
type `getResp` <class<`Mods`>, any> => class<`matrix`>;
type `getStandDR` <character, double[], double[], any> => double[];
type `getStart` <integer> => double[];
type `getZmat` <double[], class<`matrix`>, character, any, any> => class<`matrix`>;
type `getZmat.weighted` <double[], class<`matrix`>, character, any, any> => class<`matrix`>;
type `gradCalc` <character, any, double[], any, any, any> => class<`matrix`>;
type `guesst` <double[], double[], character, logical, logical, any, any, any> => double[];
type `linear` <double[], double, double> => double[];
type `linearGrad` <double[], ...> => class<`matrix`>;
type `linInt` <double[], double[], double[]> => double[];
type `linIntGrad` <double[], any, double[], ...> => class<`matrix`>;
type `linlog` <double[], double, double, double> => double[];
type `linlogGrad` <double[], double, ...> => class<`matrix`>;
type `logistic` <double[], double, class<`AsIs`> | double, double, double> => double[];
type `logisticGrad` <double[], double, double, double, ...> => class<`matrix`>;
type `logLik.DRMod` <class<`DRMod`>, ...> => class<`logLik`>;
type `MCPMod` <any, any, class<`data.frame`> | null, class<`Mods`>, null | class<`matrix`>, character[], class<`formula`>, logical> => class<`MCPMod`>;
type `MCTtest` <any, any, class<`data.frame`> | null, any, null | class<`matrix`>, character[], class<`formula`>, logical> => class<`MCTtest`>;
type `modContr` <class<`matrix`>, null, class<`matrix`>, logical, character, any> => class<`matrix`>;
type `modCount` <class<`Mods`> | list<class<`matrix`>> | list<double[]> | list<double[] | class<`matrix`>> | list<null | double[]> | list<double[] | null> | list<null> | list<null | double[] | class<`matrix`>> | list<null | double> | list<null | class<`matrix`> | double> | list<class<`matrix`> | null>, logical> => double;
type `Mods` <..., double[], double, any, any, null | list<double>, logical> => class<`Mods`>;
type `mvtnorm.control` <double, double, double, null> => class<`GenzBretz`>;
type `nPars` <character[]> => double[];
type `optContr` <class<`Mods`>, any, any, any, logical, character[]> => class<`optContr`>;
type `optDesign` <any, any, any, character[], any, logical, any, double[]> => class<`DRdesign`>;
type `optFunc` <double[], double[], integer[], integer, double[], integer, double, double[]> => double;
type `optGrid` <character, double, class<`matrix`>, list<double>, double[], character, any, double[]> => list<double[]>;
type `optLoc` <character, double, class<`matrix`>, double[], any, double[], any, any> => list<double[]>;
type `plot.bFitMod` <class<`bFitMod`>, character[], double[], character[], double, double, ...> => list<double[] | class<`matrix`>>;
type `plot.DRdesign` <class<`DRdesign`>, class<`Mods`>, double, character, ...> => null;
type `plot.DRMod` <class<`DRMod`>, logical, double, character[], logical, double, double, ...> => class<`trellis`>;
type `plotFunc` <class<`DRMod`> | class<`MCPMod`>, logical, any, character[], logical, double, double, ...> => class<`trellis`>;
type `plot.MCPMod` <class<`MCPMod`>, logical, double, character, logical, double, double, ...> => class<`trellis`>;
type `plotModels` <class<`Mods`>, double, logical, character, character, character[] | null, logical, any> => class<`trellis`>;
type `plot.Mods` <class<`Mods`>, double, logical, character, character, character[] | null, logical, any> => class<`trellis`>;
type `plot.optContr` <class<`optContr`>, logical, character, null, character[], ...> => class<`trellis`>;
type `powCalc` <character, double, double, class<`matrix`>, class<`matrix`>, class<`GenzBretz`>> => double[];
type `powMCT` <class<`optContr`>, double, class<`Mods`>, double, double, any, logical, character[]> => double[];
type `predict.bFitMod` <class<`bFitMod`>, character[], class<`function`>, double[], double, ...> => class<`matrix`>;
type `predict.DRMod` <class<`summary.DRMod`> | class<`DRMod`>, character, null | class<`data.frame`>, null | double[], logical, ...> => (double[] | list<double[]>);
type `predict.MCPMod` <class<`MCPMod`>, character, null, double[], logical, ...> => (list<double[]> | list<list<double[]>>);
type `predSamples` <class<`matrix`>, logical, double[], logical, character, any, any, any> => class<`matrix`>;
type `print.MCTtest` <class<`MCTtest`>, double, double, ...> => null;
type `print.summary.DRMod` <class<`summary.DRMod`>, double, any, ...> => (class<`matrix`> | null);
type `print.summary.MCPMod` <class<`summary.MCPMod`>, ...> => double[];
type `projPrBnds` <double, double, double> => double;
type `pValues` <class<`matrix`>, class<`matrix`>, double, double[], character, class<`GenzBretz`>> => ^double[];
type `quadratic` <double[], double, double, double> => double[];
type `quadraticGrad` <double[], ...> => class<`matrix`>;
type `rndDesign` <class<`DRdesign`>, double, double> => double[];
type `sepCoef` <class<`DRMod`> | class<`summary.DRMod`>> => list<double[]>;
type `sigEmax` <double[], double, double, double, double> => double[];
type `sigEmaxGrad` <double[], double, double, double, ...> => class<`matrix`>;
type `summary.DRMod` <class<`DRMod`>, double, ...> => (class<`matrix`> | null);
type `summary.MCPMod` <class<`MCPMod`>, ...> => double[];
type `TD` <class<`bFitMod`> | class<`DRMod`> | class<`Mods`>, double, character[], character[], any> => (^double[] | null);
type `transTrig` <double[], integer> => double[];
type `vcov.DRMod` <class<`summary.DRMod`> | class<`DRMod`>, ...> => class<`matrix`>;
type `which.is.max` <double[]> => integer;
