type `::` <class<`lvm`> | class<`lvmfit`>, ...> => (null | list<any>) | <class<`lvm`> | class<`lvmfit`> | class<`lm`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`> | list<class<`lvm`>>, ...> => character[] | <class<`lvm`>, ...> => (class<`ordinal.lvm`> | null | class<`lvm`>);
type `%++%` <any, character | class<`function`> | class<`matrix`>> => (character | class<`function`> | class<`matrix`>);
type `aalenExponential.lvm` <double, double[], double[]> => class<`function`>;
type `acc` <class<`matrix`>, character> => character[];
type `addhook` <character, character, ...> => character[];
type `addvar` <class<`lvm`>, ...> => class<`lvm`>;
type `addvar<-` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `addvar<-.lvm` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `addvar.lvm` <class<`lvm`>, character[], any, logical, ...> => class<`lvm`>;
type `adjMat` <class<`lvm`>, ...> => class<`matrix`>;
type `adjMat.lvm` <class<`lvm`>, ...> => class<`matrix`>;
type `ancestors` <class<`lvm`>, ...> => (character[] | null);
type `ancestors.lvm` <class<`lvm`>, character[], ...> => (character[] | null);
type `backdoor` <class<`lvm`>, class<`formula`>, any, ..., logical> => (logical | list<character[] | list<list<character[]>>>);
type `baptize` <class<`lvm`>, ...> => class<`lvm`>;
type `baptize.lvm` <class<`lvm`>, any, logical, logical, ...> => class<`lvm`>;
type `beta.lvm` <double, double, logical> => class<`function`>;
type `binomial.lvm` <character, any, double> => class<`function`>;
type `blockdiag` <class<`matrix`>, ..., double | null> => class<`matrix`>;
type `bootstrap` <class<`lvmfit`>, ...> => class<`bootstrap.lvm`>;
type `bootstrap.lvm` <class<`lvm`>, double, class<`data.frame`>, null, list<double[]>, any, logical, logical, logical, logical, double, logical, null, ...> => class<`bootstrap.lvm`>;
type `bootstrap.lvmfit` <class<`lvmfit`>, double, class<`data.frame`>, list<double[]>, any, logical, logical, character, null, ...> => class<`bootstrap.lvm`>;
type `By` <class<`data.frame`, `groupedData`, `nfGroupedData`, `nfnGroupedData`>, class<`formula`>, class<`function`>, class<`formula`>, logical, ...> => (class<`by`> | class<`matrix`>);
type `cancel` <class<`lvm`>, ...> => class<`lvm`>;
type `cancel<-` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `cancel<-.lvm` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `cancel.lvm` <class<`lvm`>, character[] | class<`formula`>, ...> => class<`lvm`>;
type `categorical` <class<`lvm`>, character | class<`formula`>, any, any, any, logical, logical, logical, ...> => class<`lvm`>;
type `categorical<-` <class<`lvm`>, ..., character> => class<`lvm`>;
type `categorical2dummy` <class<`lvm`>, class<`data.frame`> | list<class<`matrix`> | double[]>, double, ...> => list<class<`lvm`> | class<`data.frame`> | class<`lvm`> | list<class<`matrix`> | double[]>>;
type `char2num` <character[] | double[] | null | list<character>, ...> => (^double[] | null);
type `%++%.character` <character, character> => character;
type `checkmultigroup` <class<`multigroup`>> => null;
type `children` <class<`lvm`> | class<`lvmfit`>, ...> => (character[] | null);
type `children.lvm` <class<`lvm`>, character | class<`formula`>, ...> => (character[] | null);
type `children.lvmfit` <class<`lvmfit`>, ...> => character[];
type `closed.testing` <class<`estimate`>, integer[], double[], ...> => double[];
type `cluster.post.hook` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => (class<`lvmfit`> | null);
type `coef.estimate` <class<`estimate`> | class<`estimate`, `gkgamma`>, logical, logical, double, ...> => double[];
type `coef.lvm` <class<`lvm`>, logical, logical, character[], double, any, any, any, double, logical, ...> => character[];
type `coef.lvmfit` <class<`lvm`> | class<`lvmfit`> | class<`lvm.missing`, `lvmfit`>, double, any, any, null | character, any, any, any, logical, logical, ...> => (class<`matrix`> | double[]);
type `coef.lvm.mixture` <class<`lvm.mixture`, `mvn.mixture`>, any, logical, logical, logical, logical, logical, ...> => double[];
type `CoefMat` <class<`matrix`>, double, double, any, ...> => class<`matrix`>;
type `CoefMat.multigroupfit` <class<`lvmfit`, `multigroupfit`>, double, logical, character, null, integer[], ...> => list<class<`matrix`>>;
type `coef.multigroupfit` <class<`lvmfit`, `multigroupfit`>, double, any, logical, any, any, null, null | integer[], ...> => (class<`matrix`> | double[] | list<class<`matrix`>>);
type `coef.multinomial` <class<`multinomial`>, ...> => double[];
type `coef.zibreg` <class<`zibreg`>, ...> => double[];
type `Col` <character[], double[], double> => character[];
type `Combine` <list<class<`lm`>>, ...> => class<`Combine`, `matrix`>;
type `compare` <class<`glm`, `lm`> | class<`lvmfit`> | class<`lvmfit`, `multigroupfit`> | class<`zibreg`> | class<`estimate`>, ...> => class<`htest`>;
type `compare.default` <class<`glm`, `lm`> | class<`lvmfit`> | class<`lvmfit`, `multigroupfit`> | class<`zibreg`> | class<`estimate`>, ..., any, any, any, any, any, double, null> => class<`htest`>;
type `comparepair` <class<`glm`, `lm`> | class<`lvmfit`> | class<`zibreg`>, class<`glm`, `lm`> | class<`lvmfit`> | class<`zibreg`>> => class<`htest`>;
type `complik` <class<`lvm`>, class<`data.frame`>, double, character, any, double, character, ...> => class<`estimate.complik`, `lvm.missing`, `lvmfit`>;
type `condition` <class<`matrix`>> => double;
type `confband` <double[], ^double[], ^double[], ^double[] | null, logical, double, double, any, logical, logical, logical | character, logical, ...> => (^double[] | null);
type `confint.lvmfit` <class<`lvmfit`>, double, double, logical, logical, double, null, logical, logical, ...> => class<`matrix`>;
type `confpred` <class<`lm`>, class<`data.frame`>, class<`data.frame`>, double, any, ...> => class<`data.frame`>;
type `constrain` <class<`lvm`> | class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => list<any>;
type `constrain<-` <class<`lvm`>, ..., class<`function`>> => class<`lvm`>;
type `constrain<-.default` <class<`lvm`>, character | class<`formula`>, any, ..., class<`function`>> => class<`lvm`>;
type `constrain.default` <class<`lvm`> | class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, any, any, double, any, logical, ...> => list<any>;
type `constraints` <class<`lvm`> | class<`lvmfit`>, class<`matrix`> | class<`data.frame`>, any, double, any, any, any, ...> => (class<`matrix`> | null);
type `contr` <double[] | list<double[]>, any, logical, ...> => class<`matrix`>;
type `covariance` <class<`lvm`>, ...> => (class<`fix`> | class<`lvm`>);
type `covariance<-` <class<`lvm`>, ..., character[] | class<`formula`> | double | null> => class<`lvm`>;
type `covariance<-.lvm` <class<`lvm`>, character[] | class<`formula`> | null, character[] | null, logical, logical, ..., null | double | character[] | class<`formula`>> => class<`lvm`>;
type `covariance.lvm` <class<`lvm`>, null | character[], null | character, logical, logical, logical, any, ...> => (class<`fix`> | class<`lvm`>);
type `covfix` <class<`lvm`>, ...> => class<`fix`>;
type `covfix<-` <class<`lvm`>, ..., character | double | null> => class<`lvm`>;
type `covfix<-.lvm` <class<`lvm`>, character[] | class<`formula`>, character[] | null, logical, logical, ..., null | character | double> => class<`lvm`>;
type `covfix.lvm` <class<`lvm`>, ...> => class<`fix`>;
type `coxExponential.lvm` <double, class<`matrix`> | double[], any> => class<`function`>;
type `coxWeibull.lvm` <double, class<`formula`> | double> => class<`function`>;
type `csplit` <class<`data.frame`> | double, double | null, logical, logical, double, ...> => list<class<`data.frame`> | integer[]>;
type `cv` <list<class<`lm`> | class<`function`>>, class<`data.frame`>, double, double, any, null, double, null, ...> => class<`CrossValidated`>;
type `Debug` <any, logical> => null;
type `decomp.specials` <character | list<character>, null | character, character | null, null | character, character, logical, logical, ...> => character[];
type `density.sim` <class<`matrix`>, ..., character> => class<`matrix`, `summary.sim`>;
type `deriv.lvm` <class<`lvm`>, any, any, logical, double[] | null, double[] | null, null, logical, logical, any, ...> => list<class<`matrix`>>;
type `descendants` <class<`lvm`>, ...> => character[];
type `descendants.lvm` <class<`lvm`>, character, ...> => character[];
type `describecoef` <class<`lvm`>, any, any, any, logical> => list<character[]>;
type `DFS` <class<`matrix`>, integer, integer[] | null> => integer[];
type `diagtest` <class<`table`>, double, logical, null, character[], ...> => class<`diagtest`, `estimate`>;
type `distribution` <class<`lvm`>, ..., any> => (null | list<any>);
type `distribution<-` <class<`lvm`>, ..., class<`function`> | double | list<class<`function`>>> => class<`lvm`>;
type `distribution<-.lvm` <class<`lvm`>, character[] | class<`formula`>, null | character | logical, any, logical, ..., class<`function`> | double | list<class<`function`>>> => class<`lvm`>;
type `distribution.lvm` <class<`lvm`>, any, any, logical, ...> => (null | list<any>);
type `dsep` <class<`lvm`>, ...> => logical;
type `dsep.lvm` <class<`lvm`>, character[] | class<`formula`>, character[] | null, logical, ...> => logical;
type `edgelabels` <class<`lvm`>, ...> => class<`lvm`>;
type `edgelabels<-` <class<`lvm`>, ..., double | expression> => class<`lvm`>;
type `edgelabels<-.lvm` <class<`lvm`>, class<`formula`>, ..., double | expression> => class<`lvm`>;
type `edgelabels.lvm` <class<`lvm`>, double | expression, class<`formula`>, null, double[], double[], double, character[], character, character[], logical, logical, ...> => class<`lvm`>;
type `effects.lvmfit` <class<`lvmfit`>, class<`formula`>, any, ...> => class<`effects`>;
type `endogenous` <class<`lvm`> | class<`lvmfit`> | class<`lm`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`> | list<class<`lvm`>>, ...> => character[];
type `endogenous.list` <list<class<`lvm`>>, ...> => character;
type `endogenous.lm` <class<`lm`>, ...> => character;
type `endogenous.lvm` <class<`lvm`>, logical, logical, ...> => character[];
type `endogenous.lvmfit` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => character[];
type `endogenous.multigroup` <class<`multigroup`>, ...> => character;
type `estimate` <any, ...> => any;
type `estimate.default` <class<`glm`, `lm`> | null | class<`estimate`> | class<`lm`> | class<`lvmfit`, `multigroupfit`> | class<`multinomial`> | double[], any, ..., any, any, any, logical, logical, any, any, double, any, any, any, any, logical, any, any, any, any> => any;
type `estimate.formula` <class<`formula`>, class<`data.frame`>, any, any, ..., character, logical> => class<`glm`, `lm`>;
type `estimate.glm` <class<`glm`, `lm`>, ...> => class<`estimate`>;
type `estimate.list` <list<class<`lvm`> | double[]>, ...> => any;
type `estimate.lvm` <class<`lvm`>, class<`data.frame`> | list<class<`matrix`> | double[]>, character | null, list<any>, logical, any, any, any, any, any, logical, logical, double, logical, any, any, any, any, ...> => (class<`lvmfit`> | class<`lvm.missing`, `lvmfit`> | double[]);
type `estimate.lvmlist` <list<class<`lvm`>>, list<class<`data.frame`>>, any, any, logical, ...> => class<`lvmfit`, `multigroupfit`>;
type `estimate.MAR` <class<`lvm`>, class<`data.frame`>, character[], logical, double, logical, list<character | double[]>, double, any, any, null, logical, character, logical, null, ...> => class<`lvm.missing`, `lvmfit`>;
type `estimate.multigroup` <class<`multigroup`>, list<any>, null | character, any, any, any, null, double, logical, any, any, ...> => class<`lvmfit`, `multigroupfit`>;
type `eventTime` <class<`lvm`>, any, character, ...> => (class<`lvm`> | null);
type `eventTime<-` <class<`lvm`>, ..., class<`formula`>> => class<`lvm`>;
type `exogenous` <class<`lvm`> | class<`lvmfit`> | list<class<`lvm`>>, ...> => (character[] | null);
type `exogenous<-` <class<`lvm`>, ..., character[] | null> => class<`lvm`>;
type `exogenous.list` <list<class<`lvm`>>, ...> => character[];
type `exogenous<-.lvm` <class<`lvm`>, logical, ..., character[] | null> => class<`lvm`>;
type `exogenous.lvm` <class<`lvm`>, any, logical, logical, ...> => (character[] | null);
type `exogenous.lvmfit` <class<`lvmfit`>, ...> => character;
type `Expand` <any, ...> => class<`data.frame`>;
type `extractvar` <class<`formula`>> => list<character[]>;
type `f` <double[] | class<`lvm`>, ...> => (double[] | class<`lvm`>);
type `family.zibreg` <class<`zibreg`>, ...> => class<`family`>;
type `fixsome` <class<`lvm`>, logical, logical, any, any, any, any, logical, character, character, ...> => class<`lvm`>;
type `foldr` <double, double, double> => list<list<integer[]>>;
type `forestplot` <class<`matrix`>, any, any, double, any, logical, logical, null, logical, null, double, logical, double, double | null, character, character, any, any, any, any> => null;
type `forwardsearch` <class<`lvmfit`>, double, double, character, null, ...> => class<`modelsearch`>;
type `FUN` <character | list<character>, null | character, character | null, null | character, character, logical, logical, ...> => character[];
type `%++%.function` <any, class<`function`>> => class<`function`>;
type `functional` <class<`lvm`>, ...> => list<any>;
type `functional<-` <class<`lvm`>, ..., class<`function`>> => class<`lvm`>;
type `functional<-.lvm` <class<`lvm`>, character | class<`formula`>, any, ..., class<`function`>> => class<`lvm`>;
type `functional.lvm` <class<`lvm`>, any, any, any, ...> => list<any>;
type `Gamma.lvm` <character, double, any, logical, logical, logical, ...> => class<`function`>;
type `gaussian_gradient.lvm` <class<`lvm`>, double[], class<`data.frame`> | list<class<`matrix`> | double[]>, class<`matrix`>, double[], integer, ...> => double[];
type `gaussian_hessian.lvm` <class<`lvm`>, double[], integer, ...> => class<`matrix`>;
type `gaussian_objective.lvm` <class<`lvm`>, double[], class<`data.frame`> | list<class<`matrix`> | double[]>, class<`matrix`>, double[], integer, ...> => double;
type `gaussian_score.lvm` <class<`lvm`>, null | class<`data.frame`>, double[], any, any, double[] | null, any, logical, logical, logical, logical, logical, ...> => class<`matrix`>;
type `gethook` <character, ...> => (character[] | null);
type `getMeanVar` <class<`lvm.mixture`, `mvn.mixture`>, any, any, ...> => list<list<double[] | class<`matrix`> | double | class<`matrix`>>>;
type `getoutcome` <class<`formula`>, any, ...> => (character | list<any>);
type `gfilter` <class<`matrix`>, double> => class<`matrix`>;
type `gkgamma` <class<`data.frame`> | class<`formula`>, environment | class<`data.frame`>, null, logical, logical, ...> => class<`estimate`, `gkgamma`>;
type `GLMest` <class<`lvm`>, class<`data.frame`>, list<any>, ...> => list<any>;
type `glm.estimate.hook` <class<`lvm`>, character | null, ...> => list<any>;
type `glm_objective.lvm` <class<`lvm`>, any, class<`data.frame`>, ...> => list<any>;
type `glm_variance.lvm` <class<`lvm`>, double[], class<`data.frame`>, list<any>, ...> => class<`matrix`>;
type `gof` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => class<`gof.lvmfit`>;
type `gof.lvmfit` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, logical, double, double, logical, ...> => class<`gof.lvmfit`>;
type `goodmankruskal_gamma` <class<`table`>, ...> => list<double>;
type `Graph` <class<`lvm`>, ...> => null;
type `Graph.lvm` <class<`lvm`>, logical, ...> => null;
type `Grep` <class<`data.frame`>, character, logical, logical, ...> => class<`data.frame`>;
type `heavytail` <class<`lvm`>, ...> => null;
type `heavytail.init.hook` <class<`lvm`>, ...> => class<`lvm`>;
type `heavytail.lvm` <class<`lvm`>, null, double, ...> => null;
type `heavytail.sim.hook` <class<`lvm`>, class<`matrix`>, ...> => class<`matrix`>;
type `iid` <class<`multinomial`> | class<`lvmfit`, `multigroupfit`> | class<`estimate`> | class<`estimate`, `gkgamma`> | class<`glm`, `lm`> | class<`lm`> | class<`lvmfit`> | class<`data.frame`> | class<`matrix`>, ...> => class<`matrix`>;
type `iid.data.frame` <class<`data.frame`>, ...> => class<`matrix`>;
type `iid.default` <class<`lvmfit`, `multigroupfit`> | class<`glm`, `lm`> | class<`lm`> | class<`lvmfit`>, any, null, double, double, ...> => class<`matrix`>;
type `iid.estimate` <class<`estimate`> | class<`estimate`, `gkgamma`>, ...> => class<`matrix`>;
type `iid.glm` <class<`glm`, `lm`>, ...> => class<`matrix`>;
type `iid.matrix` <class<`matrix`>, ...> => class<`matrix`>;
type `iid.multigroupfit` <class<`lvmfit`, `multigroupfit`>, ...> => class<`matrix`>;
type `iid.multinomial` <class<`multinomial`>, ...> => class<`matrix`>;
type `images` <class<`matrix`> | list<class<`matrix`>>, any, double, logical, double, double, double, logical, double, any, logical, null, any, any, any, list<character[]>, ...> => null;
type `img` <class<`matrix`>, list<integer[]>, list<character[]>, character, character, logical, double, logical, null, logical, logical, character, character, double, ...> => null;
type `impute0` <class<`matrix`> | ^double[], null | class<`omit`>, any, any, any, ...> => (class<`matrix`> | double[]);
type `index` <class<`lvm`> | class<`lvmfit`>, ...> => (null | list<any>);
type `index<-` <class<`lvm`>, ..., list<any>> => class<`lvm`>;
type `index<-.lvm` <class<`lvm`>, ..., list<any>> => class<`lvm`>;
type `index.lvm` <class<`lvm`>, ...> => (null | list<any>);
type `index.lvmfit` <class<`lvmfit`>, ...> => list<any>;
type `information` <class<`lvm`> | class<`lvmfit`, `multigroupfit`> | class<`lvm.missing`, `lvmfit`> | class<`multigroup`> | class<`lvm.mixture`, `mvn.mixture`>, ...> => class<`matrix`>;
type `information.lvm` <class<`lvm`>, double[], any, character, class<`data.frame`> | list<class<`matrix`> | double[]>, null, null, character, any, logical, logical, logical, ...> => class<`matrix`>;
type `information.lvm.missing` <class<`lvm.missing`, `lvmfit`>, double[], character, null, ...> => class<`matrix`>;
type `information.lvm.mixture` <class<`lvm.mixture`, `mvn.mixture`>, double[], ..., character> => class<`matrix`>;
type `information.multigroup` <class<`multigroup`>, list<class<`data.frame`>>, null, double[], logical, ...> => class<`matrix`>;
type `information.multigroupfit` <class<`lvmfit`, `multigroupfit`>, double[], null, character, ...> => class<`matrix`>;
type `intercept` <class<`lvm`>, ...> => class<`fix`>;
type `intercept<-` <class<`lvm`>, ..., character | class<`formula`> | double[] | null | list<any>> => class<`lvm`>;
type `intercept<-.lvm` <class<`lvm`>, any, ..., null | character | double[] | class<`formula`> | list<any>> => class<`lvm`>;
type `intercept.lvm` <class<`lvm`>, any, ...> => class<`fix`>;
type `intfix` <class<`lvm`>, ...> => class<`fix`>;
type `intfix<-` <class<`lvm`>, ..., character | double | list<null>> => class<`lvm`>;
type `intfix<-.lvm` <class<`lvm`>, any, ..., null | character | double[] | class<`formula`> | list<any>> => class<`lvm`>;
type `intfix.lvm` <class<`lvm`>, any, ...> => class<`fix`>;
type `Inverse` <class<`matrix`>, any, logical, any, logical, logical> => class<`matrix`>;
type `izero` <integer[], integer> => double[];
type `kappa.data.frame` <class<`data.frame`>, ...> => class<`estimate`>;
type `kappa.multinomial` <class<`multinomial`>, logical, ...> => class<`estimate`>;
type `kill` <class<`lvm`>, ...> => class<`lvm`>;
type `kill.lvm` <class<`lvm`>, character[] | class<`formula`>, ...> => class<`lvm`>;
type `kmpp` <class<`matrix`>, double> => double[];
type `kronprod` <class<`matrix`>, class<`matrix`>, any> => class<`matrix`>;
type `ksmooth2` <class<`function`> | class<`matrix`>, any, null | double, null, null, character, any, ...> => list<double[] | double[] | class<`matrix`>>;
type `labels<-` <class<`lvm`>, ..., expression | list<character>> => class<`lvm`>;
type `labels<-.default` <class<`lvm`>, ..., expression | list<character>> => class<`lvm`>;
type `labels.lvm` <class<`lvm`>, expression | list<character>, ...> => class<`lvm`>;
type `latent` <class<`lvm`> | class<`lvmfit`>, ...> => (character[] | class<`lvm`> | null);
type `latent<-` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `latent<-.lvm` <class<`lvm`>, logical, ..., character[] | class<`formula`>> => class<`lvm`>;
type `latent.lvm` <class<`lvm`>, any, logical, any, ...> => (character[] | class<`lvm`> | null);
type `latent.lvmfit` <class<`lvmfit`>, logical, ...> => character;
type `lava` <any, double, double, double, double, double, double, character[], ...> => class<`matrix`>;
type `lava.options` <...> => list<double | character[]>;
type `loggamma.lvm` <...> => class<`function`>;
type `logLik.lvm` <class<`lvm`>, any, class<`data.frame`>, character, logical, any, any, any, logical, any, any, ...> => class<`logLik`>;
type `logLik.lvmfit` <class<`lvmfit`>, double[], class<`data.frame`>, character, any, any, ...> => class<`logLik`>;
type `logLik.multigroup` <class<`multigroup`>, double[], any, any, character[], ...> => class<`logLik`>;
type `logLik.multigroupfit` <class<`lvmfit`, `multigroupfit`>, double[], any, any, ...> => class<`logLik`>;
type `logLik.zibreg` <class<`zibreg`>, double[], double[], any, null, logical, ...> => class<`logLik`>;
type `lvm` <character[] | class<`formula`> | null | list<class<`formula`>>, ..., null | class<`formula`>, any> => class<`lvm`>;
type `makemissing` <class<`data.frame`>, double, integer[], logical, class<`function`>, null> => class<`data.frame`>;
type `manifest` <class<`lvm`> | class<`lvmfit`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`> | list<class<`lvm`>>, ...> => character[];
type `manifest.list` <list<class<`lvm`>>, ...> => character[];
type `manifest.lvm` <class<`lvm`>, ...> => character[];
type `manifest.lvmfit` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`>, ...> => character[];
type `manifest.multigroup` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`>, ...> => character[];
type `mat.lvm` <class<`lvm`>, list<any>, ...> => list<any>;
type `matrices` <class<`lvm`>, ...> => list<any>;
type `matrices2` <class<`lvm`>, integer[], ...> => list<any>;
type `matrices.lvm` <class<`lvm`>, character[] | double[], character[] | null | double[], null | double[], any, ...> => list<any>;
type `%++%.matrix` <class<`matrix`>, class<`matrix`>> => class<`matrix`>;
type `measurement.error` <class<`lvmfit`>, class<`formula`>, class<`data.frame`>, class<`function`>, any, any, ...> => class<`estimate`, `measurement.error`>;
type `merge.estimate` <class<`estimate`> | class<`estimate`, `gkgamma`>, class<`estimate`> | class<`estimate`, `gkgamma`>, ..., any, logical, null, null, null | double> => class<`estimate`>;
type `merge.glm` <class<`glm`, `lm`> | class<`lm`>, class<`glm`, `lm`> | class<`lm`>, ...> => class<`estimate`>;
type `merge.lm` <class<`glm`, `lm`> | class<`lm`>, class<`glm`, `lm`> | class<`lm`>, ...> => class<`estimate`>;
type `Missing` <class<`lvm`>, character | class<`formula`>, character | class<`formula`>, any, character, ...> => class<`lvm`>;
type `Missing<-` <class<`lvm`>, character | class<`formula`>, ..., class<`formula`>> => class<`lvm`>;
type `missingModel` <class<`lvm`>, class<`data.frame`>, character[], logical, double, character[], any, any, null, ...> => list<any>;
type `Model` <class<`lvm`> | class<`lvmfit`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`>, ...> => (class<`lvm`> | class<`multigroup`> | list<class<`lvm`>>);
type `Model<-` <class<`lvm`>, ..., class<`lvm`>> => class<`lvm`>;
type `model.frame.estimate` <class<`estimate`>, ...> => null;
type `model.frame.lvmfit` <class<`lvmfit`>, logical, ...> => class<`data.frame`>;
type `model.frame.multigroupfit` <class<`lvmfit`, `multigroupfit`>, ...> => list<class<`data.frame`>>;
type `model.frame.multinomial` <class<`multinomial`>, ...> => class<`data.frame`>;
type `Model<-.lvm` <class<`lvm`>, ..., class<`lvm`>> => class<`lvm`>;
type `Model.lvm` <double[] | class<`lvm`>, ...> => (double[] | class<`lvm`>);
type `Model.lvmfit` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => (class<`lvm`> | class<`multigroup`>);
type `Model.multigroup` <class<`multigroup`>, ...> => list<class<`lvm`>>;
type `Model.multigroupfit` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => (class<`lvm`> | class<`multigroup`>);
type `modelPar` <class<`lvm`> | class<`multigroup`>, double[], ...> => list<any>;
type `modelPar.lvm` <class<`lvm`>, double[], ...> => list<double[] | double[] | null | null | double[]>;
type `modelPar.multigroup` <class<`multigroup`>, double[], ...> => list<list<double[]>>;
type `modelsearch` <class<`lvmfit`>, double, character, character, ...> => class<`modelsearch`>;
type `modelVar` <class<`lvm`> | class<`lvmfit`>, any, ...> => list<any>;
type `modelVar.lvm` <class<`lvm`>, double[], any, ...> => list<any>;
type `modelVar.lvmfit` <class<`lvmfit`>, double[], ...> => list<any>;
type `moments` <class<`lvm`> | class<`lvmfit`>, ...> => list<any>;
type `moments.lvm` <class<`lvm`>, double[], logical, logical, any, logical, ...> => list<any>;
type `moments.lvmfit` <class<`lvmfit`>, double[], ...> => list<any>;
type `multigroup` <list<class<`lvm`>>, list<class<`data.frame`>>, any, logical, null, logical, ...> => class<`multigroup`>;
type `multinomial` <class<`data.frame`> | class<`factor`>, any, logical, any, logical, logical, ...> => class<`multinomial`>;
type `mvnmix` <class<`data.frame`>, double, any, double, double, double, null, logical, logical, double, character, ...> => class<`lvm.mixture`, `mvn.mixture`>;
type `mygrad` <class<`lvm`>, double[], class<`data.frame`>, null, null, logical, ...> => (class<`matrix`> | double[]);
type `NA2x` <^integer[], double> => double[];
type `na.pass0` <class<`matrix`> | class<`data.frame`>, logical, class<`function`>, ...> => (class<`matrix`> | class<`data.frame`>);
type `%ni%` <integer[] | null | character, double[] | character[]> => logical[];
type `nlminb0` <double[], class<`function`>, class<`function`>, class<`function`>, ...> => list<double[] | character>;
type `nlminb1` <double[], class<`function`>, class<`function`>, class<`function`>, ...> => list<double[] | character>;
type `nlminb2` <double[], class<`function`>, class<`function`> | null, class<`function`> | null, ...> => list<double[] | character>;
type `nodecolor<-` <class<`lvm`>, class<`formula`>, ..., character[]> => class<`lvm`>;
type `nodecolor<-.lvm` <class<`lvm`>, class<`formula`>, character[], character, any, double[], ..., character[]> => class<`lvm`>;
type `normal_gradient.lvm` <class<`lvm`>, double[], class<`data.frame`>, null, null, logical, ...> => (class<`matrix`> | double[]);
type `normal_hessian.lvm` <class<`lvm`>, double[], logical, null, ...> => class<`matrix`>;
type `normal.lvm` <character, double, double, logical, ...> => class<`function`>;
type `normal_objective.lvm` <class<`lvm`>, double[], class<`data.frame`>, null, null, logical, ...> => (class<`matrix`> | double);
type `NR` <double[], class<`function`> | null, null | class<`function`>, null | class<`function`>, any, null | list<double>, ...> => list<double[] | character | class<`matrix`> | double | character | class<`matrix`>>;
type `numberdup` <integer[]> => double[];
type `offdiag` <class<`matrix`>, double, ...> => class<`numeric`, `offdiag`>;
type `offdiags` <class<`lvm`>, logical> => double[];
type `ones.lvm` <double, any> => class<`function`>;
type `ordinal` <class<`lvm`>, ...> => (class<`ordinal.lvm`> | null | class<`lvm`>);
type `ordinal<-` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `ordinal.estimate.hook` <class<`lvm`>, class<`data.frame`> | list<class<`matrix`> | double[]>, null, null, null | character, ...> => (null | list<any>);
type `ordinal<-.lvm` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `ordinal.lvm` <class<`lvm`>, character[] | class<`formula`> | null, double | null, any, null, any, logical, any, logical, ...> => (class<`lvm`> | class<`ordinal.lvm`> | null);
type `ordinal.remove.hook` <class<`lvm`>, character[], ...> => class<`lvm`>;
type `ordinal.sim.hook` <class<`lvm`>, class<`data.frame`>, double[] | null, list<any>, ...> => class<`data.frame`>;
type `ordreg` <class<`formula`>, class<`data.frame`>, any, class<`family`>, any, logical, ...> => class<`ordreg`>;
type `ordreg_dthreshold` <double[]> => class<`matrix`>;
type `ordreg_hessian` <double[], environment, ...> => class<`matrix`>;
type `ordreg_ithreshold` <double[]> => double[];
type `ordreg_logL` <double[], environment, logical, ...> => double;
type `ordreg_score` <double[], environment, ...> => double[];
type `ordreg_threshold` <double[]> => double[];
type `parameter` <class<`lvm`>, any, ...> => (character[] | null);
type `parameter<-` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `parameter<-.lvm` <class<`lvm`>, any, any, logical, ..., character[] | class<`formula`>> => class<`lvm`>;
type `parents` <class<`lvm`>, ...> => (character[] | null);
type `parents.lvm` <class<`lvm`>, character[] | class<`formula`>, ...> => (character[] | null);
type `parfix` <class<`lvm`>, ...> => class<`lvm`>;
type `parfix.lvm` <class<`lvm`>, double, double, logical, ...> => class<`lvm`>;
type `parlabels` <class<`lvm`>, logical> => (character[] | logical[] | null);
type `parpos` <class<`multigroup`> | class<`lvm`>, ...> => (integer[] | list<any>);
type `parpos.lvm` <class<`lvm`>, any, logical, ...> => (integer[] | list<any>);
type `parpos.multigroup` <class<`multigroup`>, character[], logical, ...> => integer[];
type `pars` <class<`lvm`> | class<`lvmfit`, `multigroupfit`> | class<`lm`> | class<`glm`, `lm`> | class<`lvmfit`> | class<`lvm.missing`, `lvmfit`>, ...> => (character[] | double[] | list<character>);
type `pars.default` <class<`lvmfit`> | class<`lvm.missing`, `lvmfit`> | class<`lvm`> | class<`lvmfit`, `multigroupfit`> | class<`lm`>, ...> => double[];
type `parsedesign` <character[], character, ..., logical, logical[]> => class<`matrix`>;
type `pars.glm` <class<`glm`, `lm`>, ...> => double[];
type `pars.lvm` <class<`lvm`>, class<`matrix`>, class<`matrix`>, any, any, ...> => (character[] | double[] | list<character>);
type `pars.lvm.missing` <class<`lvm.missing`, `lvmfit`>, logical, ...> => double[];
type `partialcor` <class<`formula`>, class<`data.frame`>, double, ...> => class<`matrix`>;
type `partialcorpair` <class<`formula`>, class<`data.frame`>, double, ...> => double[];
type `path` <class<`lvm`> | class<`lvmfit`>, ...> => list<character[] | list<double | class<`matrix`> | double[] | character[]>>;
type `path.lvm` <class<`lvm`>, character | class<`formula`>, any, logical, ...> => list<character[]>;
type `path.lvmfit` <class<`lvmfit`>, class<`formula`>, any, ...> => list<list<double | class<`matrix`> | double[] | character[]>>;
type `pathM` <class<`matrix`>, character | class<`formula`>, any, logical, ...> => list<character[]>;
type `p.correct` <class<`estimate`>, any, double> => double;
type `PD` <class<`zibreg`>, double[], double[], null, any, double, double, any, any, null> => class<`matrix`>;
type `plotConf` <class<`lm`>, null | character, character, null, double, logical, double, double, double, double, double, any, null, any, double, double, double, double, double, logical> => list<any>;
type `plot.sim` <class<`matrix`>, double[], double[] | null, double[] | null, null, logical, logical, character, any, character[], double, double, double, double, any, character, double, character[], logical, double[]> => (null | list<list<double[]>>);
type `poisson.lvm` <character, any, ...> => class<`function`>;
type `predictlvm` <class<`lvmfit`>, class<`formula`>, double[], class<`data.frame`>, ...> => list<class<`matrix`>>;
type `predict.lvm` <class<`lvm`>, character[] | class<`formula`> | null, any, logical, double[], class<`data.frame`>, logical, logical, ...> => class<`matrix`>;
type `predict.lvmfit` <class<`lvmfit`>, character[] | class<`formula`> | null, null, class<`data.frame`>, double[], ...> => class<`matrix`>;
type `predict.zibreg` <class<`zibreg`>, double[], any, any, logical, logical, ...> => double[];
type `procdata.lvm` <class<`lvm`>, class<`data.frame`> | list<class<`matrix`> | double[]>, logical, any, any> => list<class<`matrix`> | double[] | class<`matrix`> | double>;
type `procformula` <class<`lvm`>, class<`formula`>, logical, ...> => list<any>;
type `procrandomslope` <class<`multigroup`>, list<class<`data.frame`>>, ...> => list<class<`multigroup`> | list<any>>;
type `prodsumdelta` <double[], list<double[]>, class<`matrix`>, double> => list<class<`matrix`> | double[] | double | class<`matrix`>>;
type `prodtrans` <double[]> => double;
type `profci.lvmfit` <class<`lvmfit`>, double, double, null, logical, any, logical, logical, ...> => double[];
type `profile.lvmfit` <class<`lvmfit`>, double, double, ...> => double;
type `pzmax` <double, class<`matrix`>> => double;
type `randomslope` <class<`lvm`>, ...> => null;
type `randomslope.lvm` <class<`lvm`>, any, null, null, any, any, logical, logical, ...> => null;
type `regfix` <class<`lvm`>, ...> => class<`fix`>;
type `regfix<-` <class<`lvm`>, ..., character | double[] | null | list<null | character>> => class<`lvm`>;
type `regfix<-.lvm` <class<`lvm`>, character[] | class<`formula`>, any, logical, any, any, any, ..., character | double[] | null | list<null | character>> => class<`lvm`>;
type `regfix.lvm` <class<`lvm`>, ...> => class<`fix`>;
type `regression` <class<`lvm`>, any, any, ...> => (class<`fix`> | class<`lvm`>);
type `regression<-` <class<`lvm`>, ..., character | class<`formula`> | double[] | null | list<null | character>> => class<`lvm`>;
type `regression<-.lvm` <class<`lvm`>, character[] | class<`formula`> | null, logical, ..., character | double[] | null | class<`formula`> | list<null | character>> => class<`lvm`>;
type `regression.lvm` <class<`lvm`>, any, any, null, any, logical, any, any, any, ...> => (class<`fix`> | class<`lvm`>);
type `reindex` <class<`lvm`>, logical, logical, logical, logical, logical> => list<any>;
type `reorderdata.lvm` <class<`lvm`>, class<`matrix`> | double[]> => (class<`matrix`> | double[]);
type `rmvar` <class<`lvm`>, ...> => class<`lvm`>;
type `rmvar<-` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `rmvar<-.lvm` <class<`lvm`>, ..., character[] | class<`formula`>> => class<`lvm`>;
type `rmvar.lvm` <class<`lvm`>, character[] | class<`formula`>, ...> => class<`lvm`>;
type `rmvn0` <double, any, class<`matrix`>, any, ...> => class<`matrix`>;
type `rotate2` <class<`matrix`>, double> => class<`matrix`>;
type `rsq` <class<`lvmfit`>, logical> => (class<`estimate`> | list<double[]>);
type `satmodel` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, logical, any, any, any, any, logical, logical, ...> => class<`logLik`>;
type `scheffe` <class<`lm`>, class<`data.frame`>, double> => class<`matrix`>;
type `score` <class<`lvm`> | class<`lvmfit`, `multigroupfit`> | class<`multigroup`> | class<`lvmfit`> | class<`lvm.missing`, `lvmfit`> | class<`glm`, `lm`> | class<`lm`>, ...> => (class<`matrix`> | double[] | list<class<`matrix`>>);
type `score.glm` <class<`glm`, `lm`>, double[], any, logical, logical, any, any, any, any, null, null, ...> => class<`matrix`>;
type `score.lm` <class<`lm`>, double[], any, logical, any, any, null, null, logical, ...> => class<`matrix`>;
type `score.lvm` <class<`lvm`>, class<`data.frame`> | null, any, character, any, any, any, any, any, logical, logical, logical, logical, any, ...> => class<`matrix`>;
type `score.lvmfit` <class<`lvmfit`>, class<`data.frame`>, double[], character, null, any, ...> => class<`matrix`>;
type `score.lvm.missing` <class<`lvm.missing`, `lvmfit`>, double[], character, null, logical, logical, ...> => class<`matrix`>;
type `score.lvm.mixture` <class<`lvm.mixture`, `mvn.mixture`>, double[], any, logical, character, ...> => class<`matrix`>;
type `score.multigroup` <class<`multigroup`>, list<class<`data.frame`>>, null, null, double[], logical, logical, ...> => (class<`matrix`> | double[] | list<class<`matrix`>>);
type `score.multigroupfit` <class<`lvmfit`, `multigroupfit`>, double[], null, character, ...> => (class<`matrix`> | double[]);
type `sequence.lvm` <double, double, logical> => class<`function`>;
type `sim` <class<`lvm`> | class<`lvmfit`> | class<`function`> | class<`matrix`, `sim`>, ...> => (class<`data.frame`> | class<`lvm`> | class<`matrix`, `sim`>);
type `[.sim` <class<`matrix`, `sim`>, any, double[], logical> => class<`matrix`, `sim`>;
type `sim.default` <class<`function`> | class<`matrix`, `sim`>, class<`data.frame`> | double, null, null, any, any, any, any, double, null, double[] | list<any>, logical, ...> => null;
type `sim.lvm` <class<`lvm`>, double | null, double[] | null, logical, logical, double, double, null, logical, logical, logical, null | double, ...> => (class<`data.frame`> | class<`lvm`>);
type `sim.lvmfit` <class<`lvmfit`>, double, double[], logical, ...> => class<`data.frame`>;
type `simnull` <double, class<`function`>, double[], class<`matrix`>, character> => class<`matrix`>;
type `simplePaths` <character, character[], any, class<`matrix`>, list<any>> => list<character[]>;
type `simulate.lvm` <class<`lvm`>, double, double, ...> => class<`data.frame`>;
type `simulate.multiple.inputs` <class<`lvm`>, class<`data.frame`>, ...> => class<`data.frame`>;
type `stack.estimate` <class<`glm`, `lm`> | class<`estimate`>, class<`glm`, `lm`> | class<`estimate`>, any, any, any, any, any, logical, any, any, any, ...> => class<`estimate`>;
type `stack.glm` <class<`glm`, `lm`>, class<`glm`, `lm`>, ...> => class<`estimate`>;
type `starter.multigroup` <class<`multigroup`>, class<`function`>, logical, double, ...> => double[];
type `startmean` <class<`lvm`>, double[], double[]> => double[];
type `startvalues` <class<`lvm`>, class<`matrix`>, double[], logical, double, double, double, ...> => double[];
type `startvalues0` <class<`lvm`>, class<`matrix`>, double[], double, double, ...> => double[];
type `stdcoef` <class<`lvmfit`>, double[], ...> => list<class<`matrix`>>;
type `subset.lvm` <class<`lvm`>, character | class<`formula`>, ...> => class<`lvm`>;
type `summary.multigroupfit` <class<`lvmfit`, `multigroupfit`>, null, ...> => class<`summary.multigroupfit`>;
type `summary.sim` <class<`matrix`> | class<`matrix`, `sim`>, double[], double[] | null, double[], double[] | null, any, null | character[], logical, logical, double, double[], ...> => class<`matrix`, `summary.sim`>;
type `summary.zibreg` <class<`zibreg`>, double, class<`matrix`>, ...> => class<`summary.zibreg`>;
type `sumsplit` <character, ...> => character[];
type `surface` <class<`matrix`> | class<`function`>, any, any, any, any, character, any, any, any, logical, double, double, character, logical, logical, character | class<`function`>, ...> => list<double[]>;
type `timedep` <class<`lvm`>, class<`formula`>, any, double[], character, ...> => class<`lvm`>;
type `toformula` <character[], character | double> => class<`formula`>;
type `toPar` <double[], integer, double> => list<class<`matrix`> | double[]>;
type `toTheta` <class<`matrix`>, class<`matrix`>, double[]> => double[];
type `tr` <class<`matrix`>, ...> => (class<`matrix`> | double);
type `transform<-` <class<`lvm`>, ..., class<`function`>> => class<`lvm`>;
type `transform<-.lvm` <class<`lvm`>, character | class<`formula`> | null, ..., class<`function`>> => class<`lvm`>;
type `transform.lvm` <class<`lvm`>, any, class<`function`>, logical, any, any, ...> => class<`lvm`>;
type `tr.matrix` <class<`matrix`>, logical, ...> => (class<`matrix`> | double);
type `uhat` <double[]> => class<`matrix`>;
type `uniform.lvm` <any, double> => class<`function`>;
type `updatelvm` <class<`lvm`>, logical, ...> => class<`lvm`>;
type `variance<-` <class<`lvm`>, ..., character[] | class<`formula`> | double | null> => class<`lvm`>;
type `variances` <class<`lvm`> | class<`lvmfit`>, logical> => double[];
type `vars` <class<`lvm`> | class<`lvmfit`>, ...> => (character[] | null);
type `vars.lvm` <class<`lvm`>, ...> => (character[] | null);
type `vars.lvmfit` <class<`lvmfit`>, ...> => character[];
type `vcov.estimate` <class<`estimate`>, logical, ...> => class<`matrix`>;
type `vcov.lvmfit` <class<`lvmfit`>, ...> => class<`matrix`>;
type `vcov.multigroupfit` <class<`lvmfit`, `multigroupfit`>, ...> => class<`matrix`>;
type `vcov.zibreg` <class<`zibreg`>, ...> => class<`matrix`>;
type `vec` <double[], logical, character, ...> => double[];
type `versioncheck` <character, double[], character, ...> => logical;
type `weibull.lvm` <double, double> => class<`function`>;
type `Weights` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => null;
type `Weights.default` <class<`lvmfit`> | class<`lvmfit`, `multigroupfit`>, ...> => null;
type `wrapvec` <double, double, ...> => integer[];
type `x2NA` <integer[], double | integer[]> => ^integer[];
type `zibreg` <class<`formula`>, class<`formula`>, class<`data.frame`>, class<`family`>, null, any, character, ...> => class<`zibreg`>;
type `zibreg_information` <double[], double[], double[], class<`matrix`>, class<`matrix`>, null, class<`family`>, character, ...> => class<`matrix`>;
type `zibreg_logL` <double[], double[], double[], class<`matrix`>, class<`matrix`>, null, class<`family`>, logical, ...> => class<`logLik`>;
type `zibreg_score` <double[], double[], double[], class<`matrix`>, class<`matrix`>, null, class<`family`>, logical, ...> => double[];
