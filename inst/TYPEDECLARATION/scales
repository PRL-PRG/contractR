type `filter` <character[]> => logical[];
type `::` <character[] | language | ^double[], null | double[] | symbol | any => any | character[], null | symbol | double | character, null | double | character, double | character, character, logical | character, null | logical, null, null> => null | character[] | double[] | struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]> | any => any;
type `$` <^double[], double[], double> => character[] | ^double[];
type `alpha` <null | character[] | ^logical[], null | ^double[]> => null | ^character[];
type `as.trans` <character> => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `censor` <^double[], double[], logical> => ^double[];
type `clevels` <integer[] | character[], logical | symbol, logical> => character[];
type `colour_ramp` <character[], null, logical> => any => any;
type `discard` <null | ^double[], double[]> => null | ^double[];
type `doColorRamp` <^integer[], double[], logical, character> => character[];
type `expand_range` <double[], double, double, double> => double[];
type `extended_breaks` <double[], null> => any => any | double[];
type `f` <^double[], double[], logical> => character[] | ^double[];
type `force_all` <null | null | character | double[]> => tuple<> | tuple<character, any => any, any => any, any => any, double[]> | tuple<double[], double, double, double, double> | tuple<double> | tuple<character, character> | list<double | character> | list<null | double | character> | struct<``:double, ``:double, ``:character, ``:character, ``:character, ``:character, ``:logical, `digits`:double>;
type `format_format` <null> => any => any;
type `FUN` <^double[] | character, double[]> => ^double[] | language | expression;
type `gradient_n_pal` <character[] | double[], null, character> => any => any | character[];
type `hue_pal` <double[], double, double, double, double> => any => any | character[];
type `is.discrete` <character[] | integer[]> => logical;
type `is.trans` <character | struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>> => logical;
type `match.fun` <double> => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `ramp` <double[]> => character[];
type `regular_minor_breaks` <double[], double[], double> => any => any | double[];
type `rescale.numeric` <double[], double[], double[], null> => double[];
type `trans_new` <character, character | any => any, character | any => any, any => any, any => any, any => any, double[]> => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `zero_range` <double[], double> => logical;
type `log_breaks` <double[], double> => any => any | double[];
type `log_trans` <double> => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `log10_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `abs_area` <double> => any => any;
type `rotate` <double[]> => double[];
type `seq_gradient_pal` <character | double[], character, character> => any => any | character[];
type `area_pal` <double[]> => any => any;
type `brewer_pal` <character | symbol | double, double | character, double> => any => any | ^character[];
type `pal_name` <double, character> => character;
type `rescale_pal` <double[]> => any => any;
type `reverse_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `[[` <double> => character[];
type `grey_pal` <double, double> => any => any | character[];
type `identity_pal` < > => any => any;
type `manual_pal` <character[]> => any => any;
type `rescale.NULL` <null> => null;
type `rescale.logical` <^logical[], double[], double[], null> => ^double[];
type `pal_aaas` <double> => character[];
type `pal_d3` <double> => character[];
type `pal_futurama` <double> => character[];
type `pal_gsea` <double> => character[];
type `pal_igv` <double> => character[];
type `pal_jama` <double> => character[];
type `pal_jco` <double> => character[];
type `pal_lancet` <double> => character[];
type `pal_locuszoom` <double> => character[];
type `pal_material` <double> => character[];
type `pal_nejm` <double> => character[];
type `pal_npg` <double> => character[];
type `pal_rickandmorty` <double> => character[];
type `pal_simpsons` <double> => character[];
type `pal_startrek` <double> => character[];
type `pal_tron` <double> => character[];
type `pal_uchicago` <double> => character[];
type `pal_ucscgb` <double> => character[];
type `show_col` <^character[], logical, null, double> => null;
type `colScale` <double[]> => character[];
type `filterNA` <any => any, symbol> => any => any;
type `filterRange` <any => any> => any => any;
type `filterRGB` <any => any> => any => any;
type `filterZeroLength` <any => any> => any => any;
type `pf` <double[]> => character[];
type `safePaletteFunc` <character[], symbol> => any => any;
type `toPaletteFunc.character` <character[]> => any => any;
type `withColorAttr` <character, struct<`na.color`:character>, any => any> => any => any;
type `%||%` <null | double | integer[], double[] | language | symbol> => double[];
type `breaks` <double[]> => double[];
type `calcLevels` <character[] | integer[], logical | symbol> => character[] | integer[];
type `cbreaks` <double[], any => any | double[], any => any | double[] | expression> => struct<`breaks`:double[], `labels`:character[]> | struct<`breaks`:double[], `labels`:tuple<language, language, language, language, language>> | struct<`breaks`:double[], `labels`:tuple<symbol, symbol, symbol>>;
type `col_bin` <character | double[], null | integer[], double, logical, character> => any => any | character[];
type `col_factor` <character[] | integer[], null | integer[] | null, null | character[], logical, character> => character[] | any => any;
type `col_numeric` <character | double[], null, character> => any => any | character[];
type `col_quantile` <character | double[], null, double, double[], character> => any => any | character[];
type `col2hcl` <character[], null, null | double, null | double, double> => character[];
type `colorFunc` <integer[]> => character[];
type `comma` <double[], double, double, character, character, character, character, logical, null, null> => character[];
type `comma_format` <double[], double, character, character, character, character, logical, null, null> => character[] | any => any;
type `cscale` <double[], any => any, null, struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>> => character[] | double[];
type `custom_function` <^double[]> => character[];
type `date_format` <character | double, character> => any => any | character;
type `date_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `dichromat_pal` <character | double> => any => any | character[];
type `div_gradient_pal` <double[] | character, character, character, character> => character[] | any => any;
type `dollar` <double[], null, double, character, character, character, character, logical, double, logical, null> => character[];
type `dollar_format` <null | double[], double, character, character, character, character, logical, double, logical, null> => any => any | character[];
type `dscale` <integer[], any => any, null> => character[];
type `euro` <double> => character;
type `finance` <double[]> => character[];
type `format` <double[], null, double, character, character, character, character, logical, null> => character[];
type `french_percent` <double[]> => character[];
type `getBins` <null | integer[], null | double[], double, logical> => double[];
type `getLevels` <null, null, null, symbol> => null;
type `hms_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `identity_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `km` <double[]> => character[];
type `labels` <double[]> => character[] | tuple<language, language, language, language, language>;
type `log_sub_breaks` <double[], double, double> => double[];
type `log1p_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `map_continuous` <any => any, double[], double[], symbol, any => any> => character[] | double[];
type `map_discrete` <any => any, integer[], character[], symbol> => character[];
type `math_format` <language | double[], symbol> => any => any | list<language>;
type `muted` <character, double, double> => character;
type `my_format` <double[]> => character[];
type `needs_cents` <double[], double> => logical;
type `number` <^double[], null | double, double, character, character, character, character, logical, null | double> => character[];
type `number_bytes` <double[], character, character[], double | null> => character[];
type `number_bytes_format` <double[] | character, character, null> => character[] | any => any;
type `number_format` <null | double, double, character, character, character, character, logical, double | null> => any => any;
type `oob` <double[], double[], logical> => double[];
type `ordinal` <integer[], character, character, character, struct<`er`:character, `nd`:character, `e`:character> | struct<`st`:character, `nd`:character, `rd`:character, `th`:character, `th`:character, `th`:character>, null> => character[];
type `ordinal_english` < > => struct<`st`:character, `nd`:character, `rd`:character, `th`:character, `th`:character, `th`:character>;
type `ordinal_format` <integer[] | character, character, character, struct<`st`:character, `nd`:character, `rd`:character, `th`:character, `th`:character, `th`:character>, null> => character[] | any => any;
type `ordinal_french` < > => struct<`er`:character, `nd`:character, `e`:character>;
type `pal` <double[]> => character[];
type `palette` <double[]> => character[] | double[];
type `parse_format` <character[]> => tuple<expression, expression, expression> | any => any;
type `per_mille` <double> => character;
type `percent` <double[], null, double, character, character, character, character, logical, null> => character[];
type `percent_format` <null | double[], double, character, character, character, character, logical, null> => character[] | any => any;
type `precision` <double[]> => double;
type `pretty_breaks` <double[], null> => any => any | double[];
type `pvalue` <^double[], double, character, logical> => character[];
type `pvalue_format` <double, character, logical> => any => any;
type `rescale_max` <double[], double[], double[]> => double[];
type `rescale_mid.numeric` <double[], double[], double[], double, null> => double[];
type `rescale_none` <integer[], null> => integer[];
type `round_any.numeric` <^double[], double, any => any> => ^double[];
type `scientific` <double[], double, double, character, character, character, logical, null> => character[];
type `scientific_format` <double[], double, character, character, character, logical, null> => character[] | any => any;
type `sqrt_trans` < > => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `squish` <^double[], double[], logical> => ^double[];
type `squish_infinite` <double[], double[]> => double[];
type `tf` <integer[]> => character[];
type `time_breaks` <double> => any => any;
type `time_format` <double | character, character> => character | any => any;
type `time_trans` <null> => struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>;
type `train_continuous` <double[], null> => double[];
type `train_discrete` <integer[], null, logical, logical> => character[];
type `trans_breaks` <double[] | character | any => any, any => any, double, null> => double[] | any => any;
type `trans_format` <character, any => any> => any => any;
type `trans_range` <struct<`name`:character, `transform`:any => any, `inverse`:any => any, `breaks`:any => any, `minor_breaks`:any => any, `format`:any => any, `domain`:double[]>, integer[]> => double[];
type `unit_format` <double, double, character, character, character, character, character, character, logical, double | null> => any => any;
type `usd` <double[]> => character[];
type `viridis_pal` <double, double, double, double, character> => any => any | character[];
type `wrap_10` <character> => character;
type `wrap_format` <double> => any => any;
