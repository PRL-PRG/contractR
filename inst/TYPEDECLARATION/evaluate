type `append_break` <character[]> => character[];
type `filter` <character[]> => logical[];
type `FUN` <struct<`V1`:integer, `V2`:integer, `i`:integer> | integer | struct<`message`:character, `call`:language> | struct<`src`:character>> => struct<`src`:character, `expr`:tuple<expression>, `line`:integer> | logical;
type `new_source` <character> => struct<`src`:character>;
type `parse_all.character` <character[], ? character, logical> => struct<`src`:character[], `expr`:list<? expression>>;
type `parse_all.connection` <integer, null, logical> => struct<`src`:character[], `expr`:list<? expression>>;
type `remove_hooks` <struct<`before.plot.new`:any => any> | struct<`persp`:any => any, `before.plot.new`:any => any, `before.grid.newpage`:any => any>> => null;
type `set_hooks` <struct<`before.plot.new`:any => any> | struct<`before.plot.new`:tuple<>> | struct<`persp`:any => any, `before.plot.new`:any => any, `before.grid.newpage`:any => any>, character> => struct<`before.plot.new`:tuple<>> | struct<`before.plot.new`:tuple<any => any>>;
type `::` <character, environment, null, logical, integer, logical, logical, logical, struct<`source`:any => any, `text`:any => any, `graphics`:any => any, `message`:any => any, `warning`:any => any, `error`:any => any, `value`:any => any>, null, logical> => tuple<struct<`src`:character>, struct<`message`:character, `call`:language>>;
type `$` <logical, symbol, language, language> => character[] | tuple<> | integer;
type `evaluate_call` <expression, character, environment, environment, logical, logical, logical, logical, logical, struct<`source`:any => any, `text`:any => any, `graphics`:any => any, `message`:any => any, `warning`:any => any, `error`:any => any, `value`:any => any>, logical> => tuple<struct<`src`:character>, struct<`message`:character, `call`:language>>;
type `handle` <struct<`value`:double, `visible`:logical>> => struct<`value`:double, `visible`:logical>;
type `handle_condition` <struct<`message`:character, `call`:language>> => tuple<struct<`src`:character>, struct<`message`:character, `call`:language>>;
type `handle_output` <logical, logical> => tuple<struct<`src`:character>>;
type `timing_fn` <struct<`value`:double, `visible`:logical>> => null;
type `watchout` <logical> => struct<`get_new`:any => any, `pause`:any => any, `unpause`:any => any, `close`:any => any, `get_con`:any => any>;
