type `and0` <double[], double[]> => logical[];
type `armijo` <class<`function`>, double[], any, double, double, any, logical, logical, double, ...> => list<double[]>;
type `combinations` <double[]> => class<`matrix`>;
type `conditionMatrix` <class<`matrix`>, double, double, double | null, null | double[], logical, double> => class<`matrix`>;
type `conditionTable` <class<`array`>, double[], double[], null | double[] | list<integer[] | double>, double, logical> => (class<`array`> | class<`matrix`>);
type `conditionTable2` <class<`array`>, double[], double[], double> => class<`array`>;
type `cubeHelix` <double, double, double, double, double> => character[];
type `ddirichlet` <class<`matrix`>, class<`matrix`> | double[], logical, double> => double[];
type `designMatrix` <double> => class<`matrix`>;
type `expit` <double[]> => double[];
type `fastHadamard` <integer[], logical> => double[];
type `filter` <character[]> => logical[];
type `fsapply` <list<integer[] | double | integer[] | integer[] | double>, class<`function`>> => double[];
type `fun` <any, character> => null;
type `FUN` <character[] | integer[]> => (character[] | integer[]) | <double[]> => character;
type `greaterThan` <double, double> => double;
type `indexBox` <double[], double[], double[]> => integer[];
type `interventionMatrix` <class<`matrix`>, double, double, null, logical> => class<`matrix`>;
type `interventionTable` <class<`array`>, double, double> => class<`array`>;
type `is.subset` <double[], double[]> => logical;
type `is.wholenumber` <double[], double> => logical[];
type `last` <integer[]> => integer;
type `logit` <double[]> => double[];
type `marginMatrix` <class<`matrix`>, double[], double[] | null, logical, logical> => class<`matrix`>;
type `marginTable` <class<`array`> | class<`matrix`>, double[], logical> => (class<`array`> | class<`matrix`>);
type `patternRepeat` <character[] | integer[], double[], double[], logical, logical> => (character[] | integer[]);
type `patternRepeat0` <double[], double[], logical, logical> => integer[];
type `powerSet` <character[] | double | integer[], any, any> => list<character[] | double[]>;
type `powerSetCond` <integer[], double, any, logical, logical> => list<double[]>;
type `powerSetMat` <double> => class<`matrix`>;
type `printCount` <double, double, double, null> => null;
type `printPercentage` <integer, double, double, double, double, double> => null;
type `propTable` <class<`array`> | class<`matrix`>, integer[] | double> => (class<`array`> | class<`matrix`>);
type `quickSort` <double[] | list<any>, any, ..., logical> => double[];
type `rdirichlet` <double, double[]> => class<`matrix`>;
type `rowMins` <class<`matrix`>> => double[];
type `rprobdist` <double[], any, any, double> => class<`array`>;
type `setmatch` <list<double[]>, list<double[]>, null | integer> => ^integer[];
type `setsetdiff` <list<integer[]>, list<integer[]>> => list<integer[]>;
type `setsetequal` <list<integer[]>, list<double[]>> => logical;
type `subarray` <class<`array`> | class<`matrix`>, double[] | list<double | integer[] | integer[] | double | double>, logical> => (class<`array`> | class<`matrix`> | integer[]);
type `%subof%` <double[], double[]> => logical;
type `subsetmatch` <list<integer[]>, list<integer[]>, null> => integer[];
type `subsetMatrix` <double> => class<`matrix`>;
type `subsetOrder` <integer[], integer[]> => double;
type `subtable` <class<`array`> | class<`matrix`>, double[], double[] | list<integer[] | double | double | integer[]>, logical> => (class<`array`> | class<`matrix`> | integer[]);
type `.sweep0` <class<`array`> | class<`matrix`>, integer[] | double, class<`matrix`> | class<`array`>, character> => (class<`array`> | class<`matrix`>);
