type `::` <character[] | tuple<^integer[], integer[], null> | tuple<double[], double[]>, character[] | tuple<double[]>, character, double[], double[], double, double, double, double> => ^double[];
type `[[` <struct<`message`:character, `call`:language>> => character;
type `ain` <character, character[], double> => logical;
type `all_int` <tuple<> | tuple<double[]> | tuple<^integer[], integer[], null> | tuple<^integer[], null> | tuple<null> | struct<`x`:double[], `y`:double[]>> => logical;
type `amatch` <null | character[], null | character[] | ^logical[], null | double, logical, character[], logical, double[], double, double, double, double, double> => null | ^integer[];
type `do_dist` <null | character[] | tuple<integer[]>, null | ^character[] | tuple<^integer[], integer[], null> | tuple<null, integer[]> | struct<`x`:integer[], `y`:integer[]> | tuple<integer[]>, character, double[], double, double, double, logical, integer> => null | ^double[];
type `ensure_int_list` <tuple<> | tuple<double[]> | tuple<^integer[], integer[], null> | tuple<^integer[], null> | tuple<null> | struct<`x`:double[], `y`:double[]>> => tuple<> | tuple<integer[]> | tuple<^integer[], integer[], null> | tuple<^integer[], null> | tuple<null> | struct<`x`:integer[], `y`:integer[]>;
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => struct<`sd_num_thread`:null>;
type `FUN` <null | ^double[] | ^character[], null | character[], character | double, double[], double, double, double, logical, integer> => character | tuple<^integer[]> | tuple<null> | ^double[];
type `int2char` <list<null | integer[]> | list<integer[]> | tuple<integer[]>> => ^character[];
type `lengths.character` <character[], character, null> => integer[];
type `lengths.list` <tuple<^integer[], integer[], null> | tuple<integer[]>, symbol> => integer[];
type `listwarning` <character, character> => character;
type `lower_tri` <^character[] | tuple<integer[]> | struct<`x`:integer[], `y`:integer[]>, character, logical, double[], double, double, double, character, integer> => ^double[];
type `normalize_dist` <^double[], tuple<^integer[], integer[], null> | character[] | tuple<integer[], integer[]> | symbol, tuple<integer[]> | character[] | symbol, character, character | symbol, symbol | double> => ^double[];
type `phonetic` <^character[], character, logical> => ^character[];
type `printable_ascii` <null | character[]> => logical[];
type `qgrams` <null | ^character[], null, double, logical, logical> => ^double[];
type `seq_ain` <tuple<integer[]>, tuple<integer[], integer[]>, double | null> => logical;
type `seq_amatch` <tuple<^integer[], null> | double[] | tuple<integer[]> | tuple<null>, tuple<integer[]> | double[], null | double, logical, character[], double[], double, double, double, double, double> => null | ^integer[];
type `seq_dist` <tuple<null, integer[]> | double[] | tuple<double[]>, double[] | tuple<double[]>, character[], double[], double, double, double, double> => ^double[];
type `seq_distmatrix` <double[] | tuple<double[]> | struct<`x`:double[], `y`:double[]>, double[] | tuple<double[]> | struct<`x`:double[], `y`:double[]>, character[], double[], double, double, double, character[], double> => ^double[];
type `seq_qgrams` <integer[], null, double> => ^double[];
type `seq_sim` <tuple<^integer[], integer[], null> | tuple<double[], double[]>, tuple<double[]>, character[], double, null> => ^double[];
type `setnames` <struct<`A`:character, `B`:character, `C`:character[]> | struct<`x`:tuple<integer[]>, `y`:tuple<integer[]>>> => struct<`A`:character, `B`:character, `C`:character[]> | struct<`x`:tuple<integer[]>, `y`:tuple<integer[]>>;
type `setNames` <character[] | tuple<^character[]> | tuple<tuple<integer[]>, tuple<integer[]>> | tuple<tuple<integer[]>, tuple<^integer[]>, tuple<null>> | tuple<null>, character[]> => character[] | struct<`V1`:^character[]> | struct<`V1`:tuple<integer[]>, `V2`:tuple<integer[]>> | struct<`V1`:tuple<integer[]>, `V2`:tuple<^integer[]>, `V3`:tuple<null>> | struct<`V1`:null>;
type `stringdist` <null | ^character[] | tuple<character>, null | character[] | tuple<character>, character[], logical, double[], double, double, double, double> => null | ^double[];
type `stringdistmatrix` <character[] | tuple<character>, character[] | tuple<character>, character[], logical, double[], double, double, double, logical | character[], double> => ^double[];
type `stringsim` <character[], character[], character[], logical, double, null | double> => double[];
