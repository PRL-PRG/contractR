type `filter` <character[]> => logical[];
type `rmvnorm` <double, ^double[], ^double[], character[], logical> => ^double[];
type `checkmvArgs` <double[], double[], double[], null | ^double[], null | ^double[]> => struct<`lower`:double[], `upper`:double[], `mean`:double[], `corr`:^double[], `sigma`:null, `uni`:logical> | struct<`lower`:double[], `upper`:double[], `mean`:double[], `corr`:null, `sigma`:^double[], `uni`:logical>;
type `chkcorr` <^double[]> => logical;
type `GenzBretz` <double, double, double> => struct<`maxpts`:double, `abseps`:double, `releps`:double>;
type `isInf` <double[]> => logical[];
type `isNInf` <double[]> => logical[];
type `mvt` <double[], double[], double, ^double[], double[], struct<`maxpts`:double, `abseps`:double, `releps`:double> | symbol, null | double> => struct<`value`:double, `error`:double, `msg`:character>;
type `probval.GenzBretz` <struct<`maxpts`:double, `abseps`:double, `releps`:double>, integer, double, double[], double[], double[], symbol, double[], double[]> => struct<`N`:integer, `NU`:integer, `LOWER`:double[], `UPPER`:double[], `INFIN`:integer[], `CORREL`:double[], `DELTA`:double[], `MAXPTS`:integer, `ABSEPS`:double, `RELEPS`:double, `error`:double, `value`:double, `inform`:integer, `RND`:integer>;
type `dmvnorm` <^double[], double[], ^double[], logical> => double;
type `cdf` <double, null | logical> => double[];
type `dots2GenzBretz` <null> => struct<`algorithm`:null, `uniroot`:null>;
type `f` <double> => double;
type `FUN` <double> => double;
type `func` <double, symbol, symbol> => double;
type `get_est` <struct<`coefficients`:double[], `residuals`:double[], `fitted.values`:double[], `effects`:double[], `R`:^double[], `rank`:integer, `qr`:struct<`qr`:^double[], `rank`:integer, `qraux`:double[], `pivot`:integer[], `tol`:double>, `family`:struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `varfun`:character>, `linear.predictors`:double[], `deviance`:double, `aic`:null, `null.deviance`:double, `iter`:integer, `weights`:double[], `prior.weights`:double[], `df.residual`:integer, `df.null`:integer, `y`:double[], `converged`:logical, `boundary`:logical, `model`:struct<`y`:double[], `x`:double[], `(weights)`:double[]>, `call`:language, `formula`:language, `terms`:language, `data`:environment, `offset`:null, `control`:struct<`epsilon`:double, `maxit`:double, `trace`:logical>, `method`:character, `contrasts`:null, `xlevels`:tuple<>>, double> => double;
type `get_new_points` <struct<`coefficients`:double[], `residuals`:double[], `fitted.values`:double[], `effects`:double[], `R`:^double[], `rank`:integer, `qr`:struct<`qr`:^double[], `rank`:integer, `qraux`:double[], `pivot`:integer[], `tol`:double>, `family`:struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `varfun`:character>, `linear.predictors`:double[], `deviance`:double, `aic`:null, `null.deviance`:double, `iter`:integer, `weights`:double[], `prior.weights`:double[], `df.residual`:integer, `df.null`:integer, `y`:double[], `converged`:logical, `boundary`:logical, `model`:struct<`y`:double[], `x`:double[], `(weights)`:double[]>, `call`:language, `formula`:language, `terms`:language, `data`:environment, `offset`:null, `control`:struct<`epsilon`:double, `maxit`:double, `trace`:logical>, `method`:character, `contrasts`:null, `xlevels`:tuple<>>, double, symbol, double> => double[];
type `get_quant_loclin` <any => any, double, double[], double, double, character, double, logical, null> => struct<`quantile`:double, `f.quantile`:double>;
type `getInt` <double, double[], ^double[], character, character[], double> => double[];
type `pmvnorm` <double[], double[], double[], null | ^double[], null | ^double[], struct<`maxpts`:double, `abseps`:double, `releps`:double> | language, null> => double;
type `predict_with_se` <struct<`coefficients`:double[], `residuals`:double[], `fitted.values`:double[], `effects`:double[], `R`:^double[], `rank`:integer, `qr`:struct<`qr`:^double[], `rank`:integer, `qraux`:double[], `pivot`:integer[], `tol`:double>, `family`:struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `varfun`:character>, `linear.predictors`:double[], `deviance`:double, `aic`:null, `null.deviance`:double, `iter`:integer, `weights`:double[], `prior.weights`:double[], `df.residual`:integer, `df.null`:integer, `y`:double[], `converged`:logical, `boundary`:logical, `model`:struct<`y`:double[], `x`:double[], `(weights)`:double[]>, `call`:language, `formula`:language, `terms`:language, `data`:environment, `offset`:null, `control`:struct<`epsilon`:double, `maxit`:double, `trace`:logical>, `method`:character, `contrasts`:null, `xlevels`:tuple<>>, struct<`x`:double>> => struct<`fit`:double, `se.fit`:double, `residual.scale`:double>;
type `qmvnorm` <double, null | integer[], character, double[], null | ^double[], null | ^double[], struct<`maxpts`:double, `abseps`:double, `releps`:double>, double, double, logical, null> => struct<`quantile`:double, `f.quantile`:double>;
type `sanitize_x` <double[], double> => double[];
type `sanitize_y` <double[]> => double[];
type `wgts` <double[], double> => double[];
type `qmvt` <double, null | character | integer, character, double, double, null | ^double[], null | ^double[], struct<`maxpts`:double, `abseps`:double, `releps`:double>, character[] | struct<`error`:any => any> | struct<`x`:double>, double, double, logical, null> => struct<`quantile`:double, `f.quantile`:double>;
type `::` <^double[], double[], ^double[], ^double[], null, struct<`maxpts`:double, `abseps`:double, `releps`:double>, null> => double[];
type `dmvt` <double[], double[], ^double[], double, logical, character> => double;
