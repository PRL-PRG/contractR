type `::` <null, language> => logical[];
type `.subset2` <? character | struct<`a`:double> | struct<`Header1`:character> | struct<`Hello_World`:character> | struct<`User-Agent`:character, `Accept-Encoding`:character, `Accept`:character> | struct<`foo`:character> | tuple<>, ? character, ? tuple<> | struct<`body`:null, `headers`:struct<`Accept-Encoding`:character, `Accept`:character>, `proxies`:null, `auth`:null> | struct<`body`:struct<`foo`:character, `a`:double>> | struct<`headers`:struct<`User-Agent`:character, `stuff`:character>> | language, null, null, null> => ? struct<`a`:double> | struct<`header1`:character> | struct<`hello-world`:character> | struct<`user-agent`:character, `accept-encoding`:character, `accept`:character> | character | struct<`scheme`:character, `domain`:character, `port`:null, `path`:character, `parameter`:null, `fragment`:null> | struct<`foo`:character> | tuple<>;
type `%||%` <? character | double | struct<`Accept-Encoding`:character, `Accept`:character>, ? character | language | double> => ? character | double | struct<`Accept-Encoding`:character, `Accept`:character>;
type `$` <? struct<`pizza`:character, `cheese`:character> | double | environment | character | struct<`a`:double> | struct<`header1`:character> | struct<`hello-world`:character> | struct<`hello-worlds`:character> | struct<`user-agent`:character, `accept-encoding`:character, `accept`:character> | struct<`User-Agent`:character, `Accept-Encoding`:character, `Accept`:character> | struct<`foo`:character> | struct<`body`:null, `headers`:struct<`Accept-Encoding`:character, `Accept`:character>, `proxies`:null, `auth`:null> | struct<`body`:struct<`foo`:character, `a`:double>> | struct<`headers`:struct<`User-Agent`:character, `stuff`:character>>, ? character | struct<`a`:struct<`b`:character>> | struct<`foo`:character> | symbol | double | raw[], ? struct<`a`:double> | struct<`foo`:character> | struct<`User-Agent`:character, `hello`:character>> => ? character | raw[] | environment | double | tuple<environment> | tuple<> | struct<`foo`:character> | struct<`User-Agent`:character, `hello`:character>;
type `add_scheme` <character> => character;
type `along_rep` <? tuple<>, logical> => logical[];
type `assert` <? double | environment | tuple<> | struct<`a`:double> | struct<`body`:struct<`foo`:character>> | struct<`foo`:character> | struct<`User-Agent`:character, `hello`:character>, character> => null;
type `build_crul_request` <struct<`url`:struct<`url`:character, `handle`:null>, `method`:character, `options`:struct<`httpget`:logical, `useragent`:character>, `headers`:struct<`Accept-Encoding`:character, `Accept`:character>>> => environment;
type `build_crul_response` <struct<`url`:struct<`url`:character, `handle`:null>, `method`:character, `options`:struct<`httpget`:logical, `useragent`:character>, `headers`:struct<`Accept-Encoding`:character, `Accept`:character>>, environment> => environment;
type `cc` <struct<`status`:double, `body`:character, `headers`:null, `body_raw`:raw[]>> => struct<`status`:double, `body`:character, `body_raw`:raw[]>;
type `check_for_pkg` <character> => logical;
type `esc` <character> => character;
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => environment;
type `FUN` <environment> => logical | character;
type `httr_mock` <logical> => null;
type `hz_namez` <? tuple<> | struct<`User-Agent`:character, `hello`:character> | struct<`a`:double> | struct<`foo`:character>> => logical[];
type `normalize_uri` <character> => character;
type `parseurl` <character> => struct<`scheme`:character, `domain`:character, `port`:null, `path`:character, `parameter`:null, `fragment`:null>;
type `prune_port` <character> => character;
type `prune_trailing_slash` <character> => character;
type `query_mapper` <struct<`foo`:character, `a`:double>> => struct<`foo`:character, `a`:double>;
type `remove_request_stub` <environment> => tuple<>;
type `request_is_in_cache` <environment> => logical;
type `request_registry` < > => environment;
type `stub_registry` < > => environment;
type `stub_registry_clear` < > => tuple<>;
type `webmockr_configuration` < > => struct<`show_stubbing_instructions`:logical, `show_body_diff`:logical, `query_values_notation`:logical, `allow`:null, `net_http_connect_on_start`:logical, `allow_net_connect`:logical, `allow_localhost`:logical>;
type `webmockr_configure` <logical, logical, null, logical, logical, logical, logical> => struct<`show_stubbing_instructions`:logical, `show_body_diff`:logical, `query_values_notation`:logical, `allow`:null, `net_http_connect_on_start`:logical, `allow_net_connect`:logical, `allow_localhost`:logical>;
