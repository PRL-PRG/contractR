type `filter` <character[]> => logical[];
type `as.character.polynomial` <double[], logical, ???> => character;
type `as.function.polynomial` <double[], ???> => any => any;
type `coef.polynomial` <double[], ???> => double[];
type `deriv.polynomial` <double[], ???> => double[];
type `integral.polynomial` <double[], null, ???> => double[];
type `Math.polynomial` <double[], integer | ???> => double[];
type `Ops.polynomial` <double[], double[]> => double[];
type `polynomial` <complex[]> => double[];
type `predict.polynomial` <double[], double[], ???> => double[];
type `print.polynomial` <double[], integer, logical, ???> => double[];
type `.degree` <double[]> => double;
type `.GCD2` <double[] | symbol, double[]> => double[];
type `.is_zero_polynomial` <double[]> => logical;
type `.polylist_from_list` <tuple<> | tuple<double[]> | list<double[]>> => tuple<> | tuple<double[]> | list<double[]>;
type `[.polylist` <tuple<double[]> | list<double[]>, double[]> => tuple<> | tuple<double[]> | list<double[]>;
type `accumulate` <any => any | character, double[], tuple<double[]> | list<double[]>, logical> => double[];
type `as.function` <double[]> => double[];
type `as.polylist` <list<double[]>> => list<double[]>;
type `as.polynomial` <double[]> => double[];
type `c.polylist` <tuple<double[], double[]>, logical> => tuple<double[], double[]> | list<double[]>;
type `change.origin` <double[], double> => double[];
type `deriv.polylist` <tuple<double, double[], double[], double[]> | list<double[]>, ???> => tuple<double, double, double[], double[]> | list<double[]>;
type `f` <double[] | symbol, double[]> => double[];
type `fp3` <integer[]> => double[];
type `FUN` <double[] | tuple<double[], double[]>, double[] | ???, ???> => double[] | struct<`zeros`:double[], `stationaryPoints`:double[], `inflexionPoints`:double[]> | tuple<double[]>;
type `GCD.polylist` <tuple<double[], double[]>> => double[];
type `integral.polylist` <tuple<double, double[], double[], double[]> | list<double[]>, ???> => tuple<double[], double[], double[], double[]> | list<double[]>;
type `is.polylist` <double[] | tuple<double[], double[]> | list<double[]>> => logical;
type `is.polynomial` <double[]> => logical;
type `LCM.polylist` <tuple<double[], double[], double[]>> => double[];
type `lines.polynomial` <double[], double, null, null, double> => null;
type `plot.polylist` <list<double[]> | tuple<double, double[], double[], double[]>, language, double[], character, double, ???, character, character> => null;
type `plot.polynomial` <double[], double[] | language, double[], character, double, ???, character, character> => null;
type `points.polynomial` <double[], double, double> => null;
type `poly.calc` <double[], double[], double, language> => double[];
type `poly.from.roots` <double[]> => double[];
type `poly.from.values` <integer[], double[], double, language> => double[];
type `poly.orth` <double[], double, logical> => tuple<double, double[], double[], double[]>;
type `polylist` <double[]> => tuple<double[]>;
type `prf` <integer[]> => double[];
type `rep.polylist` <tuple<double, double[], double[], double[]>, double, ???> => list<double[]>;
type `solve.polynomial` <double[], ???, ???> => complex[];
type `Summary.polylist` <tuple<double, double[], double[], double[]>, logical> => double[];
type `summary.polynomial` <double[], ???> => struct<`zeros`:complex[], `stationaryPoints`:complex[], `inflexionPoints`:complex[]>;
type `unique.polylist` <tuple<double[], double[]>, logical, ???> => tuple<double[]>;
