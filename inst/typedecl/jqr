type `[[` <struct<`message`:character, `call`:language>> => struct<`message`:character, `call`:language>;
type `$` <struct<`data`:character, ``:tuple<character>> | struct<`data`:character, `args`:tuple<character>>> => character[];
type `ad` <character> => struct<`data`:character, `args`:tuple<character>>;
type `allj` <character> => struct<`data`:character, `args`:tuple<character>>;
type `anyj` <character> => struct<`data`:character, `args`:tuple<character>>;
type `at` <character | struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character>>;
type `at_` <character | struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `build_array` <character, language | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `build_array_` <character, ???, struct<``:struct<`expr`:language, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>, ``:struct<`expr`:language, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `build_object` <character | struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character>>;
type `build_object_` <character | struct<`data`:character, `args`:tuple<character>>, ???, struct<`a`:struct<`expr`:symbol, `env`:environment>> | struct<`hello`:struct<`expr`:symbol, `env`:environment>> | struct<`message`:struct<`expr`:symbol, `env`:environment>, `name`:struct<`expr`:symbol, `env`:environment>> | struct<`sha`:struct<`expr`:symbol, `env`:environment>, `author`:struct<`expr`:symbol, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>> | struct<`sha`:struct<`expr`:symbol, `env`:environment>, `name`:struct<`expr`:symbol, `env`:environment>> | struct<`user`:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `callback` <character[]> => null;
type `collapse_vec` <character | double> => character | double;
type `comb` <tuple<> | tuple<character>, character> => tuple<character>;
type `combine` <character[]> => character;
type `contains` <character, character | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `contains_` <character, ???, struct<``:struct<`expr`:character, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `cpt` <tuple<character>> => tuple<character>;
type `del` <character, symbol> => struct<`data`:character, `args`:tuple<character>>;
type `del_` <character, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `do` <character | struct<`data`:character, `args`:tuple<character>>, character | language> => struct<`data`:character, `args`:tuple<character>>;
type `do_` <character | struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:character, `env`:environment>> | struct<``:struct<`expr`:language, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `dot` <character> => struct<`data`:character, `args`:tuple<character>>;
type `dot_` <character, character> => struct<`data`:character, `args`:tuple<character>>;
type `dotindex` <character, symbol> => struct<`data`:character, ``:tuple<character>>;
type `dotindex_` <character, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, ``:tuple<character>>;
type `dotstr` <character | struct<`data`:character, `args`:tuple<character>>, language | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `dotstr_` <character | struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:language, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `endswith` <struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character, character>>;
type `endswith_` <struct<`data`:character, `args`:tuple<character>>, character | ???, ??? | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `filter` <character[]> => logical[];
type `flags` <character | struct<`data`:character, `args`:tuple<character>>, logical, logical, logical, logical, logical, logical> => struct<`data`:character, `args`:tuple<character>>;
type `floorj` <character> => struct<`data`:character, `args`:tuple<character>>;
type `fromjson` <struct<`data`:character, `args`:tuple<character, character>>> => struct<`data`:character, `args`:tuple<character, character, character>>;
type `FUN` <struct<`expr`:character, `env`:environment> | struct<`expr`:language, `env`:environment> | struct<`expr`:symbol, `env`:environment>> => character;
type `funs` <character, character, character> => struct<`data`:character, `args`:tuple<character>>;
type `get_expr` <struct<``:struct<`expr`:symbol, `env`:environment>> | struct<`expr`:symbol, `env`:environment>> => character;
type `get_jq_seq` <double | integer[], logical> => character;
type `getdata` <character | struct<`data`:character, `args`:tuple<character>>> => character;
type `group` <character, symbol> => struct<`data`:character, `args`:tuple<character>>;
type `group_` <character, character | ???, ??? | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `haskey` <character, double> => struct<`data`:character, `args`:tuple<character>>;
type `haskey_` <character, ???, struct<``:struct<`expr`:double, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `index` <character, character | double | ???> => struct<`data`:character, `args`:tuple<character>>;
type `index_` <character, ???, tuple<> | struct<``:struct<`expr`:character, `env`:environment>> | struct<``:struct<`expr`:double, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `index_loc` <character, character> => struct<`data`:character, `args`:tuple<character>>;
type `index_loc_` <character, ???, struct<``:struct<`expr`:character, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `indexif` <character, symbol> => struct<`data`:character, ``:tuple<character>>;
type `indexif_` <character, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, ``:tuple<character>>;
type `indices` <character, character> => struct<`data`:character, `args`:tuple<character>>;
type `indices_` <character, ???, struct<``:struct<`expr`:character, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `join` <character, ??? | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `join_` <character, ???, tuple<> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `jq_flags` <logical, logical, logical, logical, logical, logical> => integer;
type `jq.character` <character[], character, integer> => character[];
type `jq.connection` <integer, character, integer, null> => character[];
type `jq.jqr` <struct<`data`:character, ``:tuple<character>> | struct<`data`:character, `args`:tuple<character>>, ???> => character[];
type `jqr_new` <integer> => character;
type `jqr.connection` <integer, character, integer, null> => character[];
type `jqr.default` <character[], character, integer> => character[];
type `keys` <character> => struct<`data`:character, `args`:tuple<character>>;
type `lengthj` <struct<`data`:character, `args`:tuple<character>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `ltrimstr` <struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character, character>>;
type `ltrimstr_` <struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `make_query` <struct<`data`:character, ``:tuple<character>> | struct<`data`:character, `args`:tuple<character>>> => character;
type `map` <character, language> => struct<`data`:character, `args`:tuple<character>>;
type `map_` <character, ???, struct<``:struct<`expr`:language, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `maxj` <character, ??? | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `maxj_` <character, ???, tuple<> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `minj` <character, ??? | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `minj_` <character, ???, tuple<> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `paths` <character> => struct<`data`:character, `args`:tuple<character>>;
type `peek` <struct<`data`:character, `args`:tuple<character>>> => character;
type `pipe_autoexec` <logical> => null;
type `pipeline_info` < > => struct<`is_piped`:logical, `env`:environment> | struct<`is_piped`:logical, `env`:null>;
type `pipeline_on_exit` <environment> => null;
type `pluck` <struct<``:struct<`expr`:double, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>>, character, ???> => struct<``:double> | struct<``:symbol>;
type `pop` <struct<`data`:character, ``:tuple<character>> | struct<`data`:character, `args`:tuple<character>>> => tuple<character>;
type `query_from_dots` <character | ???> => character;
type `rangej` <double | integer[], logical> => struct<`data`:character, `args`:tuple<character>>;
type `recurse` <character, language> => struct<`data`:character, `args`:tuple<character>>;
type `recurse_` <character, ???, struct<``:struct<`expr`:language, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `reverse` <character> => struct<`data`:character, `args`:tuple<character>>;
type `rindex_loc` <character, character> => struct<`data`:character, `args`:tuple<character>>;
type `rindex_loc_` <character, ???, struct<``:struct<`expr`:character, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `rtrimstr` <struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character, character>>;
type `rtrimstr_` <struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `select` <character | struct<`data`:character, `args`:tuple<character>>, language | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `select_` <character | struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:language, `env`:environment>> | struct<`a`:struct<`expr`:symbol, `env`:environment>> | struct<`bad`:struct<`expr`:symbol, `env`:environment>> | struct<`sha`:struct<`expr`:symbol, `env`:environment>, `name`:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `setdef` <tuple<> | struct<``:struct<`expr`:language, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>>, character> => character;
type `sortj` <character, ??? | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `sortj_` <character, ???, tuple<> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `sqrtj` <character> => struct<`data`:character, `args`:tuple<character>>;
type `startswith` <struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character, character>>;
type `startswith_` <struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `string` <struct<`data`:character, `args`:tuple<character>>> => character;
type `tojson` <struct<`data`:character, `args`:tuple<character>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `tonumber` <struct<`data`:character, `args`:tuple<character>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `tostring` <struct<`data`:character, `args`:tuple<character>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `tryargs` <character | struct<`data`:character, `args`:tuple<character>>> => tuple<> | tuple<character>;
type `type` <struct<`data`:character, `args`:tuple<character>>, symbol> => struct<`data`:character, `args`:tuple<character, character>>;
type `type_` <struct<`data`:character, `args`:tuple<character>>, ???, struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character, character>>;
type `types` <character> => struct<`data`:character, `args`:tuple<character>>;
type `uniquej` <character, ??? | symbol> => struct<`data`:character, `args`:tuple<character>>;
type `uniquej_` <character, character | ???, ??? | tuple<> | struct<``:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
type `vars` <character, symbol> => struct<`data`:character, `args`:tuple<character>>;
type `vars_` <character, ???, struct<`realnames`:struct<`expr`:symbol, `env`:environment>>> => struct<`data`:character, `args`:tuple<character>>;
