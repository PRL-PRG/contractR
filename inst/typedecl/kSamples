type `ad.pval` <double[], double, double> => double[];
type `ad.test` <tuple<double[], double[]> | double[], null, character, logical, double> => struct<`test.name`:character, `k`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `sig`:double, `ad`:^double[], `warning`:logical, `null.dist1`:double[], `null.dist2`:double[], `method`:character, `Nsim`:double> | struct<`test.name`:character, `k`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `sig`:double, `ad`:^double[], `warning`:logical, `null.dist1`:null, `null.dist2`:null, `method`:character, `Nsim`:double>;
type `ad.test.combined` <tuple<double[], double[], double[]>, null, character, logical, double> => struct<`test.name`:character, `M`:integer, `n.samples`:tuple<integer[], integer[]>, `nt`:integer[], `n.ties`:integer[], `ad.list`:tuple<^double[], ^double[]>, `mu`:double[], `sig`:double[], `ad.c`:^double[], `mu.c`:double, `sig.c`:double, `warning`:logical, `null.dist1`:null, `null.dist2`:null, `method`:character, `Nsim`:double>;
type `ave.score` <double[], integer[]> => double[];
type `contingency2xt` <double[], double[], character, logical, logical, double> => struct<`test.name`:character, `t`:integer, `KW.cont`:double[], `null.dist`:double[], `method`:character, `Nsim`:double> | struct<`test.name`:character, `t`:integer, `KW.cont`:double[], `null.dist`:null, `method`:character, `Nsim`:double>;
type `contingency2xt.comb` <tuple<double[], double[]>, character, logical, double> => struct<`test.name`:character, `t`:double[], `M`:integer, `kw.list`:tuple<double[], double[]>, `kw.c`:double[], `null.dist`:null, `method`:character, `Nsim`:double>;
type `conv` <double[], double[], double[], double[]> => ^double[];
type `djt` <double[], integer[]> => double[];
type `f` <double[], double[], double[], double[], double[], double, integer[]> => double[];
type `filter` <character[]> => logical[];
type `fx` <double, integer[], double> => double;
type `Harding` <integer[]> => double[];
type `io` <double[] | tuple<double[], double[]>, symbol> => tuple<double[], double[]>;
type `io2` <tuple<double[], double[], double[]>, symbol> => tuple<tuple<double[], double[], double[]>, tuple<double[], double[]>>;
type `jt.test` <double[], null, character, logical, double> => struct<`test.name`:character, `k`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `JT`:double[], `warning`:logical, `null.dist`:null, `method`:character, `Nsim`:double>;
type `JTmusig` <double[], integer[]> => struct<`mu`:double, `sig`:double>;
type `na.remove` <tuple<double[], double[]> | tuple<tuple<double[], double[]>>> => struct<`x.new`:tuple<double[], double[]>, `na.total`:double> | struct<`x.new`:tuple<tuple<double[], double[]>>, `na.total`:double>;
type `pjt` <double[], integer[]> => double[];
type `pmaxWilcox` <double, integer[]> => double;
type `pp.kSamples` <struct<`test.name`:character, `k`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `qn`:double[], `warning`:logical, `null.dist`:double[], `method`:character, `Nsim`:double>> => null;
type `ProbWilcox` <double[], integer, integer[]> => double;
type `qdiscrete` <double[], double> => struct<`cm`:double, `cp`:double>;
type `qjt` <double[], integer[]> => double[];
type `qmaxWilcox` <double, integer[]> => double;
type `qn.test` <double[] | tuple<double[], double[]>, null, character, character, logical, double> => struct<`test.name`:character, `k`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `qn`:double[], `warning`:logical, `null.dist`:double[], `method`:character, `Nsim`:double> | struct<`test.name`:character, `k`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `qn`:double[], `warning`:logical, `null.dist`:null, `method`:character, `Nsim`:double>;
type `qn.test.combined` <tuple<double[], double[], double[]>, null, character[], character, logical, double> => struct<`test.name`:character, `M`:integer, `n.samples`:tuple<integer[], integer[]>, `nt`:integer[], `n.ties`:integer[], `qn.list`:tuple<double[], double[]>, `qn.c`:double[], `warning`:logical, `null.dist`:null, `method`:character, `Nsim`:double>;
type `Steel.test` <tuple<double[], double[], double[], double[]>, null, character, character, logical, double> => struct<`test.name`:character, `k`:integer, `alternative`:character, `ns`:integer[], `N`:integer, `n.ties`:integer, `st`:double[], `warning`:logical, `null.dist`:null, `method`:character, `Nsim`:double, `W`:double[], `mu`:double[], `tau`:double[], `sig0`:double, `sig`:double[]>;
type `SteelConfInt` <tuple<double[], double[], double[], double[]>, null, double, character, character, double> => struct<`test.name`:character, `n1`:integer, `ns`:integer[], `N`:integer, `n.ties`:integer, `bounds`:struct<`conservative.bounds.asymptotic`:struct<`L`:double[], `U`:double[], `level`:integer[]>, `closest.bounds.asymptotic`:struct<`L`:double[], `U`:double[], `level`:integer[]>, `conservative.bounds.simulated`:struct<`L`:double[], `U`:double[], `level`:integer[]>, `closest.bounds.simulated`:struct<`L`:double[], `U`:double[], `level`:integer[]>>, `method`:character, `Nsim`:double, `i.LU`:^double[], `i.LUX`:^double[]>;
type `Steelnormal` <double[], double, double[], double[], double[], integer[], character, logical> => double;
type `test.list` <tuple<tuple<double[], double[], double[]>, tuple<double[], double[]>>> => tuple<tuple<double[], double[], double[]>, tuple<double[], double[]>>;
