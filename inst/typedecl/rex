type `%==%` <logical, logical> => logical;
type `%if_next_is%` <character, character> => character;
type `%if_next_isnt%` <character, character> => character;
type `%if_prev_is%` <character, character> => character;
type `%or%` <tuple<character, character>, character> => character;
type `add_options` <character, ? character> => character;
type `add_type` <character, character[]> => character;
type `as.character.regex` <character, ???> => character;
type `at_least` <character, double, character[]> => character;
type `auto_name` <character> => character;
type `between` <character, double, double | character, character[]> => character;
type `capture` <character, ? character> => character;
type `capture_group` <character | double> => character;
type `character_class` <character> => character;
type `character_class_escape_dots` <character> => character[];
type `character_class_escape.character` <character> => character;
type `character_class_escape.list` <tuple<character>> => tuple<character>;
type `character_class_escape.regex` <character> => character;
type `escape_dots` <character> => character[];
type `escape.character` <character> => character;
type `escape.character_class` <character> => character;
type `escape.list` <tuple<character> | struct<``:character>> => tuple<character> | struct<``:character>;
type `escape.regex` <character> => character;
type `except` <character> => character;
type `except_some_of` <character, character[]> => character;
type `filter` <character[]> => logical[];
type `fun` <symbol, symbol> => environment;
type `group` <character> => character;
type `match_args` <character, character[]> => character;
type `maybe` <character, language> => character;
type `no_capture` <integer[]> => logical;
type `none_of` <character> => character;
type `one_of` <character> => character;
type `one_or_more` <character, character[]> => character;
type `or` <character> => character;
type `p` <character[] | tuple<character, character> | struct<``:character>> => character;
type `range` <character, character> => character;
type `re_matches` <character[], character, logical, null, logical, ???> => struct<`1`:^character[]> | logical[];
type `re_substitutes` <character[], character, character, logical, ? character, ???> => character[];
type `regex` <character, ???> => character;
type `register` <any => any> => environment;
type `rex` <character | language | symbol, language> => character;
type `rex_` <struct<``:struct<`expr`:character, `env`:environment>> | struct<``:struct<`expr`:language, `env`:environment>> | struct<``:struct<`expr`:symbol, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:language, `env`:environment>, ``:struct<`expr`:symbol, `env`:environment>>, symbol> => character;
type `sanitize` <character, character[]> => character;
type `zero_or_more` <character, character[]> => character;
type `::` <character, language> => character;
