type `::` <character | language | tuple<symbol> | double | tuple<null, null> | environment, character[] | environment | language | integer | ???, ??? | environment | logical, logical | symbol | character, ? symbol, character | symbol | logical, environment | logical, ? logical, logical, character, character> => ? language | struct<> | character[] | any => any | double[] | struct<`wrapr unit tests`:struct<`nTestFunc`:double, `nDeactivated`:integer, `nErr`:double, `nFail`:double, `dirs`:character, `testFileRegexp`:character, `testFuncRegexp`:character, `sourceFileResults`:struct<`/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_assoc.R`:struct<`test_assoc`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_build_frame_dates.R`:struct<`test_build_frame_dates`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_build_frame.R`:struct<`test_build_frame`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_coalesce.R`:struct<`test_coalesce`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_c.R`:struct<`test_c`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_dot_quote.R`:struct<`test_dot_quote`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_draw_frame.R`:struct<`test_draw_frame`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_fn_composition.R`:struct<`test_fn_composition`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_fn_test.R`:struct<`test_fn_test`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_letl.R`:struct<`test_letl`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_let_null.R`:struct<`test_let_null`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_let.R`:struct<`test_let`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_magrittr_issues.R`:struct<`test_magrittr_issues`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_mk_formula.R`:struct<`test_mk_formula`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_named_map_builder.R`:struct<`test_named_map_builder`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_pipe_paper.R`:struct<`test_pipe_paper`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_pipe_quote_name.R`:struct<`test_pipe_quote_name`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_pipe.R`:struct<`test_pipe`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_qae.R`:struct<`test_qae`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_qchar_frame.R`:struct<`test_qchar_frame`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_qc.R`:struct<`test_qc`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_slots.R`:struct<`test_slots`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_split_braces.R`:struct<`test_split_braces`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_strict.R`:struct<`test_strict`:struct<`kind`:character, `checkNum`:double, `time`:double>>, `/mnt/arraySSD/alexi/RLibs/wrapr/unit_tests/test_str_stuff.R`:struct<`test_str_stuff`:struct<`kind`:character, `checkNum`:double, `time`:double>>>>>;
type `:::` <character[], logical> => language | symbol;
type `:=.character` <character[], character[] | double[]> => character[] | double[];
type `(` <integer[]> => double[];
type `%?%` <? ^double[] | tuple<double, null, null> | tuple<> | struct<`a`:double, `b`:null>, ^double[] | tuple<tuple<double>> | tuple<double> | tuple<>> => ? ^double[] | tuple<double, double, null> | tuple<double, null, null> | struct<`a`:double, `b`:double>;
type `%.>%` <double | character | language | symbol, language | symbol | double> => ? any => any | character[] | struct<> | double[] | tuple<language> | struct<`stages`:tuple<struct<`pipe_right_arg`:language, `pipe_environment`:environment, `left_arg_name`:null, `pipe_string`:character, `right_arg_name`:null>>> | symbol;
type `%.|%` <integer[], language | symbol> => integer;
type `%+%` <language, character | language> => language;
type `%c%` <character[] | integer[], character | integer[]> => character[] | integer[];
type `%dot%` <double[], double[]> => double;
type `%in_block%` <character[], language> => struct<`Sepal_Length`:double[], `Sepal_Width`:double[], `Species`:integer[], `Sepal_area`:double[]>;
type `%p%` <character[], character> => character[];
type `%qc%` <language | symbol, language | symbol> => character[];
type `add_name_column` <struct<`a`:struct<`x`:double>, `b`:struct<`x`:double>>, character> => struct<`a`:struct<`x`:double, `name`:character>, `b`:struct<`x`:double, `name`:character>>;
type `apply_left_default` <any => any | struct<> | struct<`1`:struct<`x`:integer[], `g`:double[], `s`:double[]>, `2`:struct<`x`:integer[], `g`:double[], `s`:double[]>> | double[], language, environment, symbol, symbol, symbol> => ? any => any | struct<> | double[];
type `apply_left.Collector` <tuple<> | tuple<language>, language, environment, symbol, symbol, symbol> => tuple<language>;
type `apply_left.default` <any => any | struct<> | struct<`1`:struct<`x`:integer[], `g`:double[], `s`:double[]>, `2`:struct<`x`:integer[], `g`:double[], `s`:double[]>> | double[], language, environment, symbol, symbol, symbol> => ? any => any | struct<> | double[];
type `apply_left.UnaryFn` <environment, symbol, symbol, symbol> => language;
type `apply_right_S4` <character | struct<>, character | struct<>, symbol, symbol, symbol, symbol> => character | struct<>;
type `apply_right.default` <character | struct<>, character | struct<>, environment, symbol, symbol, symbol> => character | struct<>;
type `apply_right.UnaryFn` <double[] | struct<>, environment, symbol, symbol | character, symbol> => double[];
type `ApplyTo` <double[] | struct<>, symbol | environment | language> => double[];
type `as_dot_fn` <language, environment> => any => any;
type `as_fn` <environment> => any => any;
type `as_fnlist` <environment> => tuple<null, null>;
type `as.list.UnaryFn` <???> => tuple<>;
type `as.list.UnaryFnList` <???> => tuple<null, null>;
type `as.UnaryFn` <environment> => tuple<null, null>;
type `bquote_call_args` <language, environment> => struct<`q`:double, `x`:double>;
type `bquote_function` <any => any> => any => any;
type `build_frame` <character | language, environment> => struct<`cyl`:double[], `mpg`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[], `kpl`:double[]>;
type `buildNameCallback` <character> => any => any;
type `c.UnaryFn` <null, null> => null;
type `clean_fit_glm` <character, character[], struct<`x1`:character[], `x2`:double[], `y`:integer[], `yC`:logical[]>, ???, any => any, logical, null, character, null, environment> => struct<`model`:struct<`coefficients`:double[], `R`:^double[], `rank`:integer, `qr`:struct<`rank`:integer, `qraux`:double[], `pivot`:integer[], `tol`:double>, `family`:struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `simulate`:any => any>, `deviance`:double, `aic`:double, `null.deviance`:double, `iter`:integer, `df.residual`:integer, `df.null`:integer, `converged`:logical, `boundary`:logical, `formula`:language, `terms`:language, `offset`:null, `control`:struct<`epsilon`:double, `maxit`:double, `trace`:logical>, `method`:character, `contrasts`:struct<`x1`:character>, `xlevels`:struct<`x1`:character[]>>, `summary`:struct<`call`:language, `terms`:language, `family`:struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `simulate`:any => any>, `deviance`:double, `aic`:double, `contrasts`:struct<`x1`:character>, `df.residual`:integer, `null.deviance`:double, `df.null`:integer, `iter`:integer, `deviance.resid`:double[], `coefficients`:^double[], `aliased`:logical[], `dispersion`:double, `df`:integer[], `cov.unscaled`:^double[], `cov.scaled`:^double[]>>;
type `clean_fit_lm` <character, character[], struct<`x1`:character[], `x2`:double[], `y`:integer[], `yC`:logical[]>, ???, logical, null, environment> => struct<`model`:struct<`coefficients`:double[], `rank`:integer, `assign`:integer[], `qr`:struct<`qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `contrasts`:struct<`x1`:character>, `xlevels`:struct<`x1`:character[]>, `terms`:language>, `summary`:struct<`call`:language, `terms`:language, `weights`:double[], `residuals`:double[], `coefficients`:^double[], `aliased`:logical[], `sigma`:double, `df`:integer[], `r.squared`:double, `adj.r.squared`:double, `fstatistic`:double[], `cov.unscaled`:^double[]>>;
type `coalesce` <^double[] | tuple<double, null, null> | struct<`a`:double, `b`:null>, ^double[] | tuple<tuple<double>> | tuple<double>> => ^double[] | tuple<double, double, null> | tuple<double, null, null, null, null> | struct<`a`:double, `b`:double>;
type `Collector` < > => tuple<>;
type `concat_items_rev` <tuple<>, tuple<>> => tuple<>;
type `DebugFn` <character, any => any, double> => integer;
type `DebugFnE` <character, any => any, double> => integer;
type `DebugFnW` <character | any => any | symbol, any => any> => any => any;
type `DebugFnWE` <character, any => any, ???> => any => any;
type `DebugPrintFn` <character, any => any, double> => integer;
type `DebugPrintFnE` <character, any => any, double> => integer;
type `defineLambda` <environment, null> => any => any;
type `draw_frame` <struct<`id`:integer[], `x`:^double[], `res`:^character[]>, ???, character, tuple<>, double> => character;
type `draw_framec` <struct<`flower_part`:character[], `Length`:character[], `Width`:character[]>, ???, character[], double> => character;
type `early_tries` <character | language | symbol, character | double | language | symbol, symbol> => null;
type `eval_dot_sequence` <character, tuple<language, language>, environment> => character;
type `evalb` <language, environment> => null;
type `execute_parallel` <struct<`d`:struct<`x`:integer[], `g`:double[]>>, any => any, character, ???, tuple<struct<`con`:integer, `host`:character, `rank`:integer>, struct<`con`:integer, `host`:character, `rank`:integer>>, logical, environment> => struct<`1`:struct<`x`:integer[], `g`:double[], `s`:double[]>, `2`:struct<`x`:integer[], `g`:double[], `s`:double[]>>;
type `f` <double | ???, double, logical, null> => double | character;
type `f2` <language | symbol> => symbol;
type `filter` <character[]> => logical[];
type `fnlist` <null, null> => null;
type `format.PartialFunction` <???> => character;
type `format.PartialNamedFn` <???> => character;
type `format.SrcFunction` <???> => character;
type `format.UnaryFnList` <???> => character;
type `FUN` <? symbol | language | character | struct<`pipe_right_arg`:language, `pipe_environment`:environment, `left_arg_name`:null, `pipe_string`:character, `right_arg_name`:null> | double[]> => ? symbol | double | struct<`1`:struct<`a`:integer[], `g`:double[]>, `2`:struct<`a`:integer[], `g`:double[]>, `3`:struct<`a`:integer[], `g`:double[]>> | struct<`1`:struct<`x`:integer[], `g`:double[]>, `2`:struct<`x`:integer[], `g`:double[]>> | ??? | struct<`d`:struct<`x`:integer[], `g`:double[]>> | struct<`d1`:struct<`a`:integer[], `g`:double[]>, `d2`:struct<`x`:integer, `g`:integer>, `d3`:struct<`y`:double>> | tuple<character> | tuple<double> | tuple<null> | language | character[];
type `fv` <language> => double[];
type `g` <double, double> => double;
type `grepdf` <character, struct<`xa`:double, `yb`:double>, ???, logical, logical, logical, logical, logical, logical> => character;
type `grepv` <character, character[], ???, logical, logical, logical, logical, logical> => character;
type `invert_perm` <double[]> => integer[];
type `isValidAndUnreservedName` <character> => logical;
type `l` <symbol, environment> => any => any;
type `lambda` <symbol, environment> => any => any;
type `lapplym` <double[], any => any, ???> => list<double>;
type `let` <? struct<`X`:character> | character[] | struct<`RankColumn`:character, `GroupColumn`:character> | struct<`NEWCOL`:character> | struct<`x`:character, `y`:character> | struct<`z`:symbol>, language, ???, environment, character, logical, logical, logical> => ? character | struct<> | double[] | struct<`y`:character, `X2`:character, `v1`:double, `v2`:double, `fX`:double[]>;
type `letprep_str` <struct<`NEWCOL`:character> | struct<`X`:character, `F`:character> | struct<`X`:character, `Y`:character>, character> => expression;
type `makeFunction_se` <tuple<symbol, symbol> | character[] | symbol, language, environment> => any => any;
type `map_to_char` <^character[] | ^double[], ???, character, character, any => any> => character;
type `map_upper` <symbol> => struct<`X`:character>;
type `mapsyms` <symbol> => struct<`x`:character, `y`:character>;
type `match_order` <double[], double[]> => integer[];
type `mk_formula` <character, character[], ???, logical, ? double, character, environment, null> => language;
type `mk_tmp_name_source` <character, ???, character[], double, character> => any => any;
type `orderv` <struct<`date`:double[], `measure`:character[], `value`:double[]> | struct<`x`:double[], `y`:integer[]>, ???, logical, logical, character[]> => integer[];
type `parLapplyLBm` <tuple<struct<`con`:integer, `host`:character, `rank`:integer>, struct<`con`:integer, `host`:character, `rank`:integer>>, double[], any => any, ???, null> => list<double>;
type `partition_tables` <character[], character, ???, null, null, struct<`d`:struct<`x`:integer[], `g`:double[]>> | struct<`d1`:struct<`a`:integer[], `g`:double[]>, `d2`:struct<`x`:integer[], `g`:integer[]>, `d3`:struct<`y`:double>>, ? symbol> => struct<`1`:struct<`d`:struct<`x`:integer[], `g`:double[]>>, `2`:struct<`d`:struct<`x`:integer[], `g`:double[]>>> | struct<`1`:struct<`d1`:struct<`a`:integer[], `g`:double[]>, `d2`:struct<`x`:integer, `g`:integer>, `d3`:struct<`y`:double>>, `2`:struct<`d1`:struct<`a`:integer[], `g`:double[]>, `d2`:struct<`x`:integer, `g`:integer>, `d3`:struct<`y`:double>>, `3`:struct<`d1`:struct<`a`:integer[], `g`:double[]>, `d2`:struct<`x`:integer, `g`:integer>, `d3`:struct<`y`:double>>>;
type `pipe_impl` <double | character | language | symbol, language | double | character, environment, symbol | language | character> => ? any => any | character | struct<> | double[] | language | tuple<language> | struct<`stages`:tuple<struct<`pipe_right_arg`:language, `pipe_environment`:environment, `left_arg_name`:null, `pipe_string`:character, `right_arg_name`:null>>>;
type `pkgfn` <character, tuple<> | struct<`object`:struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`log(y)`:double[], `x`:double[]>>>> => character;
type `plotb` <language, language, ???> => null;
type `prepareAlias` <? tuple<> | character[] | struct<`NEWCOL`:character> | struct<`RankColumn`:character, `GroupColumn`:character> | struct<`X`:character> | struct<`x`:character, `y`:character> | struct<`z`:symbol>, logical> => tuple<> | struct<`AREA_COL`:character, `LENGTH_COL`:character, `WIDTH_COL`:character> | struct<`NEWCOL`:character> | struct<`RankColumn`:character, `GroupColumn`:character> | struct<`X`:character> | struct<`x`:character, `y`:character> | struct<`XVARIABLE`:character, `YVARIABLE`:character> | struct<`z`:character>;
type `print.locum` <struct<`stages`:tuple<struct<`pipe_right_arg`:language, `pipe_environment`:environment, `left_arg_name`:null, `pipe_string`:character, `right_arg_name`:null>>>, double> => null;
type `psagg` <character[], ???, logical> => character;
type `qae` <double | language> => character[];
type `qc` <symbol | character | language, environment> => character[];
type `qchar_frame` <symbol | language> => struct<`col_1`:character[], `col_2`:character[], `col_3`:character[]>;
type `qe` <language> => character[];
type `qs` <language> => language;
type `qts` <^character[]> => character[];
type `r_plus` <character[], logical> => language | symbol;
type `reduceexpand` <language | symbol, integer[], environment> => integer;
type `restrictToNameAssignments` <struct<`region`:character, `str`:character>, logical> => struct<`region`:character>;
type `saveDest` <struct<`fn`:any => any, `args`:tuple<double>, `namedargs`:language, `fn_name`:character>> => struct<`fn`:any => any, `args`:tuple<double>, `namedargs`:language, `fn_name`:character>;
type `seqi` <double, double> => double[];
type `sequence_as_function` <tuple<language, language>, environment> => any => any;
type `sinterp` <character, ???, struct<`x`:integer[], `y`:integer[]> | environment | struct<`x`:double>, environment, character, character[]> => character[];
type `sortv` <struct<`x`:double[], `y`:integer[]>, character[], ???, logical, logical, character[]> => struct<`x`:double[], `y`:integer[]>;
type `split_at_brace_pairs` <character, character, character> => character[];
type `srcfn` <character, struct<`y`:double> | struct<`z`:double>> => character;
type `stop_if_dot_args` <language, character> => null;
type `strsplit_capture` <character, character, ???, logical, logical, logical, logical> => tuple<character, character> | list<character>;
type `to_vector` <tuple<character> | tuple<double>> => ^character[] | ^double[];
type `uniques` <character[], ???, logical, double, logical> => character[];
type `unpack_val` <character | language | double> => tuple<character> | tuple<double>;
type `vapplym` <double[], any => any, double, ???, logical> => double[];
type `VectorizeM` <any => any, character, logical, logical, logical> => any => any;
type `view.data.frame` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, ???, character, double> => character[];
type `wrapfn` <character, tuple<>> => any => any;
type `wrapr_deparse` <double | language | symbol> => character;
