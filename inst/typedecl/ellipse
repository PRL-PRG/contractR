type `ellipse.arima0` <struct<`coef`:double[], `sigma2`:double, `var.coef`:^double[], `mask`:logical[], `loglik`:double, `aic`:double, `arma`:double[], `residuals`:double[], `call`:language, `series`:character, `code`:integer, `n.cond`:integer>, double[], double, double, ???> => ^double[];
type `ellipse.default` <^double[], language | double[], double[], double, double, double[] | language, double, ???> => ^double[];
type `ellipse.glm` <struct<`coefficients`:double[], `residuals`:double[], `fitted.values`:double[], `effects`:double[], `R`:^double[], `rank`:integer, `qr`:struct<`qr`:^double[], `rank`:integer, `qraux`:double[], `pivot`:integer[], `tol`:double>, `family`:struct<`family`:character, `link`:character, `linkfun`:any => any, `linkinv`:any => any, `variance`:any => any, `dev.resids`:any => any, `aic`:any => any, `mu.eta`:any => any, `initialize`:expression, `validmu`:any => any, `valideta`:any => any, `simulate`:any => any>, `linear.predictors`:double[], `deviance`:double, `aic`:double, `null.deviance`:double, `iter`:integer, `weights`:double[], `prior.weights`:double[], `df.residual`:integer, `df.null`:integer, `y`:double[], `converged`:logical, `boundary`:logical, `model`:struct<`counts`:double[], `outcome`:integer[], `treatment`:integer[]>, `call`:language, `formula`:language, `terms`:language, `data`:environment, `offset`:null, `control`:struct<`epsilon`:double, `maxit`:double, `trace`:logical>, `method`:character, `contrasts`:struct<`outcome`:character, `treatment`:character>, `xlevels`:struct<`outcome`:character[], `treatment`:character[]>>, double[], double, ???, double, ???, ???> => ^double[];
type `ellipse.lm` <struct<`coefficients`:double[], `residuals`:double[], `effects`:double[], `rank`:integer, `fitted.values`:double[], `assign`:integer[], `qr`:struct<`qr`:^double[], `qraux`:double[], `pivot`:integer[], `tol`:double, `rank`:integer>, `df.residual`:integer, `xlevels`:tuple<>, `call`:language, `terms`:language, `model`:struct<`mpg`:double[], `disp`:double[], `cyl`:double[]>>, character[], double, double, ???> => ^double[];
type `ellipse.nls` <struct<`m`:struct<`resid`:any => any, `fitted`:any => any, `formula`:any => any, `deviance`:any => any, `lhs`:any => any, `gradient`:any => any, `conv`:any => any, `incr`:any => any, `setVarying`:any => any, `setPars`:any => any, `getPars`:any => any, `getAllPars`:any => any, `getEnv`:any => any, `trace`:any => any, `Rmat`:any => any, `predict`:any => any>, `convInfo`:struct<`isConv`:logical, `finIter`:integer, `finTol`:double, `stopCode`:integer, `stopMessage`:character>, `data`:symbol, `call`:language, `dataClasses`:character[], `control`:struct<`maxiter`:double, `tol`:double, `minFactor`:double, `printEval`:logical, `warnOnly`:logical>> | struct<`m`:struct<`resid`:any => any, `fitted`:any => any, `formula`:any => any, `deviance`:any => any, `lhs`:any => any, `gradient`:any => any, `conv`:any => any, `incr`:any => any, `setVarying`:any => any, `setPars`:any => any, `getPars`:any => any, `getAllPars`:any => any, `getEnv`:any => any, `trace`:any => any, `Rmat`:any => any, `predict`:any => any>, `convInfo`:struct<`isConv`:logical, `finIter`:integer, `finTol`:double, `stopCode`:integer, `stopMessage`:character>, `data`:symbol, `call`:language, `dataClasses`:character, `control`:struct<`maxiter`:double, `tol`:double, `minFactor`:double, `printEval`:logical, `warnOnly`:logical>>, character[], double, double, ???> => ^double[];
type `ellipse.profile` <struct<`(Intercept)`:struct<`z`:double[], `par.vals`:^double[]>, `outcome2`:struct<`z`:double[], `par.vals`:^double[]>, `outcome3`:struct<`z`:double[], `par.vals`:^double[]>, `treatment2`:struct<`z`:double[], `par.vals`:^double[]>, `treatment3`:struct<`z`:double[], `par.vals`:^double[]>> | struct<`Vm`:struct<`tau`:double[], `par.vals`:^double[]>, `delV`:struct<`tau`:double[], `par.vals`:^double[]>, `K`:struct<`tau`:double[], `par.vals`:^double[]>>, integer[] | character[], symbol, double, double, ???> => ^double[];
type `ellipse.profile.glm` <struct<`(Intercept)`:struct<`z`:double[], `par.vals`:^double[]>, `outcome2`:struct<`z`:double[], `par.vals`:^double[]>, `outcome3`:struct<`z`:double[], `par.vals`:^double[]>, `treatment2`:struct<`z`:double[], `par.vals`:^double[]>, `treatment3`:struct<`z`:double[], `par.vals`:^double[]>>, integer[], double, ???, double, ???, ???> => ^double[];
type `ellipse.profile.nls` <struct<`Vm`:struct<`tau`:double[], `par.vals`:^double[]>, `delV`:struct<`tau`:double[], `par.vals`:^double[]>, `K`:struct<`tau`:double[], `par.vals`:^double[]>>, character[], double, double, double, ???> => ^double[];
type `filter` <character[]> => logical[];
type `getad` <double, double> => double[];
type `myapprox` <double[], double[], double[]> => double[];
type `pairs.default` <struct<`POP`:double[], `MOR`:integer[], `CAR`:double[], `DR`:double[], `GNP`:double[], `DEN`:double[], `TB`:double[]>, ???> => null;
