type `filter` <character[]> => logical[];
type `check_result` <logical> => logical;
type `see_if` <language, environment, ? symbol> => logical;
type `[[` <struct<`message`:character, `call`:null>> => logical;
type `%||%` <? any => any | integer[], ? language | symbol | any => any | integer> => ? any => any | integer[];
type `%has_args%` <any => any, character> => logical;
type `%has_attr%` <double, character> => logical;
type `%has_name%` <struct<`a`:double, `b`:double>, character> => logical;
type `are_equal` <double, double, double | ???> => logical;
type `assertError` <character, null> => struct<`message`:character, `call`:null>;
type `fail` <language, environment | symbol> => character;
type `get_message` <logical, language, environment> => character;
type `has_args` <any => any, character, logical> => logical;
type `has_attr` <any => any | logical, character> => logical;
type `is.count` <double> => logical;
type `is.date` <double> => logical;
type `is.dir` <character> => logical;
type `is.error` <character> => logical;
type `is.flag` <character | integer[]> => logical;
type `is.integerish` <character | double> => logical;
type `is.number` <double | integer[]> => logical;
type `is.readable` <character> => logical;
type `is.scalar` <character | integer[]> => logical;
type `is.string` <character[] | double | integer[]> => logical;
type `is.time` <double> => logical;
type `is.writeable` <character> => logical;
type `noNA` <character | ^integer[]> => logical;
type `not_empty` <struct<> | double[]> => logical;
type `on_failure` <any => any> => ? any => any;
type `on_failure<-` <any => any, any => any> => any => any;
