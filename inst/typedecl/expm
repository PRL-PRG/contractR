type `::` <^double[], logical | character[], double, logical, language | double, logical, language | character[]> => ^double[];
type `:::` <^double[], double> => ^double[];
type `.expmCond.1` <^double[], logical> => double | struct<`condExpm`:double, `expm`:^double[]>;
type `.expmCond.F` <^double[], double, double, double, logical> => struct<`condExpm`:double, `expm`:^double[]>;
type `.expmCond.X` <^double[], character, logical> => struct<`expmCondF`:double, `expmCond1`:double, `expm`:^double[]>;
type `.expmFrechet2008.26` <^double[], ^double[], logical> => struct<`Lexpm`:^double[]>;
type `%^%` <^double[], double> => ^double[];
type `balance` <^double[], character[]> => struct<`z`:^double[], `scale`:double[], `i1`:integer, `i2`:integer>;
type `dgebal` <^double[], character[]> => struct<`z`:^double[], `scale`:double[], `i1`:integer, `i2`:integer>;
type `E.unit` <integer, integer> => ^double[];
type `expAtv` <^double[], double[], double, character | double, double, double, double, double, double, logical> => struct<`eAtv`:double[], `error`:double, `nstep`:integer, `n.reject`:integer>;
type `expm` <^double[], character[], double, logical, language | double, logical, language | character[]> => ^double[];
type `expm.AlMoHi09` <^double[], double> => ^double[];
type `expm.Higham08` <^double[], logical> => ^double[];
type `expm.s.Pade.s` <^double[], double, integer> => ^double[];
type `expmCond` <^double[], character, logical, double, double, character[]> => double | struct<`condExpm`:double, `expm`:^double[]> | struct<`expmCondF`:double, `expmCond1`:double, `expm`:^double[]>;
type `expmFrechet` <^double[], ^double[], character[], logical> => struct<`Lexpm`:^double[]>;
type `filter` <character[]> => logical[];
type `logm` <^double[], character[], language | double> => ^double[];
type `logm.Higham08` <^double[]> => ^double[];
type `myRound` <double> => double;
type `rootS` <^double[]> => ^double[];
type `sqrtm` <^double[]> => ^complex[];
