type `cc_and` <character[] | double[]> => character;
type `cc_or` <character[]> => character;
type `check_attributes` <double | integer[], ? struct<`y`:integer[]>, logical, logical, logical, logical, symbol | character, logical> => double | integer[];
type `check_character` <character[] | integer[], logical, character | language, logical> => character[] | integer[];
type `check_chr` <character[] | double, logical, language | character | double, logical> => character[] | double;
type `check_class_internal` <character[] | double[] | ^integer[], ? ^character[] | ^double[], character, logical> => character[] | double[] | ^integer[];
type `check_classes` <tuple<>, character[], logical, logical, language, logical> => tuple<>;
type `check_colnames` <struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>, character[], logical, logical, character | symbol, logical> => struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>;
type `check_count` <double, logical, double | language, logical> => double;
type `check_data` <struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>, ? struct<`Count`:double, `Extra`:null, `Latitude`:double[]>, ? integer, logical, logical, character[], symbol | character, logical> => struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>;
type `check_date` <double, logical, language, logical> => double;
type `check_dbl` <double[], logical, language | double, logical> => double[];
type `check_dttm` <double, logical, character, language, logical> => double;
type `check_environment` <double | environment, double | symbol, logical> => double | environment;
type `check_flag` <logical, logical, symbol, logical> => logical;
type `check_flag_internal` <logical> => null;
type `check_function` <any => any, ? integer, symbol, logical> => any => any;
type `check_grepl` <character[], character, symbol, character, logical> => character[];
type `check_homogenous` <tuple<double, double>, logical, logical, language, logical> => tuple<double, double>;
type `check_inherits` <struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]> | tuple<>, character, character | language, logical> => struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]> | tuple<>;
type `check_int` <double | integer[], logical, double | language, logical> => double | integer[];
type `check_integer` <double | integer[], logical, double | language, logical> => double | integer[];
type `check_intersection` <integer[], integer[], logical, symbol, symbol, logical> => integer[];
type `check_join` <struct<`x`:integer[]>, struct<`x`:integer[], `y`:integer[]>, ? character, logical, symbol, symbol, logical> => struct<`x`:integer[]>;
type `check_key` <struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>, character[], logical, character | symbol, logical | symbol> => struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>;
type `check_length` <? character[] | double[] | tuple<> | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer>, ? double | integer[], ? language | character | double, logical> => ? character[] | double[] | tuple<> | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer>;
type `check_length_internal` <? double | integer[]> => null;
type `check_length1` <? double | integer[] | tuple<>, ? double | language, logical> => ? double | integer[] | tuple<>;
type `check_levels` <double, character[], logical, logical, double | language, logical> => double;
type `check_lgl` <double | logical[], logical, double | language | character, logical> => double | logical[];
type `check_list` <tuple<> | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer>, ? struct<`x1`:double, `x2`:integer> | struct<`y`:integer[]>, null, logical, null, logical, logical, language | character, logical> => tuple<> | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer>;
type `check_logical` <double | logical[], logical, double | language, logical> => double | logical[];
type `check_missing_colnames` <struct<`x`:double, `y`:double, `z`:double>, character[], symbol, logical> => struct<`x`:double, `y`:double, `z`:double>;
type `check_missing_names` <double[], character[], symbol, logical> => double[];
type `check_name` <character[], symbol, logical, logical> => character[];
type `check_named` <double[] | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer[]>, integer[] | language, character, symbol, logical, character | double | symbol, logical> => double[] | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer[]>;
type `check_names` <double[] | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer>, character[], logical, logical, logical, logical, symbol, logical> => double[] | struct<`x1`:double, `x2`:integer[]> | struct<`y`:integer>;
type `check_nas` <character[] | double[] | ^integer[], ? ^character[] | ^double[], character, logical> => character[] | double[] | ^integer[];
type `check_nchar` <character[], double | integer[], language | character, logical> => character[];
type `check_ncol` <struct<`x`:double>, double, language, logical> => struct<`x`:double>;
type `check_neg_dbl` <double, logical, double, logical> => double;
type `check_neg_int` <integer, logical, integer | language, logical> => integer;
type `check_nlevels` <integer, double, language, logical> => integer;
type `check_no_attributes` <character[] | double[], logical, logical, character | symbol, logical> => character[] | double[];
type `check_noneg_dbl` <double, logical, double, logical> => double;
type `check_noneg_int` <double, logical, character | double, logical> => double;
type `check_nrow` <struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>, ? double, character | language, logical> => struct<`Count`:^integer[], `Longitude`:double[], `Latitude`:double[], `Type`:integer[], `Extra`:logical[], `Comments`:character[]>;
type `check_null` <? double, ? double | symbol, logical> => ? double;
type `check_numeric` <double | integer[], logical, double | language, logical> => double | integer[];
type `check_pos_dbl` <double, logical, double, logical> => double;
type `check_pos_int` <double | integer[], logical, double | language, logical> => double | integer[];
type `check_prob` <double[], logical, language | double, logical> => double[];
type `check_rbind` <struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>, logical, logical, language, language, logical> => struct<`mpg`:double[], `cyl`:double[], `disp`:double[], `hp`:double[], `drat`:double[], `wt`:double[], `qsec`:double[], `vs`:double[], `am`:double[], `gear`:double[], `carb`:double[]>;
type `check_scalar` <character[] | double[], ? character | double[], logical, logical, logical, character | language | double, logical> => character[] | double[];
type `check_sorted` <integer[], character | language, logical> => integer[];
type `check_string` <character, logical, symbol, logical> => character;
type `check_string_internal` <character> => null;
type `check_tzone` <double, character, language | symbol, logical> => double;
type `check_unique` <? character[] | double[] | tuple<>, ? character | language | double, logical> => ? character[] | double[] | tuple<>;
type `check_unnamed` <character[] | double[], character | double | symbol, logical> => character[] | double[];
type `check_unused` <double | ???, character, logical> => ? double;
type `check_values` <character[] | double[], character[] | double[], logical, character, logical> => character[] | double[];
type `check_vector` <character[] | double[], ? ^character[] | ^double[], ? integer[] | double, logical, logical, ? logical, ? logical, logical, logical, logical, character | language | symbol, logical> => character[] | double[];
type `checkor` <language, logical> => logical;
type `chk_deparse` <? character | double | language | symbol> => character;
type `chk_fail` <character, logical> => character;
type `chk_max_dbl` < > => double;
type `chk_max_int` < > => integer;
type `chk_min_dbl` < > => double;
type `chk_min_int` < > => integer;
type `chk_tiny_dbl` < > => double;
type `co_and` <character[], character, language | symbol> => character;
type `err_deparse` <language | symbol> => character;
type `filter` <character[]> => logical[];
type `FUN` <? character | language> => ? character | logical;
type `is_count` <? double | integer[]> => logical;
type `is_count_range` <? double | integer[]> => logical;
type `is_flag` <? double | integer[]> => logical;
type `is_length` <? double | integer[]> => logical;
type `is_NA` <? double | integer[]> => logical;
type `is_string` <? character> => logical;
type `is.POSIXt` <double> => logical;
type `new_duplicated` <struct<`Longitude`:double[]>, logical, logical, ???> => logical[];
type `tz` <double> => character;
