#include "contract.hpp"
#include "r_api.hpp"
#include "utilities.hpp"

std::vector<ContractAssertion*> contracts;
std::vector<bool> contract_status;

void initialize_contracts() {
    contract_status.push_back(true);
}

void add_contract(ContractAssertion* contract) {
    contracts.push_back(contract);
}

const ContractAssertion& get_contract(int index) {
    return *contracts[index];
}

SEXP r_clear_contracts() {
    for (int i = 0; i < contracts.size(); ++i) {
        delete contracts[i];
    }
    contracts.clear();
    return R_NilValue;
}

void destroy_r_contract(SEXP r_contract) {
    ContractAssertion* contract =
        static_cast<ContractAssertion*>(R_ExternalPtrAddr(r_contract));
    if (contract) {
        delete contract;
        R_SetExternalPtrAddr(r_contract, nullptr);
    }
}

SEXP create_r_contract(ContractAssertion* contract) {
    SEXP externalptr =
        PROTECT(R_MakeExternalPtr(contract, R_NilValue, R_NilValue));

    R_RegisterCFinalizerEx(externalptr, destroy_r_contract, TRUE);

    UNPROTECT(1);

    return externalptr;
}

SEXP r_enable_contracts() {
    contract_status.push_back(true);
    return R_NilValue;
}

SEXP r_disable_contracts() {
    contract_status.push_back(false);
    return R_NilValue;
}

SEXP r_reinstate_contract_status() {
    contract_status.pop_back();
    return R_NilValue;
}

bool contracts_are_enabled() {
    return contract_status.back();
}

bool contracts_are_disabled() {
    return !contracts_are_enabled();
}

SEXP r_capture_contracts(SEXP sym, SEXP env, SEXP r_separate) {
    bool separate = asLogical(r_separate);
    std::vector<ContractAssertion*> saved_contracts(std::move(contracts));
    contracts = std::vector<ContractAssertion*>();

    PROTECT(sym);
    PROTECT(env);

    SEXP code = PROTECT(Rf_findVarInFrame(env, sym));
    SEXP result = PROTECT(Rf_eval(code, env));
    SEXP r_contracts = PROTECT(r_get_contracts());

    /*  delete contracts generated by this code block  */
    if (separate) {
        r_clear_contracts();
    }
    /* merge contracts with the previously created ones */
    else {
        saved_contracts.reserve(saved_contracts.size() + contracts.size());
        saved_contracts.insert(
            saved_contracts.end(), contracts.begin(), contracts.end());
    }

    contracts = std::move(saved_contracts);

    SEXP list =
        PROTECT(create_list({result, r_contracts}, {"result", "contracts"}));

    UNPROTECT(6);

    return list;
}


SEXP r_get_contracts() {
    int size = contracts.size();

    auto get_call_id = [](int index) -> int {
        return get_contract(index).get_call_id();
    };

    auto get_call_trace = [](int index) -> std::string {
        return get_contract(index).get_call_trace();
    };

    auto get_package_name = [](int index) -> std::string {
        return get_contract(index).get_package_name();
    };

    auto get_function_name = [](int index) -> std::string {
        return get_contract(index).get_function_name();
    };

    auto get_actual_parameter_count = [](int index) -> int {
        return get_contract(index).get_actual_parameter_count();
    };

    auto get_expected_parameter_count = [](int index) -> int {
        return get_contract(index).get_expected_parameter_count();
    };

    auto get_parameter_position = [](int index) -> int {
        return get_contract(index).get_parameter_position();
    };

    auto get_parameter_name = [](int index) -> std::string {
        return get_contract(index).get_parameter_name();
    };

    auto get_actual_type = [](int index) -> std::string {
        return get_contract(index).get_actual_type();
    };

    auto get_expected_type = [](int index) -> std::string {
        return get_contract(index).get_expected_type();
    };

    auto get_assertion_status = [](int index) -> bool {
        return get_contract(index).get_assertion_status();
    };

    std::vector<SEXP> columns = {
        PROTECT(create_integer_vector(size, get_call_id)),
        PROTECT(create_character_vector(size, get_call_trace)),
        PROTECT(create_character_vector(size, get_package_name)),
        PROTECT(create_character_vector(size, get_function_name)),
        PROTECT(create_integer_vector(size, get_actual_parameter_count)),
        PROTECT(create_integer_vector(size, get_expected_parameter_count)),
        PROTECT(create_integer_vector(size, get_parameter_position)),
        PROTECT(create_character_vector(size, get_parameter_name)),
        PROTECT(create_character_vector(size, get_actual_type)),
        PROTECT(create_character_vector(size, get_expected_type)),
        PROTECT(create_logical_vector(size, get_assertion_status))};

    std::vector<std::string> names = {"call_id",
                                      "call_trace",
                                      "package_name",
                                      "function_name",
                                      "actual_parameter_count",
                                      "expected_parameter_count",
                                      "parameter_position",
                                      "parameter_name",
                                      "actual_type",
                                      "expected_type",
                                      "assertion_status"};

    SEXP df = PROTECT(create_data_frame(columns, names));

    UNPROTECT(columns.size() + 1);

    return df;
}
